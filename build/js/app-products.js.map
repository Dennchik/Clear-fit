{"version":3,"names":[],"mappings":"","sources":["app-products.js"],"sourcesContent":["//* --------------------------------[jScript]-----------------------------------\nwindow.onload = function () {\n\tdocument.querySelector('.preloader').classList.add(\"preloader-remove\");\n};\n\nclass ItcCollapse {\n\tconstructor(target, duration = 350) {\n\t\tthis._target = target;\n\t\tthis._duration = duration;\n\t}\n\tshow() {\n\t\tconst el = this._target;\n\t\tif (el.classList.contains('collapsing') || el.classList.contains('_show')) {\n\t\t\treturn;\n\t\t}\n\t\tel.classList.remove('_collapse');\n\t\tconst height = el.offsetHeight;\n\t\tel.style.height = 0;\n\t\tel.style.overflow = 'hidden';\n\t\tel.style.transition = `height ${this._duration}ms ease`;\n\t\tel.classList.add('collapsing');\n\t\tel.offsetHeight;\n\t\tel.style.height = `${height}px`;\n\t\twindow.setTimeout(() => {\n\t\t\tel.classList.remove('collapsing');\n\t\t\tel.classList.add('_collapse');\n\t\t\tel.classList.add('_show');\n\t\t\tel.style.height = '';\n\t\t\tel.style.transition = '';\n\t\t\tel.style.overflow = '';\n\n\t\t}, this._duration);\n\t}\n\thide() {\n\t\tconst el = this._target;\n\t\tif (el.classList.contains('collapsing') || !el.classList.contains('_show')) {\n\t\t\treturn;\n\t\t}\n\t\tel.style.height = `${el.offsetHeight}px`;\n\t\tel.offsetHeight;\n\t\tel.style.height = 0;\n\t\tel.style.overflow = 'hidden';\n\t\tel.style.transition = `height ${this._duration}ms ease`;\n\t\tel.classList.remove('_collapse');\n\t\tel.classList.remove('_show');\n\t\tel.classList.add('collapsing');\n\t\twindow.setTimeout(() => {\n\t\t\tel.classList.remove('collapsing');\n\t\t\tel.classList.add('_collapse');\n\t\t\tel.style.height = '';\n\t\t\tel.style.transition = '';\n\t\t\tel.style.overflow = '';\n\t\t}, this._duration);\n\t}\n\ttoggle() {\n\t\tthis._target.classList.contains('_show') ? this.hide() : this.show();\n\t}\n}\n\n// === Определение устройства вывода ===\n\"use strict\";\nvar isMobile = {\n\tAndroid: function () {\n\t\treturn navigator.userAgent.match(/Android/i);\n\t},\n\tBlackBerry: () => {\n\t\treturn navigator.userAgent.match(/BlackBerry/i);\n\t},\n\tiOS: () => {\n\t\treturn navigator.userAgent.match(/iPhone|iPad|iPod/i);\n\t},\n\tOpera: () => {\n\t\treturn navigator.userAgent.match(/Opera Mini/i);\n\t},\n\tWindows: () => {\n\t\treturn navigator.userAgent.match(/IEMobile/i);\n\t},\n\n\n\tany: () => {\n\t\treturn (\n\t\t\tisMobile.Android() ||\n\t\t\tisMobile.BlackBerry() ||\n\t\t\tisMobile.iOS() ||\n\t\t\tisMobile.Opera() ||\n\t\t\tisMobile.Windows());\n\t}\n};\n// Dynamic Adapt v.1\n// HTML data-da=\"where(uniq class name),position(digit),when(breakpoint)\"\n// e.x. data-da=\"item,2,992\"\n\n\"use strict\";\n\n(function () {\n\tlet originalPositions = [];\n\tlet daElements = document.querySelectorAll('[data-da]');\n\tlet daElementsArray = [];\n\tlet daMatchMedia = [];\n\t//Заполняем массивы\n\tif (daElements.length > 0) {\n\t\tlet number = 0;\n\t\tfor (let index = 0; index < daElements.length; index++) {\n\t\t\tconst daElement = daElements[index];\n\t\t\tconst daMove = daElement.getAttribute('data-da');\n\t\t\tconst daPlace = daElement.hasAttribute('data-da-position') ? daElement.getAttribute('data-da-position') : 'last';\n\t\t\tconst daResolutionBreakpoint = daElement.hasAttribute('data-da-resolution') ? daElement.getAttribute('data-da-resolution') : 768;\n\t\t\t// noinspection JSCheckFunctionSignatures\n\t\t\tdaElement.setAttribute('data-da-index', number);\n\t\t\t//Заполняем массив первоначальных позиций\n\t\t\toriginalPositions[number] = {\n\t\t\t\t\"parent\": daElement.parentNode,\n\t\t\t\t\"index\": indexInParent(daElement)\n\t\t\t};\n\t\t\t//Заполняем массив элементов\n\t\t\tdaElementsArray[number] = {\n\t\t\t\t\"element\": daElement,\n\t\t\t\t\"destination\": document.querySelector('.' + daMove),\n\t\t\t\t\"place\": daPlace,\n\t\t\t\t\"breakpoint\": daResolutionBreakpoint\n\t\t\t};\n\t\t\tnumber++;\n\t\t}\n\t\tdynamicAdaptSort(daElementsArray);\n\n\t\t//Создаем события в точке брейкпоинта\n\t\tfor (let index = 0; index < daElementsArray.length; index++) {\n\t\t\tconst el = daElementsArray[index];\n\t\t\tconst daBreakpoint = el.breakpoint;\n\t\t\tconst daType = \"max\"; //Для MobileFirst поменять на min\n\n\t\t\tdaMatchMedia.push(window.matchMedia(\"(\" + daType + \"-width: \" + daBreakpoint + \"px)\"));\n\t\t\tdaMatchMedia[index].addListener(dynamicAdapt);\n\t\t}\n\t}\n\n\t//Основная функция\n\tfunction dynamicAdapt() {\n\t\tfor (let index = 0; index < daElementsArray.length; index++) {\n\t\t\tconst el = daElementsArray[index];\n\t\t\tconst daElement = el.element;\n\t\t\tconst daDestination = el.destination;\n\t\t\tconst daPlace = el.place;\n\t\t\tconst daBreakpoint = el.breakpoint;\n\t\t\tconst daClassname = \"_dynamic_adapt_\" + daBreakpoint;\n\n\t\t\tif (daMatchMedia[index].matches) {\n\t\t\t\t//Перебрасываем элементы\n\t\t\t\tif (!daElement.classList.contains(daClassname)) {\n\t\t\t\t\tlet actualIndex = indexOfElements(daDestination)[daPlace];\n\t\t\t\t\tif (daPlace === 'first') {\n\t\t\t\t\t\tactualIndex = indexOfElements(daDestination)[0];\n\t\t\t\t\t} else if (daPlace === 'last') {\n\t\t\t\t\t\tactualIndex = indexOfElements(daDestination)[indexOfElements(daDestination).length];\n\t\t\t\t\t}\n\t\t\t\t\tdaDestination.insertBefore(daElement, daDestination.children[actualIndex]);\n\t\t\t\t\tdaElement.classList.add(daClassname);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t//Возвращаем на место\n\t\t\t\tif (daElement.classList.contains(daClassname)) {\n\t\t\t\t\tdynamicAdaptBack(daElement);\n\t\t\t\t\tdaElement.classList.remove(daClassname);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcustomAdapt();\n\t}\n\n\t//Вызов основной функции\n\tdynamicAdapt();\n\n\t//Функция возврата на место\n\tfunction dynamicAdaptBack(el) {\n\t\tconst daIndex = el.getAttribute('data-da-index');\n\t\tconst originalPlace = originalPositions[daIndex];\n\t\tconst parentPlace = originalPlace['parent'];\n\t\tconst indexPlace = originalPlace['index'];\n\t\tconst actualIndex = indexOfElements(parentPlace, true)[indexPlace];\n\t\tparentPlace.insertBefore(el, parentPlace.children[actualIndex]);\n\t}\n\n\t//Функция получения индекса внутри родителя\n\tfunction indexInParent(el) {\n\t\tconst children = Array.prototype.slice.call(el.parentNode.children);\n\t\treturn children.indexOf(el);\n\t}\n\n\t//Функция получения массива индексов элементов внутри родителя\n\tfunction indexOfElements(parent, back) {\n\t\tconst children = parent.children;\n\t\tconst childrenArray = [];\n\t\tfor (let i = 0; i < children.length; i++) {\n\t\t\tconst childrenElement = children[i];\n\t\t\tif (back) {\n\t\t\t\tchildrenArray.push(i);\n\t\t\t} else {\n\t\t\t\t//Исключая перенесенный элемент\n\t\t\t\tif (childrenElement.getAttribute('data-da') == null) {\n\t\t\t\t\tchildrenArray.push(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn childrenArray;\n\t}\n\n\t//Сортировка объекта\n\tfunction dynamicAdaptSort(arr) {\n\t\tarr.sort(function (a, b) {\n\t\t\tif (a.breakpoint > b.breakpoint) {\n\t\t\t\treturn -1;\n\t\t\t} else {\n\t\t\t\treturn 1;\n\t\t\t} //Для MobileFirst поменять\n\t\t});\n\t\tarr.sort(function (a, b) {\n\t\t\tif (a.place > b.place) {\n\t\t\t\treturn 1;\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t});\n\t}\n\n\t//Дополнительные сценарии адаптации\n\tfunction customAdapt() {\n\t\t// noinspection JSUnusedLocalSymbols\n\t\tconst viewport_width = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);\n\t}\n}());\n\nvar Swiper = (function () {\n\t'use strict';\n\tfunction isObject$1(obj) {\n\t\treturn obj !== null && typeof obj === 'object' && 'constructor' in obj && obj.constructor === Object;\n\t}\n\tfunction extend$1(target, src) {\n\t\tif (target === void 0) {\n\t\t\ttarget = {};\n\t\t}\n\t\tif (src === void 0) {\n\t\t\tsrc = {};\n\t\t}\n\t\tObject.keys(src).forEach(key => {\n\t\t\tif (typeof target[key] === 'undefined') target[key] = src[key]; else if (isObject$1(src[key]) && isObject$1(target[key]) && Object.keys(src[key]).length > 0) {\n\t\t\t\textend$1(target[key], src[key]);\n\t\t\t}\n\t\t});\n\t}\n\tconst ssrDocument = {\n\t\tbody: {},\n\t\taddEventListener() { },\n\t\tremoveEventListener() { },\n\t\tactiveElement: {\n\t\t\tblur() { },\n\t\t\tnodeName: ''\n\t\t},\n\t\tquerySelector() {\n\t\t\treturn null;\n\t\t},\n\t\tquerySelectorAll() {\n\t\t\treturn [];\n\t\t},\n\t\tgetElementById() {\n\t\t\treturn null;\n\t\t},\n\t\tcreateEvent() {\n\t\t\treturn {\n\t\t\t\tinitEvent() { }\n\t\t\t};\n\t\t},\n\t\tcreateElement() {\n\t\t\treturn {\n\t\t\t\tchildren: [],\n\t\t\t\tchildNodes: [],\n\t\t\t\tstyle: {},\n\t\t\t\tsetAttribute() { },\n\t\t\t\tgetElementsByTagName() {\n\t\t\t\t\treturn [];\n\t\t\t\t}\n\t\t\t};\n\t\t},\n\t\tcreateElementNS() {\n\t\t\treturn {};\n\t\t},\n\t\timportNode() {\n\t\t\treturn null;\n\t\t},\n\t\tlocation: {\n\t\t\thash: '',\n\t\t\thost: '',\n\t\t\thostname: '',\n\t\t\thref: '',\n\t\t\torigin: '',\n\t\t\tpathname: '',\n\t\t\tprotocol: '',\n\t\t\tsearch: ''\n\t\t}\n\t};\n\tfunction getDocument() {\n\t\tconst doc = typeof document !== 'undefined' ? document : {};\n\t\textend$1(doc, ssrDocument);\n\t\treturn doc;\n\t}\n\tconst ssrWindow = {\n\t\tdocument: ssrDocument,\n\t\tnavigator: {\n\t\t\tuserAgent: ''\n\t\t},\n\t\tlocation: {\n\t\t\thash: '',\n\t\t\thost: '',\n\t\t\thostname: '',\n\t\t\thref: '',\n\t\t\torigin: '',\n\t\t\tpathname: '',\n\t\t\tprotocol: '',\n\t\t\tsearch: ''\n\t\t},\n\t\thistory: {\n\t\t\treplaceState() { },\n\t\t\tpushState() { },\n\t\t\tgo() { },\n\t\t\tback() { }\n\t\t},\n\t\tCustomEvent: function CustomEvent() {\n\t\t\treturn this;\n\t\t},\n\t\taddEventListener() { },\n\t\tremoveEventListener() { },\n\t\tgetComputedStyle() {\n\t\t\treturn {\n\t\t\t\tgetPropertyValue() {\n\t\t\t\t\treturn '';\n\t\t\t\t}\n\t\t\t};\n\t\t},\n\t\tImage() { },\n\t\tDate() { },\n\t\tscreen: {},\n\t\tsetTimeout() { },\n\t\tclearTimeout() { },\n\t\tmatchMedia() {\n\t\t\treturn {};\n\t\t},\n\t\trequestAnimationFrame(callback) {\n\t\t\tif (typeof setTimeout === 'undefined') {\n\t\t\t\tcallback();\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn setTimeout(callback, 0);\n\t\t},\n\t\tcancelAnimationFrame(id) {\n\t\t\tif (typeof setTimeout === 'undefined') {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tclearTimeout(id);\n\t\t}\n\t};\n\tfunction getWindow() {\n\t\tconst win = typeof window !== 'undefined' ? window : {};\n\t\textend$1(win, ssrWindow);\n\t\treturn win;\n\t}\n\n\tfunction deleteProps(obj) {\n\t\tconst object = obj;\n\t\tObject.keys(object).forEach(key => {\n\t\t\ttry {\n\t\t\t\tobject[key] = null;\n\t\t\t} catch (e) {\n\t\t\t\t// no getter for object\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tdelete object[key];\n\t\t\t} catch (e) {\n\t\t\t\t// something got wrong\n\t\t\t}\n\t\t});\n\t}\n\tfunction nextTick(callback, delay) {\n\t\tif (delay === void 0) {\n\t\t\tdelay = 0;\n\t\t}\n\t\treturn setTimeout(callback, delay);\n\t}\n\tfunction now() {\n\t\treturn Date.now();\n\t}\n\tfunction getComputedStyle$1(el) {\n\t\tconst window = getWindow();\n\t\tlet style;\n\t\tif (window.getComputedStyle) {\n\t\t\tstyle = window.getComputedStyle(el, null);\n\t\t}\n\t\tif (!style && el.currentStyle) {\n\t\t\tstyle = el.currentStyle;\n\t\t}\n\t\tif (!style) {\n\t\t\tstyle = el.style;\n\t\t}\n\t\treturn style;\n\t}\n\tfunction getTranslate(el, axis) {\n\t\tif (axis === void 0) {\n\t\t\taxis = 'x';\n\t\t}\n\t\tconst window = getWindow();\n\t\tlet matrix;\n\t\tlet curTransform;\n\t\tlet transformMatrix;\n\t\tconst curStyle = getComputedStyle$1(el);\n\t\tif (window.WebKitCSSMatrix) {\n\t\t\tcurTransform = curStyle.transform || curStyle.webkitTransform;\n\t\t\tif (curTransform.split(',').length > 6) {\n\t\t\t\tcurTransform = curTransform.split(', ').map(a => a.replace(',', '.')).join(', ');\n\t\t\t}\n\t\t\t// Some old versions of Webkit choke when 'none' is passed; pass\n\t\t\t// empty string instead in this case\n\t\t\ttransformMatrix = new window.WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);\n\t\t} else {\n\t\t\ttransformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');\n\t\t\tmatrix = transformMatrix.toString().split(',');\n\t\t}\n\t\tif (axis === 'x') {\n\t\t\t// Latest Chrome and webkits Fix\n\t\t\tif (window.WebKitCSSMatrix) curTransform = transformMatrix.m41;\n\t\t\t// Crazy IE10 Matrix\n\t\t\telse if (matrix.length === 16) curTransform = parseFloat(matrix[12]);\n\t\t\t// Normal Browsers\n\t\t\telse curTransform = parseFloat(matrix[4]);\n\t\t}\n\t\tif (axis === 'y') {\n\t\t\t// Latest Chrome and webkits Fix\n\t\t\tif (window.WebKitCSSMatrix) curTransform = transformMatrix.m42;\n\t\t\t// Crazy IE10 Matrix\n\t\t\telse if (matrix.length === 16) curTransform = parseFloat(matrix[13]);\n\t\t\t// Normal Browsers\n\t\t\telse curTransform = parseFloat(matrix[5]);\n\t\t}\n\t\treturn curTransform || 0;\n\t}\n\tfunction isObject(o) {\n\t\treturn typeof o === 'object' && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === 'Object';\n\t}\n\tfunction isNode(node) {\n\t\t// eslint-disable-next-line\n\t\tif (typeof window !== 'undefined' && typeof window.HTMLElement !== 'undefined') {\n\t\t\treturn node instanceof HTMLElement;\n\t\t}\n\t\treturn node && (node.nodeType === 1 || node.nodeType === 11);\n\t}\n\tfunction extend() {\n\t\tconst to = Object(arguments.length <= 0 ? undefined : arguments[0]);\n\t\tconst noExtend = ['__proto__', 'constructor', 'prototype'];\n\t\tfor (let i = 1; i < arguments.length; i += 1) {\n\t\t\tconst nextSource = i < 0 || arguments.length <= i ? undefined : arguments[i];\n\t\t\tif (nextSource !== undefined && nextSource !== null && !isNode(nextSource)) {\n\t\t\t\tconst keysArray = Object.keys(Object(nextSource)).filter(key => noExtend.indexOf(key) < 0);\n\t\t\t\tfor (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {\n\t\t\t\t\tconst nextKey = keysArray[nextIndex];\n\t\t\t\t\tconst desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);\n\t\t\t\t\tif (desc !== undefined && desc.enumerable) {\n\t\t\t\t\t\tif (isObject(to[nextKey]) && isObject(nextSource[nextKey])) {\n\t\t\t\t\t\t\tif (nextSource[nextKey].__swiper__) {\n\t\t\t\t\t\t\t\tto[nextKey] = nextSource[nextKey];\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\textend(to[nextKey], nextSource[nextKey]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (!isObject(to[nextKey]) && isObject(nextSource[nextKey])) {\n\t\t\t\t\t\t\tto[nextKey] = {};\n\t\t\t\t\t\t\tif (nextSource[nextKey].__swiper__) {\n\t\t\t\t\t\t\t\tto[nextKey] = nextSource[nextKey];\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\textend(to[nextKey], nextSource[nextKey]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tto[nextKey] = nextSource[nextKey];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn to;\n\t}\n\tfunction setCSSProperty(el, varName, varValue) {\n\t\tel.style.setProperty(varName, varValue);\n\t}\n\tfunction animateCSSModeScroll(_ref) {\n\t\tlet {\n\t\t\tswiper,\n\t\t\ttargetPosition,\n\t\t\tside\n\t\t} = _ref;\n\t\tconst window = getWindow();\n\t\tconst startPosition = -swiper.translate;\n\t\tlet startTime = null;\n\t\tlet time;\n\t\tconst duration = swiper.params.speed;\n\t\tswiper.wrapperEl.style.scrollSnapType = 'none';\n\t\twindow.cancelAnimationFrame(swiper.cssModeFrameID);\n\t\tconst dir = targetPosition > startPosition ? 'next' : 'prev';\n\t\tconst isOutOfBound = (current, target) => {\n\t\t\treturn dir === 'next' && current >= target || dir === 'prev' && current <= target;\n\t\t};\n\t\tconst animate = () => {\n\t\t\ttime = new Date().getTime();\n\t\t\tif (startTime === null) {\n\t\t\t\tstartTime = time;\n\t\t\t}\n\t\t\tconst progress = Math.max(Math.min((time - startTime) / duration, 1), 0);\n\t\t\tconst easeProgress = 0.5 - Math.cos(progress * Math.PI) / 2;\n\t\t\tlet currentPosition = startPosition + easeProgress * (targetPosition - startPosition);\n\t\t\tif (isOutOfBound(currentPosition, targetPosition)) {\n\t\t\t\tcurrentPosition = targetPosition;\n\t\t\t}\n\t\t\tswiper.wrapperEl.scrollTo({\n\t\t\t\t[side]: currentPosition\n\t\t\t});\n\t\t\tif (isOutOfBound(currentPosition, targetPosition)) {\n\t\t\t\tswiper.wrapperEl.style.overflow = 'hidden';\n\t\t\t\tswiper.wrapperEl.style.scrollSnapType = '';\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tswiper.wrapperEl.style.overflow = '';\n\t\t\t\t\tswiper.wrapperEl.scrollTo({\n\t\t\t\t\t\t[side]: currentPosition\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t\twindow.cancelAnimationFrame(swiper.cssModeFrameID);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tswiper.cssModeFrameID = window.requestAnimationFrame(animate);\n\t\t};\n\t\tanimate();\n\t}\n\tfunction getSlideTransformEl(slideEl) {\n\t\treturn slideEl.querySelector('.swiper-slide-transform') || slideEl.shadowRoot && slideEl.shadowRoot.querySelector('.swiper-slide-transform') || slideEl;\n\t}\n\tfunction elementChildren(element, selector) {\n\t\tif (selector === void 0) {\n\t\t\tselector = '';\n\t\t}\n\t\treturn [...element.children].filter(el => el.matches(selector));\n\t}\n\tfunction createElement(tag, classes) {\n\t\tif (classes === void 0) {\n\t\t\tclasses = [];\n\t\t}\n\t\tconst el = document.createElement(tag);\n\t\tel.classList.add(...(Array.isArray(classes) ? classes : [classes]));\n\t\treturn el;\n\t}\n\tfunction elementOffset(el) {\n\t\tconst window = getWindow();\n\t\tconst document = getDocument();\n\t\tconst box = el.getBoundingClientRect();\n\t\tconst body = document.body;\n\t\tconst clientTop = el.clientTop || body.clientTop || 0;\n\t\tconst clientLeft = el.clientLeft || body.clientLeft || 0;\n\t\tconst scrollTop = el === window ? window.scrollY : el.scrollTop;\n\t\tconst scrollLeft = el === window ? window.scrollX : el.scrollLeft;\n\t\treturn {\n\t\t\ttop: box.top + scrollTop - clientTop,\n\t\t\tleft: box.left + scrollLeft - clientLeft\n\t\t};\n\t}\n\tfunction elementPrevAll(el, selector) {\n\t\tconst prevEls = [];\n\t\twhile (el.previousElementSibling) {\n\t\t\tconst prev = el.previousElementSibling; // eslint-disable-line\n\t\t\tif (selector) {\n\t\t\t\tif (prev.matches(selector)) prevEls.push(prev);\n\t\t\t} else prevEls.push(prev);\n\t\t\tel = prev;\n\t\t}\n\t\treturn prevEls;\n\t}\n\tfunction elementNextAll(el, selector) {\n\t\tconst nextEls = [];\n\t\twhile (el.nextElementSibling) {\n\t\t\tconst next = el.nextElementSibling; // eslint-disable-line\n\t\t\tif (selector) {\n\t\t\t\tif (next.matches(selector)) nextEls.push(next);\n\t\t\t} else nextEls.push(next);\n\t\t\tel = next;\n\t\t}\n\t\treturn nextEls;\n\t}\n\tfunction elementStyle(el, prop) {\n\t\tconst window = getWindow();\n\t\treturn window.getComputedStyle(el, null).getPropertyValue(prop);\n\t}\n\tfunction elementIndex(el) {\n\t\tlet child = el;\n\t\tlet i;\n\t\tif (child) {\n\t\t\ti = 0;\n\t\t\t// eslint-disable-next-line\n\t\t\twhile ((child = child.previousSibling) !== null) {\n\t\t\t\tif (child.nodeType === 1) i += 1;\n\t\t\t}\n\t\t\treturn i;\n\t\t}\n\t\treturn undefined;\n\t}\n\tfunction elementParents(el, selector) {\n\t\tconst parents = []; // eslint-disable-line\n\t\tlet parent = el.parentElement; // eslint-disable-line\n\t\twhile (parent) {\n\t\t\tif (selector) {\n\t\t\t\tif (parent.matches(selector)) parents.push(parent);\n\t\t\t} else {\n\t\t\t\tparents.push(parent);\n\t\t\t}\n\t\t\tparent = parent.parentElement;\n\t\t}\n\t\treturn parents;\n\t}\n\tfunction elementTransitionEnd(el, callback) {\n\t\tfunction fireCallBack(e) {\n\t\t\tif (e.target !== el) return;\n\t\t\tcallback.call(el, e);\n\t\t\tel.removeEventListener('transitionend', fireCallBack);\n\t\t}\n\t\tif (callback) {\n\t\t\tel.addEventListener('transitionend', fireCallBack);\n\t\t}\n\t}\n\tfunction elementOuterSize(el, size, includeMargins) {\n\t\tconst window = getWindow();\n\t\tif (includeMargins) {\n\t\t\treturn el[size === 'width' ? 'offsetWidth' : 'offsetHeight'] + parseFloat(window.getComputedStyle(el, null).getPropertyValue(size === 'width' ? 'margin-right' : 'margin-top')) + parseFloat(window.getComputedStyle(el, null).getPropertyValue(size === 'width' ? 'margin-left' : 'margin-bottom'));\n\t\t}\n\t\treturn el.offsetWidth;\n\t}\n\n\tlet support;\n\tfunction calcSupport() {\n\t\tconst window = getWindow();\n\t\tconst document = getDocument();\n\t\treturn {\n\t\t\tsmoothScroll: document.documentElement && document.documentElement.style && 'scrollBehavior' in document.documentElement.style,\n\t\t\ttouch: !!('ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch)\n\t\t};\n\t}\n\tfunction getSupport() {\n\t\tif (!support) {\n\t\t\tsupport = calcSupport();\n\t\t}\n\t\treturn support;\n\t}\n\n\tlet deviceCached;\n\tfunction calcDevice(_temp) {\n\t\tlet {\n\t\t\tuserAgent\n\t\t} = _temp === void 0 ? {} : _temp;\n\t\tconst support = getSupport();\n\t\tconst window = getWindow();\n\t\tconst platform = window.navigator.platform;\n\t\tconst ua = userAgent || window.navigator.userAgent;\n\t\tconst device = {\n\t\t\tios: false,\n\t\t\tandroid: false\n\t\t};\n\t\tconst screenWidth = window.screen.width;\n\t\tconst screenHeight = window.screen.height;\n\t\tconst android = ua.match(/(Android);?[\\s\\/]+([\\d.]+)?/); // eslint-disable-line\n\t\tlet ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/);\n\t\tconst ipod = ua.match(/(iPod)(.*OS\\s([\\d_]+))?/);\n\t\tconst iphone = !ipad && ua.match(/(iPhone\\sOS|iOS)\\s([\\d_]+)/);\n\t\tconst windows = platform === 'Win32';\n\t\tlet macos = platform === 'MacIntel';\n\n\t\t// iPadOs 13 fix\n\t\tconst iPadScreens = ['1024x1366', '1366x1024', '834x1194', '1194x834', '834x1112', '1112x834', '768x1024', '1024x768', '820x1180', '1180x820', '810x1080', '1080x810'];\n\t\tif (!ipad && macos && support.touch && iPadScreens.indexOf(`${screenWidth}x${screenHeight}`) >= 0) {\n\t\t\tipad = ua.match(/(Version)\\/([\\d.]+)/);\n\t\t\tif (!ipad) ipad = [0, 1, '13_0_0'];\n\t\t\tmacos = false;\n\t\t}\n\n\t\t// Android\n\t\tif (android && !windows) {\n\t\t\tdevice.os = 'android';\n\t\t\tdevice.android = true;\n\t\t}\n\t\tif (ipad || iphone || ipod) {\n\t\t\tdevice.os = 'ios';\n\t\t\tdevice.ios = true;\n\t\t}\n\n\t\t// Export object\n\t\treturn device;\n\t}\n\tfunction getDevice(overrides) {\n\t\tif (overrides === void 0) {\n\t\t\toverrides = {};\n\t\t}\n\t\tif (!deviceCached) {\n\t\t\tdeviceCached = calcDevice(overrides);\n\t\t}\n\t\treturn deviceCached;\n\t}\n\n\tlet browser;\n\tfunction calcBrowser() {\n\t\tconst window = getWindow();\n\t\tlet needPerspectiveFix = false;\n\t\tfunction isSafari() {\n\t\t\tconst ua = window.navigator.userAgent.toLowerCase();\n\t\t\treturn ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0;\n\t\t}\n\t\tif (isSafari()) {\n\t\t\tconst ua = String(window.navigator.userAgent);\n\t\t\tif (ua.includes('Version/')) {\n\t\t\t\tconst [major, minor] = ua.split('Version/')[1].split(' ')[0].split('.').map(num => Number(num));\n\t\t\t\tneedPerspectiveFix = major < 16 || major === 16 && minor < 2;\n\t\t\t}\n\t\t}\n\t\treturn {\n\t\t\tisSafari: needPerspectiveFix || isSafari(),\n\t\t\tneedPerspectiveFix,\n\t\t\tisWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window.navigator.userAgent)\n\t\t};\n\t}\n\tfunction getBrowser() {\n\t\tif (!browser) {\n\t\t\tbrowser = calcBrowser();\n\t\t}\n\t\treturn browser;\n\t}\n\n\tfunction Resize(_ref) {\n\t\tlet {\n\t\t\tswiper,\n\t\t\ton,\n\t\t\temit\n\t\t} = _ref;\n\t\tconst window = getWindow();\n\t\tlet observer = null;\n\t\tlet animationFrame = null;\n\t\tconst resizeHandler = () => {\n\t\t\tif (!swiper || swiper.destroyed || !swiper.initialized) return;\n\t\t\temit('beforeResize');\n\t\t\temit('resize');\n\t\t};\n\t\tconst createObserver = () => {\n\t\t\tif (!swiper || swiper.destroyed || !swiper.initialized) return;\n\t\t\tobserver = new ResizeObserver(entries => {\n\t\t\t\tanimationFrame = window.requestAnimationFrame(() => {\n\t\t\t\t\tconst {\n\t\t\t\t\t\twidth,\n\t\t\t\t\t\theight\n\t\t\t\t\t} = swiper;\n\t\t\t\t\tlet newWidth = width;\n\t\t\t\t\tlet newHeight = height;\n\t\t\t\t\tentries.forEach(_ref2 => {\n\t\t\t\t\t\tlet {\n\t\t\t\t\t\t\tcontentBoxSize,\n\t\t\t\t\t\t\tcontentRect,\n\t\t\t\t\t\t\ttarget\n\t\t\t\t\t\t} = _ref2;\n\t\t\t\t\t\tif (target && target !== swiper.el) return;\n\t\t\t\t\t\tnewWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;\n\t\t\t\t\t\tnewHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;\n\t\t\t\t\t});\n\t\t\t\t\tif (newWidth !== width || newHeight !== height) {\n\t\t\t\t\t\tresizeHandler();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t\tobserver.observe(swiper.el);\n\t\t};\n\t\tconst removeObserver = () => {\n\t\t\tif (animationFrame) {\n\t\t\t\twindow.cancelAnimationFrame(animationFrame);\n\t\t\t}\n\t\t\tif (observer && observer.unobserve && swiper.el) {\n\t\t\t\tobserver.unobserve(swiper.el);\n\t\t\t\tobserver = null;\n\t\t\t}\n\t\t};\n\t\tconst orientationChangeHandler = () => {\n\t\t\tif (!swiper || swiper.destroyed || !swiper.initialized) return;\n\t\t\temit('orientationchange');\n\t\t};\n\t\ton('init', () => {\n\t\t\tif (swiper.params.resizeObserver && typeof window.ResizeObserver !== 'undefined') {\n\t\t\t\tcreateObserver();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\twindow.addEventListener('resize', resizeHandler);\n\t\t\twindow.addEventListener('orientationchange', orientationChangeHandler);\n\t\t});\n\t\ton('destroy', () => {\n\t\t\tremoveObserver();\n\t\t\twindow.removeEventListener('resize', resizeHandler);\n\t\t\twindow.removeEventListener('orientationchange', orientationChangeHandler);\n\t\t});\n\t}\n\n\tfunction Observer(_ref) {\n\t\tlet {\n\t\t\tswiper,\n\t\t\textendParams,\n\t\t\ton,\n\t\t\temit\n\t\t} = _ref;\n\t\tconst observers = [];\n\t\tconst window = getWindow();\n\t\tconst attach = function (target, options) {\n\t\t\tif (options === void 0) {\n\t\t\t\toptions = {};\n\t\t\t}\n\t\t\tconst ObserverFunc = window.MutationObserver || window.WebkitMutationObserver;\n\t\t\tconst observer = new ObserverFunc(mutations => {\n\t\t\t\t// The observerUpdate event should only be triggered\n\t\t\t\t// once despite the number of mutations.  Additional\n\t\t\t\t// triggers are redundant and are very costly\n\t\t\t\tif (swiper.__preventObserver__) return;\n\t\t\t\tif (mutations.length === 1) {\n\t\t\t\t\temit('observerUpdate', mutations[0]);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst observerUpdate = function observerUpdate() {\n\t\t\t\t\temit('observerUpdate', mutations[0]);\n\t\t\t\t};\n\t\t\t\tif (window.requestAnimationFrame) {\n\t\t\t\t\twindow.requestAnimationFrame(observerUpdate);\n\t\t\t\t} else {\n\t\t\t\t\twindow.setTimeout(observerUpdate, 0);\n\t\t\t\t}\n\t\t\t});\n\t\t\tobserver.observe(target, {\n\t\t\t\tattributes: typeof options.attributes === 'undefined' ? true : options.attributes,\n\t\t\t\tchildList: typeof options.childList === 'undefined' ? true : options.childList,\n\t\t\t\tcharacterData: typeof options.characterData === 'undefined' ? true : options.characterData\n\t\t\t});\n\t\t\tobservers.push(observer);\n\t\t};\n\t\tconst init = () => {\n\t\t\tif (!swiper.params.observer) return;\n\t\t\tif (swiper.params.observeParents) {\n\t\t\t\tconst containerParents = elementParents(swiper.hostEl);\n\t\t\t\tfor (let i = 0; i < containerParents.length; i += 1) {\n\t\t\t\t\tattach(containerParents[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Observe container\n\t\t\tattach(swiper.hostEl, {\n\t\t\t\tchildList: swiper.params.observeSlideChildren\n\t\t\t});\n\n\t\t\t// Observe wrapper\n\t\t\tattach(swiper.wrapperEl, {\n\t\t\t\tattributes: false\n\t\t\t});\n\t\t};\n\t\tconst destroy = () => {\n\t\t\tobservers.forEach(observer => {\n\t\t\t\tobserver.disconnect();\n\t\t\t});\n\t\t\tobservers.splice(0, observers.length);\n\t\t};\n\t\textendParams({\n\t\t\tobserver: false,\n\t\t\tobserveParents: false,\n\t\t\tobserveSlideChildren: false\n\t\t});\n\t\ton('init', init);\n\t\ton('destroy', destroy);\n\t}\n\n\t/* eslint-disable no-underscore-dangle */\n\n\tvar eventsEmitter = {\n\t\ton(events, handler, priority) {\n\t\t\tconst self = this;\n\t\t\tif (!self.eventsListeners || self.destroyed) return self;\n\t\t\tif (typeof handler !== 'function') return self;\n\t\t\tconst method = priority ? 'unshift' : 'push';\n\t\t\tevents.split(' ').forEach(event => {\n\t\t\t\tif (!self.eventsListeners[event]) self.eventsListeners[event] = [];\n\t\t\t\tself.eventsListeners[event][method](handler);\n\t\t\t});\n\t\t\treturn self;\n\t\t},\n\t\tonce(events, handler, priority) {\n\t\t\tconst self = this;\n\t\t\tif (!self.eventsListeners || self.destroyed) return self;\n\t\t\tif (typeof handler !== 'function') return self;\n\t\t\tfunction onceHandler() {\n\t\t\t\tself.off(events, onceHandler);\n\t\t\t\tif (onceHandler.__emitterProxy) {\n\t\t\t\t\tdelete onceHandler.__emitterProxy;\n\t\t\t\t}\n\t\t\t\tfor (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n\t\t\t\t\targs[_key] = arguments[_key];\n\t\t\t\t}\n\t\t\t\thandler.apply(self, args);\n\t\t\t}\n\t\t\tonceHandler.__emitterProxy = handler;\n\t\t\treturn self.on(events, onceHandler, priority);\n\t\t},\n\t\tonAny(handler, priority) {\n\t\t\tconst self = this;\n\t\t\tif (!self.eventsListeners || self.destroyed) return self;\n\t\t\tif (typeof handler !== 'function') return self;\n\t\t\tconst method = priority ? 'unshift' : 'push';\n\t\t\tif (self.eventsAnyListeners.indexOf(handler) < 0) {\n\t\t\t\tself.eventsAnyListeners[method](handler);\n\t\t\t}\n\t\t\treturn self;\n\t\t},\n\t\toffAny(handler) {\n\t\t\tconst self = this;\n\t\t\tif (!self.eventsListeners || self.destroyed) return self;\n\t\t\tif (!self.eventsAnyListeners) return self;\n\t\t\tconst index = self.eventsAnyListeners.indexOf(handler);\n\t\t\tif (index >= 0) {\n\t\t\t\tself.eventsAnyListeners.splice(index, 1);\n\t\t\t}\n\t\t\treturn self;\n\t\t},\n\t\toff(events, handler) {\n\t\t\tconst self = this;\n\t\t\tif (!self.eventsListeners || self.destroyed) return self;\n\t\t\tif (!self.eventsListeners) return self;\n\t\t\tevents.split(' ').forEach(event => {\n\t\t\t\tif (typeof handler === 'undefined') {\n\t\t\t\t\tself.eventsListeners[event] = [];\n\t\t\t\t} else if (self.eventsListeners[event]) {\n\t\t\t\t\tself.eventsListeners[event].forEach((eventHandler, index) => {\n\t\t\t\t\t\tif (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) {\n\t\t\t\t\t\t\tself.eventsListeners[event].splice(index, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn self;\n\t\t},\n\t\temit() {\n\t\t\tconst self = this;\n\t\t\tif (!self.eventsListeners || self.destroyed) return self;\n\t\t\tif (!self.eventsListeners) return self;\n\t\t\tlet events;\n\t\t\tlet data;\n\t\t\tlet context;\n\t\t\tfor (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n\t\t\t\targs[_key2] = arguments[_key2];\n\t\t\t}\n\t\t\tif (typeof args[0] === 'string' || Array.isArray(args[0])) {\n\t\t\t\tevents = args[0];\n\t\t\t\tdata = args.slice(1, args.length);\n\t\t\t\tcontext = self;\n\t\t\t} else {\n\t\t\t\tevents = args[0].events;\n\t\t\t\tdata = args[0].data;\n\t\t\t\tcontext = args[0].context || self;\n\t\t\t}\n\t\t\tdata.unshift(context);\n\t\t\tconst eventsArray = Array.isArray(events) ? events : events.split(' ');\n\t\t\teventsArray.forEach(event => {\n\t\t\t\tif (self.eventsAnyListeners && self.eventsAnyListeners.length) {\n\t\t\t\t\tself.eventsAnyListeners.forEach(eventHandler => {\n\t\t\t\t\t\teventHandler.apply(context, [event, ...data]);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tif (self.eventsListeners && self.eventsListeners[event]) {\n\t\t\t\t\tself.eventsListeners[event].forEach(eventHandler => {\n\t\t\t\t\t\teventHandler.apply(context, data);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn self;\n\t\t}\n\t};\n\n\tfunction updateSize() {\n\t\tconst swiper = this;\n\t\tlet width;\n\t\tlet height;\n\t\tconst el = swiper.el;\n\t\tif (typeof swiper.params.width !== 'undefined' && swiper.params.width !== null) {\n\t\t\twidth = swiper.params.width;\n\t\t} else {\n\t\t\twidth = el.clientWidth;\n\t\t}\n\t\tif (typeof swiper.params.height !== 'undefined' && swiper.params.height !== null) {\n\t\t\theight = swiper.params.height;\n\t\t} else {\n\t\t\theight = el.clientHeight;\n\t\t}\n\t\tif (width === 0 && swiper.isHorizontal() || height === 0 && swiper.isVertical()) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Subtract paddings\n\t\twidth = width - parseInt(elementStyle(el, 'padding-left') || 0, 10) - parseInt(elementStyle(el, 'padding-right') || 0, 10);\n\t\theight = height - parseInt(elementStyle(el, 'padding-top') || 0, 10) - parseInt(elementStyle(el, 'padding-bottom') || 0, 10);\n\t\tif (Number.isNaN(width)) width = 0;\n\t\tif (Number.isNaN(height)) height = 0;\n\t\tObject.assign(swiper, {\n\t\t\twidth,\n\t\t\theight,\n\t\t\tsize: swiper.isHorizontal() ? width : height\n\t\t});\n\t}\n\n\tfunction updateSlides() {\n\t\tconst swiper = this;\n\t\tfunction getDirectionLabel(property) {\n\t\t\tif (swiper.isHorizontal()) {\n\t\t\t\treturn property;\n\t\t\t}\n\t\t\t// prettier-ignore\n\t\t\treturn {\n\t\t\t\t'width': 'height',\n\t\t\t\t'margin-top': 'margin-left',\n\t\t\t\t'margin-bottom ': 'margin-right',\n\t\t\t\t'margin-left': 'margin-top',\n\t\t\t\t'margin-right': 'margin-bottom',\n\t\t\t\t'padding-left': 'padding-top',\n\t\t\t\t'padding-right': 'padding-bottom',\n\t\t\t\t'marginRight': 'marginBottom'\n\t\t\t}[property];\n\t\t}\n\t\tfunction getDirectionPropertyValue(node, label) {\n\t\t\treturn parseFloat(node.getPropertyValue(getDirectionLabel(label)) || 0);\n\t\t}\n\t\tconst params = swiper.params;\n\t\tconst {\n\t\t\twrapperEl,\n\t\t\tslidesEl,\n\t\t\tsize: swiperSize,\n\t\t\trtlTranslate: rtl,\n\t\t\twrongRTL\n\t\t} = swiper;\n\t\tconst isVirtual = swiper.virtual && params.virtual.enabled;\n\t\tconst previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;\n\t\tconst slides = elementChildren(slidesEl, `.${swiper.params.slideClass}, swiper-slide`);\n\t\tconst slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;\n\t\tlet snapGrid = [];\n\t\tconst slidesGrid = [];\n\t\tconst slidesSizesGrid = [];\n\t\tlet offsetBefore = params.slidesOffsetBefore;\n\t\tif (typeof offsetBefore === 'function') {\n\t\t\toffsetBefore = params.slidesOffsetBefore.call(swiper);\n\t\t}\n\t\tlet offsetAfter = params.slidesOffsetAfter;\n\t\tif (typeof offsetAfter === 'function') {\n\t\t\toffsetAfter = params.slidesOffsetAfter.call(swiper);\n\t\t}\n\t\tconst previousSnapGridLength = swiper.snapGrid.length;\n\t\tconst previousSlidesGridLength = swiper.slidesGrid.length;\n\t\tlet spaceBetween = params.spaceBetween;\n\t\tlet slidePosition = -offsetBefore;\n\t\tlet prevSlideSize = 0;\n\t\tlet index = 0;\n\t\tif (typeof swiperSize === 'undefined') {\n\t\t\treturn;\n\t\t}\n\t\tif (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {\n\t\t\tspaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiperSize;\n\t\t} else if (typeof spaceBetween === 'string') {\n\t\t\tspaceBetween = parseFloat(spaceBetween);\n\t\t}\n\t\tswiper.virtualSize = -spaceBetween;\n\n\t\t// reset margins\n\t\tslides.forEach(slideEl => {\n\t\t\tif (rtl) {\n\t\t\t\tslideEl.style.marginLeft = '';\n\t\t\t} else {\n\t\t\t\tslideEl.style.marginRight = '';\n\t\t\t}\n\t\t\tslideEl.style.marginBottom = '';\n\t\t\tslideEl.style.marginTop = '';\n\t\t});\n\n\t\t// reset cssMode offsets\n\t\tif (params.centeredSlides && params.cssMode) {\n\t\t\tsetCSSProperty(wrapperEl, '--swiper-centered-offset-before', '');\n\t\t\tsetCSSProperty(wrapperEl, '--swiper-centered-offset-after', '');\n\t\t}\n\t\tconst gridEnabled = params.grid && params.grid.rows > 1 && swiper.grid;\n\t\tif (gridEnabled) {\n\t\t\tswiper.grid.initSlides(slidesLength);\n\t\t}\n\n\t\t// Calc slides\n\t\tlet slideSize;\n\t\tconst shouldResetSlideSize = params.slidesPerView === 'auto' && params.breakpoints && Object.keys(params.breakpoints).filter(key => {\n\t\t\treturn typeof params.breakpoints[key].slidesPerView !== 'undefined';\n\t\t}).length > 0;\n\t\tfor (let i = 0; i < slidesLength; i += 1) {\n\t\t\tslideSize = 0;\n\t\t\tlet slide;\n\t\t\tif (slides[i]) slide = slides[i];\n\t\t\tif (gridEnabled) {\n\t\t\t\tswiper.grid.updateSlide(i, slide, slidesLength, getDirectionLabel);\n\t\t\t}\n\t\t\tif (slides[i] && elementStyle(slide, 'display') === 'none') continue; // eslint-disable-line\n\n\t\t\tif (params.slidesPerView === 'auto') {\n\t\t\t\tif (shouldResetSlideSize) {\n\t\t\t\t\tslides[i].style[getDirectionLabel('width')] = ``;\n\t\t\t\t}\n\t\t\t\tconst slideStyles = getComputedStyle(slide);\n\t\t\t\tconst currentTransform = slide.style.transform;\n\t\t\t\tconst currentWebKitTransform = slide.style.webkitTransform;\n\t\t\t\tif (currentTransform) {\n\t\t\t\t\tslide.style.transform = 'none';\n\t\t\t\t}\n\t\t\t\tif (currentWebKitTransform) {\n\t\t\t\t\tslide.style.webkitTransform = 'none';\n\t\t\t\t}\n\t\t\t\tif (params.roundLengths) {\n\t\t\t\t\tslideSize = swiper.isHorizontal() ? elementOuterSize(slide, 'width', true) : elementOuterSize(slide, 'height', true);\n\t\t\t\t} else {\n\t\t\t\t\t// eslint-disable-next-line\n\t\t\t\t\tconst width = getDirectionPropertyValue(slideStyles, 'width');\n\t\t\t\t\tconst paddingLeft = getDirectionPropertyValue(slideStyles, 'padding-left');\n\t\t\t\t\tconst paddingRight = getDirectionPropertyValue(slideStyles, 'padding-right');\n\t\t\t\t\tconst marginLeft = getDirectionPropertyValue(slideStyles, 'margin-left');\n\t\t\t\t\tconst marginRight = getDirectionPropertyValue(slideStyles, 'margin-right');\n\t\t\t\t\tconst boxSizing = slideStyles.getPropertyValue('box-sizing');\n\t\t\t\t\tif (boxSizing && boxSizing === 'border-box') {\n\t\t\t\t\t\tslideSize = width + marginLeft + marginRight;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst {\n\t\t\t\t\t\t\tclientWidth,\n\t\t\t\t\t\t\toffsetWidth\n\t\t\t\t\t\t} = slide;\n\t\t\t\t\t\tslideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (currentTransform) {\n\t\t\t\t\tslide.style.transform = currentTransform;\n\t\t\t\t}\n\t\t\t\tif (currentWebKitTransform) {\n\t\t\t\t\tslide.style.webkitTransform = currentWebKitTransform;\n\t\t\t\t}\n\t\t\t\tif (params.roundLengths) slideSize = Math.floor(slideSize);\n\t\t\t} else {\n\t\t\t\tslideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;\n\t\t\t\tif (params.roundLengths) slideSize = Math.floor(slideSize);\n\t\t\t\tif (slides[i]) {\n\t\t\t\t\tslides[i].style[getDirectionLabel('width')] = `${slideSize}px`;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (slides[i]) {\n\t\t\t\tslides[i].swiperSlideSize = slideSize;\n\t\t\t}\n\t\t\tslidesSizesGrid.push(slideSize);\n\t\t\tif (params.centeredSlides) {\n\t\t\t\tslidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;\n\t\t\t\tif (prevSlideSize === 0 && i !== 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;\n\t\t\t\tif (i === 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;\n\t\t\t\tif (Math.abs(slidePosition) < 1 / 1000) slidePosition = 0;\n\t\t\t\tif (params.roundLengths) slidePosition = Math.floor(slidePosition);\n\t\t\t\tif (index % params.slidesPerGroup === 0) snapGrid.push(slidePosition);\n\t\t\t\tslidesGrid.push(slidePosition);\n\t\t\t} else {\n\t\t\t\tif (params.roundLengths) slidePosition = Math.floor(slidePosition);\n\t\t\t\tif ((index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup === 0) snapGrid.push(slidePosition);\n\t\t\t\tslidesGrid.push(slidePosition);\n\t\t\t\tslidePosition = slidePosition + slideSize + spaceBetween;\n\t\t\t}\n\t\t\tswiper.virtualSize += slideSize + spaceBetween;\n\t\t\tprevSlideSize = slideSize;\n\t\t\tindex += 1;\n\t\t}\n\t\tswiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;\n\t\tif (rtl && wrongRTL && (params.effect === 'slide' || params.effect === 'coverflow')) {\n\t\t\twrapperEl.style.width = `${swiper.virtualSize + spaceBetween}px`;\n\t\t}\n\t\tif (params.setWrapperSize) {\n\t\t\twrapperEl.style[getDirectionLabel('width')] = `${swiper.virtualSize + spaceBetween}px`;\n\t\t}\n\t\tif (gridEnabled) {\n\t\t\tswiper.grid.updateWrapperSize(slideSize, snapGrid, getDirectionLabel);\n\t\t}\n\n\t\t// Remove last grid elements depending on width\n\t\tif (!params.centeredSlides) {\n\t\t\tconst newSlidesGrid = [];\n\t\t\tfor (let i = 0; i < snapGrid.length; i += 1) {\n\t\t\t\tlet slidesGridItem = snapGrid[i];\n\t\t\t\tif (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);\n\t\t\t\tif (snapGrid[i] <= swiper.virtualSize - swiperSize) {\n\t\t\t\t\tnewSlidesGrid.push(slidesGridItem);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsnapGrid = newSlidesGrid;\n\t\t\tif (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {\n\t\t\t\tsnapGrid.push(swiper.virtualSize - swiperSize);\n\t\t\t}\n\t\t}\n\t\tif (isVirtual && params.loop) {\n\t\t\tconst size = slidesSizesGrid[0] + spaceBetween;\n\t\t\tif (params.slidesPerGroup > 1) {\n\t\t\t\tconst groups = Math.ceil((swiper.virtual.slidesBefore + swiper.virtual.slidesAfter) / params.slidesPerGroup);\n\t\t\t\tconst groupSize = size * params.slidesPerGroup;\n\t\t\t\tfor (let i = 0; i < groups; i += 1) {\n\t\t\t\t\tsnapGrid.push(snapGrid[snapGrid.length - 1] + groupSize);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (let i = 0; i < swiper.virtual.slidesBefore + swiper.virtual.slidesAfter; i += 1) {\n\t\t\t\tif (params.slidesPerGroup === 1) {\n\t\t\t\t\tsnapGrid.push(snapGrid[snapGrid.length - 1] + size);\n\t\t\t\t}\n\t\t\t\tslidesGrid.push(slidesGrid[slidesGrid.length - 1] + size);\n\t\t\t\tswiper.virtualSize += size;\n\t\t\t}\n\t\t}\n\t\tif (snapGrid.length === 0) snapGrid = [0];\n\t\tif (spaceBetween !== 0) {\n\t\t\tconst key = swiper.isHorizontal() && rtl ? 'marginLeft' : getDirectionLabel('marginRight');\n\t\t\tslides.filter((_, slideIndex) => {\n\t\t\t\tif (!params.cssMode || params.loop) return true;\n\t\t\t\tif (slideIndex === slides.length - 1) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}).forEach(slideEl => {\n\t\t\t\tslideEl.style[key] = `${spaceBetween}px`;\n\t\t\t});\n\t\t}\n\t\tif (params.centeredSlides && params.centeredSlidesBounds) {\n\t\t\tlet allSlidesSize = 0;\n\t\t\tslidesSizesGrid.forEach(slideSizeValue => {\n\t\t\t\tallSlidesSize += slideSizeValue + (spaceBetween || 0);\n\t\t\t});\n\t\t\tallSlidesSize -= spaceBetween;\n\t\t\tconst maxSnap = allSlidesSize - swiperSize;\n\t\t\tsnapGrid = snapGrid.map(snap => {\n\t\t\t\tif (snap <= 0) return -offsetBefore;\n\t\t\t\tif (snap > maxSnap) return maxSnap + offsetAfter;\n\t\t\t\treturn snap;\n\t\t\t});\n\t\t}\n\t\tif (params.centerInsufficientSlides) {\n\t\t\tlet allSlidesSize = 0;\n\t\t\tslidesSizesGrid.forEach(slideSizeValue => {\n\t\t\t\tallSlidesSize += slideSizeValue + (spaceBetween || 0);\n\t\t\t});\n\t\t\tallSlidesSize -= spaceBetween;\n\t\t\tif (allSlidesSize < swiperSize) {\n\t\t\t\tconst allSlidesOffset = (swiperSize - allSlidesSize) / 2;\n\t\t\t\tsnapGrid.forEach((snap, snapIndex) => {\n\t\t\t\t\tsnapGrid[snapIndex] = snap - allSlidesOffset;\n\t\t\t\t});\n\t\t\t\tslidesGrid.forEach((snap, snapIndex) => {\n\t\t\t\t\tslidesGrid[snapIndex] = snap + allSlidesOffset;\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\tObject.assign(swiper, {\n\t\t\tslides,\n\t\t\tsnapGrid,\n\t\t\tslidesGrid,\n\t\t\tslidesSizesGrid\n\t\t});\n\t\tif (params.centeredSlides && params.cssMode && !params.centeredSlidesBounds) {\n\t\t\tsetCSSProperty(wrapperEl, '--swiper-centered-offset-before', `${-snapGrid[0]}px`);\n\t\t\tsetCSSProperty(wrapperEl, '--swiper-centered-offset-after', `${swiper.size / 2 - slidesSizesGrid[slidesSizesGrid.length - 1] / 2}px`);\n\t\t\tconst addToSnapGrid = -swiper.snapGrid[0];\n\t\t\tconst addToSlidesGrid = -swiper.slidesGrid[0];\n\t\t\tswiper.snapGrid = swiper.snapGrid.map(v => v + addToSnapGrid);\n\t\t\tswiper.slidesGrid = swiper.slidesGrid.map(v => v + addToSlidesGrid);\n\t\t}\n\t\tif (slidesLength !== previousSlidesLength) {\n\t\t\tswiper.emit('slidesLengthChange');\n\t\t}\n\t\tif (snapGrid.length !== previousSnapGridLength) {\n\t\t\tif (swiper.params.watchOverflow) swiper.checkOverflow();\n\t\t\tswiper.emit('snapGridLengthChange');\n\t\t}\n\t\tif (slidesGrid.length !== previousSlidesGridLength) {\n\t\t\tswiper.emit('slidesGridLengthChange');\n\t\t}\n\t\tif (params.watchSlidesProgress) {\n\t\t\tswiper.updateSlidesOffset();\n\t\t}\n\t\tif (!isVirtual && !params.cssMode && (params.effect === 'slide' || params.effect === 'fade')) {\n\t\t\tconst backFaceHiddenClass = `${params.containerModifierClass}backface-hidden`;\n\t\t\tconst hasClassBackfaceClassAdded = swiper.el.classList.contains(backFaceHiddenClass);\n\t\t\tif (slidesLength <= params.maxBackfaceHiddenSlides) {\n\t\t\t\tif (!hasClassBackfaceClassAdded) swiper.el.classList.add(backFaceHiddenClass);\n\t\t\t} else if (hasClassBackfaceClassAdded) {\n\t\t\t\tswiper.el.classList.remove(backFaceHiddenClass);\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction updateAutoHeight(speed) {\n\t\tconst swiper = this;\n\t\tconst activeSlides = [];\n\t\tconst isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n\t\tlet newHeight = 0;\n\t\tlet i;\n\t\tif (typeof speed === 'number') {\n\t\t\tswiper.setTransition(speed);\n\t\t} else if (speed === true) {\n\t\t\tswiper.setTransition(swiper.params.speed);\n\t\t}\n\t\tconst getSlideByIndex = index => {\n\t\t\tif (isVirtual) {\n\t\t\t\treturn swiper.slides[swiper.getSlideIndexByData(index)];\n\t\t\t}\n\t\t\treturn swiper.slides[index];\n\t\t};\n\t\t// Find slides currently in view\n\t\tif (swiper.params.slidesPerView !== 'auto' && swiper.params.slidesPerView > 1) {\n\t\t\tif (swiper.params.centeredSlides) {\n\t\t\t\t(swiper.visibleSlides || []).forEach(slide => {\n\t\t\t\t\tactiveSlides.push(slide);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tfor (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {\n\t\t\t\t\tconst index = swiper.activeIndex + i;\n\t\t\t\t\tif (index > swiper.slides.length && !isVirtual) break;\n\t\t\t\t\tactiveSlides.push(getSlideByIndex(index));\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tactiveSlides.push(getSlideByIndex(swiper.activeIndex));\n\t\t}\n\n\t\t// Find new height from highest slide in view\n\t\tfor (i = 0; i < activeSlides.length; i += 1) {\n\t\t\tif (typeof activeSlides[i] !== 'undefined') {\n\t\t\t\tconst height = activeSlides[i].offsetHeight;\n\t\t\t\tnewHeight = height > newHeight ? height : newHeight;\n\t\t\t}\n\t\t}\n\n\t\t// Update Height\n\t\tif (newHeight || newHeight === 0) swiper.wrapperEl.style.height = `${newHeight}px`;\n\t}\n\n\tfunction updateSlidesOffset() {\n\t\tconst swiper = this;\n\t\tconst slides = swiper.slides;\n\t\t// eslint-disable-next-line\n\t\tconst minusOffset = swiper.isElement ? swiper.isHorizontal() ? swiper.wrapperEl.offsetLeft : swiper.wrapperEl.offsetTop : 0;\n\t\tfor (let i = 0; i < slides.length; i += 1) {\n\t\t\tslides[i].swiperSlideOffset = (swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop) - minusOffset - swiper.cssOverflowAdjustment();\n\t\t}\n\t}\n\n\tfunction updateSlidesProgress(translate) {\n\t\tif (translate === void 0) {\n\t\t\ttranslate = this && this.translate || 0;\n\t\t}\n\t\tconst swiper = this;\n\t\tconst params = swiper.params;\n\t\tconst {\n\t\t\tslides,\n\t\t\trtlTranslate: rtl,\n\t\t\tsnapGrid\n\t\t} = swiper;\n\t\tif (slides.length === 0) return;\n\t\tif (typeof slides[0].swiperSlideOffset === 'undefined') swiper.updateSlidesOffset();\n\t\tlet offsetCenter = -translate;\n\t\tif (rtl) offsetCenter = translate;\n\n\t\t// Visible Slides\n\t\tslides.forEach(slideEl => {\n\t\t\tslideEl.classList.remove(params.slideVisibleClass);\n\t\t});\n\t\tswiper.visibleSlidesIndexes = [];\n\t\tswiper.visibleSlides = [];\n\t\tlet spaceBetween = params.spaceBetween;\n\t\tif (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {\n\t\t\tspaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiper.size;\n\t\t} else if (typeof spaceBetween === 'string') {\n\t\t\tspaceBetween = parseFloat(spaceBetween);\n\t\t}\n\t\tfor (let i = 0; i < slides.length; i += 1) {\n\t\t\tconst slide = slides[i];\n\t\t\tlet slideOffset = slide.swiperSlideOffset;\n\t\t\tif (params.cssMode && params.centeredSlides) {\n\t\t\t\tslideOffset -= slides[0].swiperSlideOffset;\n\t\t\t}\n\t\t\tconst slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + spaceBetween);\n\t\t\tconst originalSlideProgress = (offsetCenter - snapGrid[0] + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + spaceBetween);\n\t\t\tconst slideBefore = -(offsetCenter - slideOffset);\n\t\t\tconst slideAfter = slideBefore + swiper.slidesSizesGrid[i];\n\t\t\tconst isVisible = slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;\n\t\t\tif (isVisible) {\n\t\t\t\tswiper.visibleSlides.push(slide);\n\t\t\t\tswiper.visibleSlidesIndexes.push(i);\n\t\t\t\tslides[i].classList.add(params.slideVisibleClass);\n\t\t\t}\n\t\t\tslide.progress = rtl ? -slideProgress : slideProgress;\n\t\t\tslide.originalProgress = rtl ? -originalSlideProgress : originalSlideProgress;\n\t\t}\n\t}\n\n\tfunction updateProgress(translate) {\n\t\tconst swiper = this;\n\t\tif (typeof translate === 'undefined') {\n\t\t\tconst multiplier = swiper.rtlTranslate ? -1 : 1;\n\t\t\t// eslint-disable-next-line\n\t\t\ttranslate = swiper && swiper.translate && swiper.translate * multiplier || 0;\n\t\t}\n\t\tconst params = swiper.params;\n\t\tconst translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n\t\tlet {\n\t\t\tprogress,\n\t\t\tisBeginning,\n\t\t\tisEnd,\n\t\t\tprogressLoop\n\t\t} = swiper;\n\t\tconst wasBeginning = isBeginning;\n\t\tconst wasEnd = isEnd;\n\t\tif (translatesDiff === 0) {\n\t\t\tprogress = 0;\n\t\t\tisBeginning = true;\n\t\t\tisEnd = true;\n\t\t} else {\n\t\t\tprogress = (translate - swiper.minTranslate()) / translatesDiff;\n\t\t\tconst isBeginningRounded = Math.abs(translate - swiper.minTranslate()) < 1;\n\t\t\tconst isEndRounded = Math.abs(translate - swiper.maxTranslate()) < 1;\n\t\t\tisBeginning = isBeginningRounded || progress <= 0;\n\t\t\tisEnd = isEndRounded || progress >= 1;\n\t\t\tif (isBeginningRounded) progress = 0;\n\t\t\tif (isEndRounded) progress = 1;\n\t\t}\n\t\tif (params.loop) {\n\t\t\tconst firstSlideIndex = swiper.getSlideIndexByData(0);\n\t\t\tconst lastSlideIndex = swiper.getSlideIndexByData(swiper.slides.length - 1);\n\t\t\tconst firstSlideTranslate = swiper.slidesGrid[firstSlideIndex];\n\t\t\tconst lastSlideTranslate = swiper.slidesGrid[lastSlideIndex];\n\t\t\tconst translateMax = swiper.slidesGrid[swiper.slidesGrid.length - 1];\n\t\t\tconst translateAbs = Math.abs(translate);\n\t\t\tif (translateAbs >= firstSlideTranslate) {\n\t\t\t\tprogressLoop = (translateAbs - firstSlideTranslate) / translateMax;\n\t\t\t} else {\n\t\t\t\tprogressLoop = (translateAbs + translateMax - lastSlideTranslate) / translateMax;\n\t\t\t}\n\t\t\tif (progressLoop > 1) progressLoop -= 1;\n\t\t}\n\t\tObject.assign(swiper, {\n\t\t\tprogress,\n\t\t\tprogressLoop,\n\t\t\tisBeginning,\n\t\t\tisEnd\n\t\t});\n\t\tif (params.watchSlidesProgress || params.centeredSlides && params.autoHeight) swiper.updateSlidesProgress(translate);\n\t\tif (isBeginning && !wasBeginning) {\n\t\t\tswiper.emit('reachBeginning toEdge');\n\t\t}\n\t\tif (isEnd && !wasEnd) {\n\t\t\tswiper.emit('reachEnd toEdge');\n\t\t}\n\t\tif (wasBeginning && !isBeginning || wasEnd && !isEnd) {\n\t\t\tswiper.emit('fromEdge');\n\t\t}\n\t\tswiper.emit('progress', progress);\n\t}\n\n\tfunction updateSlidesClasses() {\n\t\tconst swiper = this;\n\t\tconst {\n\t\t\tslides,\n\t\t\tparams,\n\t\t\tslidesEl,\n\t\t\tactiveIndex\n\t\t} = swiper;\n\t\tconst isVirtual = swiper.virtual && params.virtual.enabled;\n\t\tconst getFilteredSlide = selector => {\n\t\t\treturn elementChildren(slidesEl, `.${params.slideClass}${selector}, swiper-slide${selector}`)[0];\n\t\t};\n\t\tslides.forEach(slideEl => {\n\t\t\tslideEl.classList.remove(params.slideActiveClass, params.slideNextClass, params.slidePrevClass);\n\t\t});\n\t\tlet activeSlide;\n\t\tif (isVirtual) {\n\t\t\tif (params.loop) {\n\t\t\t\tlet slideIndex = activeIndex - swiper.virtual.slidesBefore;\n\t\t\t\tif (slideIndex < 0) slideIndex = swiper.virtual.slides.length + slideIndex;\n\t\t\t\tif (slideIndex >= swiper.virtual.slides.length) slideIndex -= swiper.virtual.slides.length;\n\t\t\t\tactiveSlide = getFilteredSlide(`[data-swiper-slide-index=\"${slideIndex}\"]`);\n\t\t\t} else {\n\t\t\t\tactiveSlide = getFilteredSlide(`[data-swiper-slide-index=\"${activeIndex}\"]`);\n\t\t\t}\n\t\t} else {\n\t\t\tactiveSlide = slides[activeIndex];\n\t\t}\n\t\tif (activeSlide) {\n\t\t\t// Active classes\n\t\t\tactiveSlide.classList.add(params.slideActiveClass);\n\n\t\t\t// Next Slide\n\t\t\tlet nextSlide = elementNextAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];\n\t\t\tif (params.loop && !nextSlide) {\n\t\t\t\tnextSlide = slides[0];\n\t\t\t}\n\t\t\tif (nextSlide) {\n\t\t\t\tnextSlide.classList.add(params.slideNextClass);\n\t\t\t}\n\t\t\t// Prev Slide\n\t\t\tlet prevSlide = elementPrevAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];\n\t\t\tif (params.loop && !prevSlide === 0) {\n\t\t\t\tprevSlide = slides[slides.length - 1];\n\t\t\t}\n\t\t\tif (prevSlide) {\n\t\t\t\tprevSlide.classList.add(params.slidePrevClass);\n\t\t\t}\n\t\t}\n\t\tswiper.emitSlidesClasses();\n\t}\n\n\tconst processLazyPreloader = (swiper, imageEl) => {\n\t\tif (!swiper || swiper.destroyed || !swiper.params) return;\n\t\tconst slideSelector = () => swiper.isElement ? `swiper-slide` : `.${swiper.params.slideClass}`;\n\t\tconst slideEl = imageEl.closest(slideSelector());\n\t\tif (slideEl) {\n\t\t\tlet lazyEl = slideEl.querySelector(`.${swiper.params.lazyPreloaderClass}`);\n\t\t\tif (!lazyEl && swiper.isElement) {\n\t\t\t\tlazyEl = slideEl.shadowRoot.querySelector(`.${swiper.params.lazyPreloaderClass}`);\n\t\t\t}\n\t\t\tif (lazyEl) lazyEl.remove();\n\t\t}\n\t};\n\tconst unlazy = (swiper, index) => {\n\t\tif (!swiper.slides[index]) return;\n\t\tconst imageEl = swiper.slides[index].querySelector('[loading=\"lazy\"]');\n\t\tif (imageEl) imageEl.removeAttribute('loading');\n\t};\n\tconst preload = swiper => {\n\t\tif (!swiper || swiper.destroyed || !swiper.params) return;\n\t\tlet amount = swiper.params.lazyPreloadPrevNext;\n\t\tconst len = swiper.slides.length;\n\t\tif (!len || !amount || amount < 0) return;\n\t\tamount = Math.min(amount, len);\n\t\tconst slidesPerView = swiper.params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : Math.ceil(swiper.params.slidesPerView);\n\t\tconst activeIndex = swiper.activeIndex;\n\t\tif (swiper.params.grid && swiper.params.grid.rows > 1) {\n\t\t\tconst activeColumn = activeIndex;\n\t\t\tconst preloadColumns = [activeColumn - amount];\n\t\t\tpreloadColumns.push(...Array.from({\n\t\t\t\tlength: amount\n\t\t\t}).map((_, i) => {\n\t\t\t\treturn activeColumn + slidesPerView + i;\n\t\t\t}));\n\t\t\tswiper.slides.forEach((slideEl, i) => {\n\t\t\t\tif (preloadColumns.includes(slideEl.column)) unlazy(swiper, i);\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\t\tconst slideIndexLastInView = activeIndex + slidesPerView - 1;\n\t\tif (swiper.params.rewind || swiper.params.loop) {\n\t\t\tfor (let i = activeIndex - amount; i <= slideIndexLastInView + amount; i += 1) {\n\t\t\t\tconst realIndex = (i % len + len) % len;\n\t\t\t\tif (realIndex < activeIndex || realIndex > slideIndexLastInView) unlazy(swiper, realIndex);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (let i = Math.max(activeIndex - amount, 0); i <= Math.min(slideIndexLastInView + amount, len - 1); i += 1) {\n\t\t\t\tif (i !== activeIndex && (i > slideIndexLastInView || i < activeIndex)) {\n\t\t\t\t\tunlazy(swiper, i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\tfunction getActiveIndexByTranslate(swiper) {\n\t\tconst {\n\t\t\tslidesGrid,\n\t\t\tparams\n\t\t} = swiper;\n\t\tconst translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;\n\t\tlet activeIndex;\n\t\tfor (let i = 0; i < slidesGrid.length; i += 1) {\n\t\t\tif (typeof slidesGrid[i + 1] !== 'undefined') {\n\t\t\t\tif (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2) {\n\t\t\t\t\tactiveIndex = i;\n\t\t\t\t} else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) {\n\t\t\t\t\tactiveIndex = i + 1;\n\t\t\t\t}\n\t\t\t} else if (translate >= slidesGrid[i]) {\n\t\t\t\tactiveIndex = i;\n\t\t\t}\n\t\t}\n\t\t// Normalize slideIndex\n\t\tif (params.normalizeSlideIndex) {\n\t\t\tif (activeIndex < 0 || typeof activeIndex === 'undefined') activeIndex = 0;\n\t\t}\n\t\treturn activeIndex;\n\t}\n\tfunction updateActiveIndex(newActiveIndex) {\n\t\tconst swiper = this;\n\t\tconst translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;\n\t\tconst {\n\t\t\tsnapGrid,\n\t\t\tparams,\n\t\t\tactiveIndex: previousIndex,\n\t\t\trealIndex: previousRealIndex,\n\t\t\tsnapIndex: previousSnapIndex\n\t\t} = swiper;\n\t\tlet activeIndex = newActiveIndex;\n\t\tlet snapIndex;\n\t\tconst getVirtualRealIndex = aIndex => {\n\t\t\tlet realIndex = aIndex - swiper.virtual.slidesBefore;\n\t\t\tif (realIndex < 0) {\n\t\t\t\trealIndex = swiper.virtual.slides.length + realIndex;\n\t\t\t}\n\t\t\tif (realIndex >= swiper.virtual.slides.length) {\n\t\t\t\trealIndex -= swiper.virtual.slides.length;\n\t\t\t}\n\t\t\treturn realIndex;\n\t\t};\n\t\tif (typeof activeIndex === 'undefined') {\n\t\t\tactiveIndex = getActiveIndexByTranslate(swiper);\n\t\t}\n\t\tif (snapGrid.indexOf(translate) >= 0) {\n\t\t\tsnapIndex = snapGrid.indexOf(translate);\n\t\t} else {\n\t\t\tconst skip = Math.min(params.slidesPerGroupSkip, activeIndex);\n\t\t\tsnapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);\n\t\t}\n\t\tif (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;\n\t\tif (activeIndex === previousIndex) {\n\t\t\tif (snapIndex !== previousSnapIndex) {\n\t\t\t\tswiper.snapIndex = snapIndex;\n\t\t\t\tswiper.emit('snapIndexChange');\n\t\t\t}\n\t\t\tif (swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) {\n\t\t\t\tswiper.realIndex = getVirtualRealIndex(activeIndex);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t// Get real index\n\t\tlet realIndex;\n\t\tif (swiper.virtual && params.virtual.enabled && params.loop) {\n\t\t\trealIndex = getVirtualRealIndex(activeIndex);\n\t\t} else if (swiper.slides[activeIndex]) {\n\t\t\trealIndex = parseInt(swiper.slides[activeIndex].getAttribute('data-swiper-slide-index') || activeIndex, 10);\n\t\t} else {\n\t\t\trealIndex = activeIndex;\n\t\t}\n\t\tObject.assign(swiper, {\n\t\t\tpreviousSnapIndex,\n\t\t\tsnapIndex,\n\t\t\tpreviousRealIndex,\n\t\t\trealIndex,\n\t\t\tpreviousIndex,\n\t\t\tactiveIndex\n\t\t});\n\t\tif (swiper.initialized) {\n\t\t\tpreload(swiper);\n\t\t}\n\t\tswiper.emit('activeIndexChange');\n\t\tswiper.emit('snapIndexChange');\n\t\tif (previousRealIndex !== realIndex) {\n\t\t\tswiper.emit('realIndexChange');\n\t\t}\n\t\tif (swiper.initialized || swiper.params.runCallbacksOnInit) {\n\t\t\tswiper.emit('slideChange');\n\t\t}\n\t}\n\n\tfunction updateClickedSlide(e) {\n\t\tconst swiper = this;\n\t\tconst params = swiper.params;\n\t\tconst slide = e.closest(`.${params.slideClass}, swiper-slide`);\n\t\tlet slideFound = false;\n\t\tlet slideIndex;\n\t\tif (slide) {\n\t\t\tfor (let i = 0; i < swiper.slides.length; i += 1) {\n\t\t\t\tif (swiper.slides[i] === slide) {\n\t\t\t\t\tslideFound = true;\n\t\t\t\t\tslideIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (slide && slideFound) {\n\t\t\tswiper.clickedSlide = slide;\n\t\t\tif (swiper.virtual && swiper.params.virtual.enabled) {\n\t\t\t\tswiper.clickedIndex = parseInt(slide.getAttribute('data-swiper-slide-index'), 10);\n\t\t\t} else {\n\t\t\t\tswiper.clickedIndex = slideIndex;\n\t\t\t}\n\t\t} else {\n\t\t\tswiper.clickedSlide = undefined;\n\t\t\tswiper.clickedIndex = undefined;\n\t\t\treturn;\n\t\t}\n\t\tif (params.slideToClickedSlide && swiper.clickedIndex !== undefined && swiper.clickedIndex !== swiper.activeIndex) {\n\t\t\tswiper.slideToClickedSlide();\n\t\t}\n\t}\n\n\tvar update = {\n\t\tupdateSize,\n\t\tupdateSlides,\n\t\tupdateAutoHeight,\n\t\tupdateSlidesOffset,\n\t\tupdateSlidesProgress,\n\t\tupdateProgress,\n\t\tupdateSlidesClasses,\n\t\tupdateActiveIndex,\n\t\tupdateClickedSlide\n\t};\n\n\tfunction getSwiperTranslate(axis) {\n\t\tif (axis === void 0) {\n\t\t\taxis = this.isHorizontal() ? 'x' : 'y';\n\t\t}\n\t\tconst swiper = this;\n\t\tconst {\n\t\t\tparams,\n\t\t\trtlTranslate: rtl,\n\t\t\ttranslate,\n\t\t\twrapperEl\n\t\t} = swiper;\n\t\tif (params.virtualTranslate) {\n\t\t\treturn rtl ? -translate : translate;\n\t\t}\n\t\tif (params.cssMode) {\n\t\t\treturn translate;\n\t\t}\n\t\tlet currentTranslate = getTranslate(wrapperEl, axis);\n\t\tcurrentTranslate += swiper.cssOverflowAdjustment();\n\t\tif (rtl) currentTranslate = -currentTranslate;\n\t\treturn currentTranslate || 0;\n\t}\n\n\tfunction setTranslate(translate, byController) {\n\t\tconst swiper = this;\n\t\tconst {\n\t\t\trtlTranslate: rtl,\n\t\t\tparams,\n\t\t\twrapperEl,\n\t\t\tprogress\n\t\t} = swiper;\n\t\tlet x = 0;\n\t\tlet y = 0;\n\t\tconst z = 0;\n\t\tif (swiper.isHorizontal()) {\n\t\t\tx = rtl ? -translate : translate;\n\t\t} else {\n\t\t\ty = translate;\n\t\t}\n\t\tif (params.roundLengths) {\n\t\t\tx = Math.floor(x);\n\t\t\ty = Math.floor(y);\n\t\t}\n\t\tswiper.previousTranslate = swiper.translate;\n\t\tswiper.translate = swiper.isHorizontal() ? x : y;\n\t\tif (params.cssMode) {\n\t\t\twrapperEl[swiper.isHorizontal() ? 'scrollLeft' : 'scrollTop'] = swiper.isHorizontal() ? -x : -y;\n\t\t} else if (!params.virtualTranslate) {\n\t\t\tif (swiper.isHorizontal()) {\n\t\t\t\tx -= swiper.cssOverflowAdjustment();\n\t\t\t} else {\n\t\t\t\ty -= swiper.cssOverflowAdjustment();\n\t\t\t}\n\t\t\twrapperEl.style.transform = `translate3d(${x}px, ${y}px, ${z}px)`;\n\t\t}\n\n\t\t// Check if we need to update progress\n\t\tlet newProgress;\n\t\tconst translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n\t\tif (translatesDiff === 0) {\n\t\t\tnewProgress = 0;\n\t\t} else {\n\t\t\tnewProgress = (translate - swiper.minTranslate()) / translatesDiff;\n\t\t}\n\t\tif (newProgress !== progress) {\n\t\t\tswiper.updateProgress(translate);\n\t\t}\n\t\tswiper.emit('setTranslate', swiper.translate, byController);\n\t}\n\n\tfunction minTranslate() {\n\t\treturn -this.snapGrid[0];\n\t}\n\n\tfunction maxTranslate() {\n\t\treturn -this.snapGrid[this.snapGrid.length - 1];\n\t}\n\n\tfunction translateTo(translate, speed, runCallbacks, translateBounds, internal) {\n\t\tif (translate === void 0) {\n\t\t\ttranslate = 0;\n\t\t}\n\t\tif (speed === void 0) {\n\t\t\tspeed = this.params.speed;\n\t\t}\n\t\tif (runCallbacks === void 0) {\n\t\t\trunCallbacks = true;\n\t\t}\n\t\tif (translateBounds === void 0) {\n\t\t\ttranslateBounds = true;\n\t\t}\n\t\tconst swiper = this;\n\t\tconst {\n\t\t\tparams,\n\t\t\twrapperEl\n\t\t} = swiper;\n\t\tif (swiper.animating && params.preventInteractionOnTransition) {\n\t\t\treturn false;\n\t\t}\n\t\tconst minTranslate = swiper.minTranslate();\n\t\tconst maxTranslate = swiper.maxTranslate();\n\t\tlet newTranslate;\n\t\tif (translateBounds && translate > minTranslate) newTranslate = minTranslate; else if (translateBounds && translate < maxTranslate) newTranslate = maxTranslate; else newTranslate = translate;\n\n\t\t// Update progress\n\t\tswiper.updateProgress(newTranslate);\n\t\tif (params.cssMode) {\n\t\t\tconst isH = swiper.isHorizontal();\n\t\t\tif (speed === 0) {\n\t\t\t\twrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -newTranslate;\n\t\t\t} else {\n\t\t\t\tif (!swiper.support.smoothScroll) {\n\t\t\t\t\tanimateCSSModeScroll({\n\t\t\t\t\t\tswiper,\n\t\t\t\t\t\ttargetPosition: -newTranslate,\n\t\t\t\t\t\tside: isH ? 'left' : 'top'\n\t\t\t\t\t});\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\twrapperEl.scrollTo({\n\t\t\t\t\t[isH ? 'left' : 'top']: -newTranslate,\n\t\t\t\t\tbehavior: 'smooth'\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\tif (speed === 0) {\n\t\t\tswiper.setTransition(0);\n\t\t\tswiper.setTranslate(newTranslate);\n\t\t\tif (runCallbacks) {\n\t\t\t\tswiper.emit('beforeTransitionStart', speed, internal);\n\t\t\t\tswiper.emit('transitionEnd');\n\t\t\t}\n\t\t} else {\n\t\t\tswiper.setTransition(speed);\n\t\t\tswiper.setTranslate(newTranslate);\n\t\t\tif (runCallbacks) {\n\t\t\t\tswiper.emit('beforeTransitionStart', speed, internal);\n\t\t\t\tswiper.emit('transitionStart');\n\t\t\t}\n\t\t\tif (!swiper.animating) {\n\t\t\t\tswiper.animating = true;\n\t\t\t\tif (!swiper.onTranslateToWrapperTransitionEnd) {\n\t\t\t\t\tswiper.onTranslateToWrapperTransitionEnd = function transitionEnd(e) {\n\t\t\t\t\t\tif (!swiper || swiper.destroyed) return;\n\t\t\t\t\t\tif (e.target !== this) return;\n\t\t\t\t\t\tswiper.wrapperEl.removeEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);\n\t\t\t\t\t\tswiper.onTranslateToWrapperTransitionEnd = null;\n\t\t\t\t\t\tdelete swiper.onTranslateToWrapperTransitionEnd;\n\t\t\t\t\t\tif (runCallbacks) {\n\t\t\t\t\t\t\tswiper.emit('transitionEnd');\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tswiper.wrapperEl.addEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tvar translate = {\n\t\tgetTranslate: getSwiperTranslate,\n\t\tsetTranslate,\n\t\tminTranslate,\n\t\tmaxTranslate,\n\t\ttranslateTo\n\t};\n\n\tfunction setTransition(duration, byController) {\n\t\tconst swiper = this;\n\t\tif (!swiper.params.cssMode) {\n\t\t\tswiper.wrapperEl.style.transitionDuration = `${duration}ms`;\n\t\t\tswiper.wrapperEl.style.transitionDelay = duration === 0 ? `0ms` : '';\n\t\t}\n\t\tswiper.emit('setTransition', duration, byController);\n\t}\n\n\tfunction transitionEmit(_ref) {\n\t\tlet {\n\t\t\tswiper,\n\t\t\trunCallbacks,\n\t\t\tdirection,\n\t\t\tstep\n\t\t} = _ref;\n\t\tconst {\n\t\t\tactiveIndex,\n\t\t\tpreviousIndex\n\t\t} = swiper;\n\t\tlet dir = direction;\n\t\tif (!dir) {\n\t\t\tif (activeIndex > previousIndex) dir = 'next'; else if (activeIndex < previousIndex) dir = 'prev'; else dir = 'reset';\n\t\t}\n\t\tswiper.emit(`transition${step}`);\n\t\tif (runCallbacks && activeIndex !== previousIndex) {\n\t\t\tif (dir === 'reset') {\n\t\t\t\tswiper.emit(`slideResetTransition${step}`);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tswiper.emit(`slideChangeTransition${step}`);\n\t\t\tif (dir === 'next') {\n\t\t\t\tswiper.emit(`slideNextTransition${step}`);\n\t\t\t} else {\n\t\t\t\tswiper.emit(`slidePrevTransition${step}`);\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction transitionStart(runCallbacks, direction) {\n\t\tif (runCallbacks === void 0) {\n\t\t\trunCallbacks = true;\n\t\t}\n\t\tconst swiper = this;\n\t\tconst {\n\t\t\tparams\n\t\t} = swiper;\n\t\tif (params.cssMode) return;\n\t\tif (params.autoHeight) {\n\t\t\tswiper.updateAutoHeight();\n\t\t}\n\t\ttransitionEmit({\n\t\t\tswiper,\n\t\t\trunCallbacks,\n\t\t\tdirection,\n\t\t\tstep: 'Start'\n\t\t});\n\t}\n\n\tfunction transitionEnd(runCallbacks, direction) {\n\t\tif (runCallbacks === void 0) {\n\t\t\trunCallbacks = true;\n\t\t}\n\t\tconst swiper = this;\n\t\tconst {\n\t\t\tparams\n\t\t} = swiper;\n\t\tswiper.animating = false;\n\t\tif (params.cssMode) return;\n\t\tswiper.setTransition(0);\n\t\ttransitionEmit({\n\t\t\tswiper,\n\t\t\trunCallbacks,\n\t\t\tdirection,\n\t\t\tstep: 'End'\n\t\t});\n\t}\n\n\tvar transition = {\n\t\tsetTransition,\n\t\ttransitionStart,\n\t\ttransitionEnd\n\t};\n\n\tfunction slideTo(index, speed, runCallbacks, internal, initial) {\n\t\tif (index === void 0) {\n\t\t\tindex = 0;\n\t\t}\n\t\tif (speed === void 0) {\n\t\t\tspeed = this.params.speed;\n\t\t}\n\t\tif (runCallbacks === void 0) {\n\t\t\trunCallbacks = true;\n\t\t}\n\t\tif (typeof index === 'string') {\n\t\t\tindex = parseInt(index, 10);\n\t\t}\n\t\tconst swiper = this;\n\t\tlet slideIndex = index;\n\t\tif (slideIndex < 0) slideIndex = 0;\n\t\tconst {\n\t\t\tparams,\n\t\t\tsnapGrid,\n\t\t\tslidesGrid,\n\t\t\tpreviousIndex,\n\t\t\tactiveIndex,\n\t\t\trtlTranslate: rtl,\n\t\t\twrapperEl,\n\t\t\tenabled\n\t\t} = swiper;\n\t\tif (swiper.animating && params.preventInteractionOnTransition || !enabled && !internal && !initial) {\n\t\t\treturn false;\n\t\t}\n\t\tconst skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);\n\t\tlet snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);\n\t\tif (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;\n\t\tconst translate = -snapGrid[snapIndex];\n\t\t// Normalize slideIndex\n\t\tif (params.normalizeSlideIndex) {\n\t\t\tfor (let i = 0; i < slidesGrid.length; i += 1) {\n\t\t\t\tconst normalizedTranslate = -Math.floor(translate * 100);\n\t\t\t\tconst normalizedGrid = Math.floor(slidesGrid[i] * 100);\n\t\t\t\tconst normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);\n\t\t\t\tif (typeof slidesGrid[i + 1] !== 'undefined') {\n\t\t\t\t\tif (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2) {\n\t\t\t\t\t\tslideIndex = i;\n\t\t\t\t\t} else if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext) {\n\t\t\t\t\t\tslideIndex = i + 1;\n\t\t\t\t\t}\n\t\t\t\t} else if (normalizedTranslate >= normalizedGrid) {\n\t\t\t\t\tslideIndex = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Directions locks\n\t\tif (swiper.initialized && slideIndex !== activeIndex) {\n\t\t\tif (!swiper.allowSlideNext && (rtl ? translate > swiper.translate && translate > swiper.minTranslate() : translate < swiper.translate && translate < swiper.minTranslate())) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {\n\t\t\t\tif ((activeIndex || 0) !== slideIndex) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (slideIndex !== (previousIndex || 0) && runCallbacks) {\n\t\t\tswiper.emit('beforeSlideChangeStart');\n\t\t}\n\n\t\t// Update progress\n\t\tswiper.updateProgress(translate);\n\t\tlet direction;\n\t\tif (slideIndex > activeIndex) direction = 'next'; else if (slideIndex < activeIndex) direction = 'prev'; else direction = 'reset';\n\n\t\t// Update Index\n\t\tif (rtl && -translate === swiper.translate || !rtl && translate === swiper.translate) {\n\t\t\tswiper.updateActiveIndex(slideIndex);\n\t\t\t// Update Height\n\t\t\tif (params.autoHeight) {\n\t\t\t\tswiper.updateAutoHeight();\n\t\t\t}\n\t\t\tswiper.updateSlidesClasses();\n\t\t\tif (params.effect !== 'slide') {\n\t\t\t\tswiper.setTranslate(translate);\n\t\t\t}\n\t\t\tif (direction !== 'reset') {\n\t\t\t\tswiper.transitionStart(runCallbacks, direction);\n\t\t\t\tswiper.transitionEnd(runCallbacks, direction);\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tif (params.cssMode) {\n\t\t\tconst isH = swiper.isHorizontal();\n\t\t\tconst t = rtl ? translate : -translate;\n\t\t\tif (speed === 0) {\n\t\t\t\tconst isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n\t\t\t\tif (isVirtual) {\n\t\t\t\t\tswiper.wrapperEl.style.scrollSnapType = 'none';\n\t\t\t\t\tswiper._immediateVirtual = true;\n\t\t\t\t}\n\t\t\t\tif (isVirtual && !swiper._cssModeVirtualInitialSet && swiper.params.initialSlide > 0) {\n\t\t\t\t\tswiper._cssModeVirtualInitialSet = true;\n\t\t\t\t\trequestAnimationFrame(() => {\n\t\t\t\t\t\twrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\twrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;\n\t\t\t\t}\n\t\t\t\tif (isVirtual) {\n\t\t\t\t\trequestAnimationFrame(() => {\n\t\t\t\t\t\tswiper.wrapperEl.style.scrollSnapType = '';\n\t\t\t\t\t\tswiper._immediateVirtual = false;\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (!swiper.support.smoothScroll) {\n\t\t\t\t\tanimateCSSModeScroll({\n\t\t\t\t\t\tswiper,\n\t\t\t\t\t\ttargetPosition: t,\n\t\t\t\t\t\tside: isH ? 'left' : 'top'\n\t\t\t\t\t});\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\twrapperEl.scrollTo({\n\t\t\t\t\t[isH ? 'left' : 'top']: t,\n\t\t\t\t\tbehavior: 'smooth'\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\tswiper.setTransition(speed);\n\t\tswiper.setTranslate(translate);\n\t\tswiper.updateActiveIndex(slideIndex);\n\t\tswiper.updateSlidesClasses();\n\t\tswiper.emit('beforeTransitionStart', speed, internal);\n\t\tswiper.transitionStart(runCallbacks, direction);\n\t\tif (speed === 0) {\n\t\t\tswiper.transitionEnd(runCallbacks, direction);\n\t\t} else if (!swiper.animating) {\n\t\t\tswiper.animating = true;\n\t\t\tif (!swiper.onSlideToWrapperTransitionEnd) {\n\t\t\t\tswiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {\n\t\t\t\t\tif (!swiper || swiper.destroyed) return;\n\t\t\t\t\tif (e.target !== this) return;\n\t\t\t\t\tswiper.wrapperEl.removeEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);\n\t\t\t\t\tswiper.onSlideToWrapperTransitionEnd = null;\n\t\t\t\t\tdelete swiper.onSlideToWrapperTransitionEnd;\n\t\t\t\t\tswiper.transitionEnd(runCallbacks, direction);\n\t\t\t\t};\n\t\t\t}\n\t\t\tswiper.wrapperEl.addEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);\n\t\t}\n\t\treturn true;\n\t}\n\n\tfunction slideToLoop(index, speed, runCallbacks, internal) {\n\t\tif (index === void 0) {\n\t\t\tindex = 0;\n\t\t}\n\t\tif (speed === void 0) {\n\t\t\tspeed = this.params.speed;\n\t\t}\n\t\tif (runCallbacks === void 0) {\n\t\t\trunCallbacks = true;\n\t\t}\n\t\tif (typeof index === 'string') {\n\t\t\tconst indexAsNumber = parseInt(index, 10);\n\t\t\tindex = indexAsNumber;\n\t\t}\n\t\tconst swiper = this;\n\t\tlet newIndex = index;\n\t\tif (swiper.params.loop) {\n\t\t\tif (swiper.virtual && swiper.params.virtual.enabled) {\n\t\t\t\t// eslint-disable-next-line\n\t\t\t\tnewIndex = newIndex + swiper.virtual.slidesBefore;\n\t\t\t} else {\n\t\t\t\tnewIndex = swiper.getSlideIndexByData(newIndex);\n\t\t\t}\n\t\t}\n\t\treturn swiper.slideTo(newIndex, speed, runCallbacks, internal);\n\t}\n\n\t/* eslint no-unused-vars: \"off\" */\n\tfunction slideNext(speed, runCallbacks, internal) {\n\t\tif (speed === void 0) {\n\t\t\tspeed = this.params.speed;\n\t\t}\n\t\tif (runCallbacks === void 0) {\n\t\t\trunCallbacks = true;\n\t\t}\n\t\tconst swiper = this;\n\t\tconst {\n\t\t\tenabled,\n\t\t\tparams,\n\t\t\tanimating\n\t\t} = swiper;\n\t\tif (!enabled) return swiper;\n\t\tlet perGroup = params.slidesPerGroup;\n\t\tif (params.slidesPerView === 'auto' && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {\n\t\t\tperGroup = Math.max(swiper.slidesPerViewDynamic('current', true), 1);\n\t\t}\n\t\tconst increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : perGroup;\n\t\tconst isVirtual = swiper.virtual && params.virtual.enabled;\n\t\tif (params.loop) {\n\t\t\tif (animating && !isVirtual && params.loopPreventsSliding) return false;\n\t\t\tswiper.loopFix({\n\t\t\t\tdirection: 'next'\n\t\t\t});\n\t\t\t// eslint-disable-next-line\n\t\t\tswiper._clientLeft = swiper.wrapperEl.clientLeft;\n\t\t}\n\t\tif (params.rewind && swiper.isEnd) {\n\t\t\treturn swiper.slideTo(0, speed, runCallbacks, internal);\n\t\t}\n\t\treturn swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);\n\t}\n\n\t/* eslint no-unused-vars: \"off\" */\n\tfunction slidePrev(speed, runCallbacks, internal) {\n\t\tif (speed === void 0) {\n\t\t\tspeed = this.params.speed;\n\t\t}\n\t\tif (runCallbacks === void 0) {\n\t\t\trunCallbacks = true;\n\t\t}\n\t\tconst swiper = this;\n\t\tconst {\n\t\t\tparams,\n\t\t\tsnapGrid,\n\t\t\tslidesGrid,\n\t\t\trtlTranslate,\n\t\t\tenabled,\n\t\t\tanimating\n\t\t} = swiper;\n\t\tif (!enabled) return swiper;\n\t\tconst isVirtual = swiper.virtual && params.virtual.enabled;\n\t\tif (params.loop) {\n\t\t\tif (animating && !isVirtual && params.loopPreventsSliding) return false;\n\t\t\tswiper.loopFix({\n\t\t\t\tdirection: 'prev'\n\t\t\t});\n\t\t\t// eslint-disable-next-line\n\t\t\tswiper._clientLeft = swiper.wrapperEl.clientLeft;\n\t\t}\n\t\tconst translate = rtlTranslate ? swiper.translate : -swiper.translate;\n\t\tfunction normalize(val) {\n\t\t\tif (val < 0) return -Math.floor(Math.abs(val));\n\t\t\treturn Math.floor(val);\n\t\t}\n\t\tconst normalizedTranslate = normalize(translate);\n\t\tconst normalizedSnapGrid = snapGrid.map(val => normalize(val));\n\t\tlet prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];\n\t\tif (typeof prevSnap === 'undefined' && params.cssMode) {\n\t\t\tlet prevSnapIndex;\n\t\t\tsnapGrid.forEach((snap, snapIndex) => {\n\t\t\t\tif (normalizedTranslate >= snap) {\n\t\t\t\t\t// prevSnap = snap;\n\t\t\t\t\tprevSnapIndex = snapIndex;\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (typeof prevSnapIndex !== 'undefined') {\n\t\t\t\tprevSnap = snapGrid[prevSnapIndex > 0 ? prevSnapIndex - 1 : prevSnapIndex];\n\t\t\t}\n\t\t}\n\t\tlet prevIndex = 0;\n\t\tif (typeof prevSnap !== 'undefined') {\n\t\t\tprevIndex = slidesGrid.indexOf(prevSnap);\n\t\t\tif (prevIndex < 0) prevIndex = swiper.activeIndex - 1;\n\t\t\tif (params.slidesPerView === 'auto' && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {\n\t\t\t\tprevIndex = prevIndex - swiper.slidesPerViewDynamic('previous', true) + 1;\n\t\t\t\tprevIndex = Math.max(prevIndex, 0);\n\t\t\t}\n\t\t}\n\t\tif (params.rewind && swiper.isBeginning) {\n\t\t\tconst lastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;\n\t\t\treturn swiper.slideTo(lastIndex, speed, runCallbacks, internal);\n\t\t}\n\t\treturn swiper.slideTo(prevIndex, speed, runCallbacks, internal);\n\t}\n\n\t/* eslint no-unused-vars: \"off\" */\n\tfunction slideReset(speed, runCallbacks, internal) {\n\t\tif (speed === void 0) {\n\t\t\tspeed = this.params.speed;\n\t\t}\n\t\tif (runCallbacks === void 0) {\n\t\t\trunCallbacks = true;\n\t\t}\n\t\tconst swiper = this;\n\t\treturn swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);\n\t}\n\n\t/* eslint no-unused-vars: \"off\" */\n\tfunction slideToClosest(speed, runCallbacks, internal, threshold) {\n\t\tif (speed === void 0) {\n\t\t\tspeed = this.params.speed;\n\t\t}\n\t\tif (runCallbacks === void 0) {\n\t\t\trunCallbacks = true;\n\t\t}\n\t\tif (threshold === void 0) {\n\t\t\tthreshold = 0.5;\n\t\t}\n\t\tconst swiper = this;\n\t\tlet index = swiper.activeIndex;\n\t\tconst skip = Math.min(swiper.params.slidesPerGroupSkip, index);\n\t\tconst snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);\n\t\tconst translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;\n\t\tif (translate >= swiper.snapGrid[snapIndex]) {\n\t\t\t// The current translate is on or after the current snap index, so the choice\n\t\t\t// is between the current index and the one after it.\n\t\t\tconst currentSnap = swiper.snapGrid[snapIndex];\n\t\t\tconst nextSnap = swiper.snapGrid[snapIndex + 1];\n\t\t\tif (translate - currentSnap > (nextSnap - currentSnap) * threshold) {\n\t\t\t\tindex += swiper.params.slidesPerGroup;\n\t\t\t}\n\t\t} else {\n\t\t\t// The current translate is before the current snap index, so the choice\n\t\t\t// is between the current index and the one before it.\n\t\t\tconst prevSnap = swiper.snapGrid[snapIndex - 1];\n\t\t\tconst currentSnap = swiper.snapGrid[snapIndex];\n\t\t\tif (translate - prevSnap <= (currentSnap - prevSnap) * threshold) {\n\t\t\t\tindex -= swiper.params.slidesPerGroup;\n\t\t\t}\n\t\t}\n\t\tindex = Math.max(index, 0);\n\t\tindex = Math.min(index, swiper.slidesGrid.length - 1);\n\t\treturn swiper.slideTo(index, speed, runCallbacks, internal);\n\t}\n\n\tfunction slideToClickedSlide() {\n\t\tconst swiper = this;\n\t\tconst {\n\t\t\tparams,\n\t\t\tslidesEl\n\t\t} = swiper;\n\t\tconst slidesPerView = params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : params.slidesPerView;\n\t\tlet slideToIndex = swiper.clickedIndex;\n\t\tlet realIndex;\n\t\tconst slideSelector = swiper.isElement ? `swiper-slide` : `.${params.slideClass}`;\n\t\tif (params.loop) {\n\t\t\tif (swiper.animating) return;\n\t\t\trealIndex = parseInt(swiper.clickedSlide.getAttribute('data-swiper-slide-index'), 10);\n\t\t\tif (params.centeredSlides) {\n\t\t\t\tif (slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2) {\n\t\t\t\t\tswiper.loopFix();\n\t\t\t\t\tslideToIndex = swiper.getSlideIndex(elementChildren(slidesEl, `${slideSelector}[data-swiper-slide-index=\"${realIndex}\"]`)[0]);\n\t\t\t\t\tnextTick(() => {\n\t\t\t\t\t\tswiper.slideTo(slideToIndex);\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tswiper.slideTo(slideToIndex);\n\t\t\t\t}\n\t\t\t} else if (slideToIndex > swiper.slides.length - slidesPerView) {\n\t\t\t\tswiper.loopFix();\n\t\t\t\tslideToIndex = swiper.getSlideIndex(elementChildren(slidesEl, `${slideSelector}[data-swiper-slide-index=\"${realIndex}\"]`)[0]);\n\t\t\t\tnextTick(() => {\n\t\t\t\t\tswiper.slideTo(slideToIndex);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tswiper.slideTo(slideToIndex);\n\t\t\t}\n\t\t} else {\n\t\t\tswiper.slideTo(slideToIndex);\n\t\t}\n\t}\n\n\tvar slide = {\n\t\tslideTo,\n\t\tslideToLoop,\n\t\tslideNext,\n\t\tslidePrev,\n\t\tslideReset,\n\t\tslideToClosest,\n\t\tslideToClickedSlide\n\t};\n\n\tfunction loopCreate(slideRealIndex) {\n\t\tconst swiper = this;\n\t\tconst {\n\t\t\tparams,\n\t\t\tslidesEl\n\t\t} = swiper;\n\t\tif (!params.loop || swiper.virtual && swiper.params.virtual.enabled) return;\n\t\tconst slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);\n\t\tslides.forEach((el, index) => {\n\t\t\tel.setAttribute('data-swiper-slide-index', index);\n\t\t});\n\t\tswiper.loopFix({\n\t\t\tslideRealIndex,\n\t\t\tdirection: params.centeredSlides ? undefined : 'next'\n\t\t});\n\t}\n\n\tfunction loopFix(_temp) {\n\t\tlet {\n\t\t\tslideRealIndex,\n\t\t\tslideTo = true,\n\t\t\tdirection,\n\t\t\tsetTranslate,\n\t\t\tactiveSlideIndex,\n\t\t\tbyController,\n\t\t\tbyMousewheel\n\t\t} = _temp === void 0 ? {} : _temp;\n\t\tconst swiper = this;\n\t\tif (!swiper.params.loop) return;\n\t\tswiper.emit('beforeLoopFix');\n\t\tconst {\n\t\t\tslides,\n\t\t\tallowSlidePrev,\n\t\t\tallowSlideNext,\n\t\t\tslidesEl,\n\t\t\tparams\n\t\t} = swiper;\n\t\tswiper.allowSlidePrev = true;\n\t\tswiper.allowSlideNext = true;\n\t\tif (swiper.virtual && params.virtual.enabled) {\n\t\t\tif (slideTo) {\n\t\t\t\tif (!params.centeredSlides && swiper.snapIndex === 0) {\n\t\t\t\t\tswiper.slideTo(swiper.virtual.slides.length, 0, false, true);\n\t\t\t\t} else if (params.centeredSlides && swiper.snapIndex < params.slidesPerView) {\n\t\t\t\t\tswiper.slideTo(swiper.virtual.slides.length + swiper.snapIndex, 0, false, true);\n\t\t\t\t} else if (swiper.snapIndex === swiper.snapGrid.length - 1) {\n\t\t\t\t\tswiper.slideTo(swiper.virtual.slidesBefore, 0, false, true);\n\t\t\t\t}\n\t\t\t}\n\t\t\tswiper.allowSlidePrev = allowSlidePrev;\n\t\t\tswiper.allowSlideNext = allowSlideNext;\n\t\t\tswiper.emit('loopFix');\n\t\t\treturn;\n\t\t}\n\t\tconst slidesPerView = params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : Math.ceil(parseFloat(params.slidesPerView, 10));\n\t\tlet loopedSlides = params.loopedSlides || slidesPerView;\n\t\tif (loopedSlides % params.slidesPerGroup !== 0) {\n\t\t\tloopedSlides += params.slidesPerGroup - loopedSlides % params.slidesPerGroup;\n\t\t}\n\t\tswiper.loopedSlides = loopedSlides;\n\t\tconst prependSlidesIndexes = [];\n\t\tconst appendSlidesIndexes = [];\n\t\tlet activeIndex = swiper.activeIndex;\n\t\tif (typeof activeSlideIndex === 'undefined') {\n\t\t\tactiveSlideIndex = swiper.getSlideIndex(swiper.slides.filter(el => el.classList.contains(params.slideActiveClass))[0]);\n\t\t} else {\n\t\t\tactiveIndex = activeSlideIndex;\n\t\t}\n\t\tconst isNext = direction === 'next' || !direction;\n\t\tconst isPrev = direction === 'prev' || !direction;\n\t\tlet slidesPrepended = 0;\n\t\tlet slidesAppended = 0;\n\t\t// prepend last slides before start\n\t\tif (activeSlideIndex < loopedSlides) {\n\t\t\tslidesPrepended = Math.max(loopedSlides - activeSlideIndex, params.slidesPerGroup);\n\t\t\tfor (let i = 0; i < loopedSlides - activeSlideIndex; i += 1) {\n\t\t\t\tconst index = i - Math.floor(i / slides.length) * slides.length;\n\t\t\t\tprependSlidesIndexes.push(slides.length - index - 1);\n\t\t\t}\n\t\t} else if (activeSlideIndex /* + slidesPerView */ > swiper.slides.length - loopedSlides * 2) {\n\t\t\tslidesAppended = Math.max(activeSlideIndex - (swiper.slides.length - loopedSlides * 2), params.slidesPerGroup);\n\t\t\tfor (let i = 0; i < slidesAppended; i += 1) {\n\t\t\t\tconst index = i - Math.floor(i / slides.length) * slides.length;\n\t\t\t\tappendSlidesIndexes.push(index);\n\t\t\t}\n\t\t}\n\t\tif (isPrev) {\n\t\t\tprependSlidesIndexes.forEach(index => {\n\t\t\t\tswiper.slides[index].swiperLoopMoveDOM = true;\n\t\t\t\tslidesEl.prepend(swiper.slides[index]);\n\t\t\t\tswiper.slides[index].swiperLoopMoveDOM = false;\n\t\t\t});\n\t\t}\n\t\tif (isNext) {\n\t\t\tappendSlidesIndexes.forEach(index => {\n\t\t\t\tswiper.slides[index].swiperLoopMoveDOM = true;\n\t\t\t\tslidesEl.append(swiper.slides[index]);\n\t\t\t\tswiper.slides[index].swiperLoopMoveDOM = false;\n\t\t\t});\n\t\t}\n\t\tswiper.recalcSlides();\n\t\tif (params.slidesPerView === 'auto') {\n\t\t\tswiper.updateSlides();\n\t\t}\n\t\tif (params.watchSlidesProgress) {\n\t\t\tswiper.updateSlidesOffset();\n\t\t}\n\t\tif (slideTo) {\n\t\t\tif (prependSlidesIndexes.length > 0 && isPrev) {\n\t\t\t\tif (typeof slideRealIndex === 'undefined') {\n\t\t\t\t\tconst currentSlideTranslate = swiper.slidesGrid[activeIndex];\n\t\t\t\t\tconst newSlideTranslate = swiper.slidesGrid[activeIndex + slidesPrepended];\n\t\t\t\t\tconst diff = newSlideTranslate - currentSlideTranslate;\n\t\t\t\t\tif (byMousewheel) {\n\t\t\t\t\t\tswiper.setTranslate(swiper.translate - diff);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tswiper.slideTo(activeIndex + slidesPrepended, 0, false, true);\n\t\t\t\t\t\tif (setTranslate) {\n\t\t\t\t\t\t\tswiper.touches[swiper.isHorizontal() ? 'startX' : 'startY'] += diff;\n\t\t\t\t\t\t\tswiper.touchEventsData.currentTranslate = swiper.translate;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (setTranslate) {\n\t\t\t\t\t\tswiper.slideToLoop(slideRealIndex, 0, false, true);\n\t\t\t\t\t\tswiper.touchEventsData.currentTranslate = swiper.translate;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (appendSlidesIndexes.length > 0 && isNext) {\n\t\t\t\tif (typeof slideRealIndex === 'undefined') {\n\t\t\t\t\tconst currentSlideTranslate = swiper.slidesGrid[activeIndex];\n\t\t\t\t\tconst newSlideTranslate = swiper.slidesGrid[activeIndex - slidesAppended];\n\t\t\t\t\tconst diff = newSlideTranslate - currentSlideTranslate;\n\t\t\t\t\tif (byMousewheel) {\n\t\t\t\t\t\tswiper.setTranslate(swiper.translate - diff);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tswiper.slideTo(activeIndex - slidesAppended, 0, false, true);\n\t\t\t\t\t\tif (setTranslate) {\n\t\t\t\t\t\t\tswiper.touches[swiper.isHorizontal() ? 'startX' : 'startY'] += diff;\n\t\t\t\t\t\t\tswiper.touchEventsData.currentTranslate = swiper.translate;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tswiper.slideToLoop(slideRealIndex, 0, false, true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tswiper.allowSlidePrev = allowSlidePrev;\n\t\tswiper.allowSlideNext = allowSlideNext;\n\t\tif (swiper.controller && swiper.controller.control && !byController) {\n\t\t\tconst loopParams = {\n\t\t\t\tslideRealIndex,\n\t\t\t\tdirection,\n\t\t\t\tsetTranslate,\n\t\t\t\tactiveSlideIndex,\n\t\t\t\tbyController: true\n\t\t\t};\n\t\t\tif (Array.isArray(swiper.controller.control)) {\n\t\t\t\tswiper.controller.control.forEach(c => {\n\t\t\t\t\tif (!c.destroyed && c.params.loop) c.loopFix({\n\t\t\t\t\t\t...loopParams,\n\t\t\t\t\t\tslideTo: c.params.slidesPerView === params.slidesPerView ? slideTo : false\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t} else if (swiper.controller.control instanceof swiper.constructor && swiper.controller.control.params.loop) {\n\t\t\t\tswiper.controller.control.loopFix({\n\t\t\t\t\t...loopParams,\n\t\t\t\t\tslideTo: swiper.controller.control.params.slidesPerView === params.slidesPerView ? slideTo : false\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\tswiper.emit('loopFix');\n\t}\n\n\tfunction loopDestroy() {\n\t\tconst swiper = this;\n\t\tconst {\n\t\t\tparams,\n\t\t\tslidesEl\n\t\t} = swiper;\n\t\tif (!params.loop || swiper.virtual && swiper.params.virtual.enabled) return;\n\t\tswiper.recalcSlides();\n\t\tconst newSlidesOrder = [];\n\t\tswiper.slides.forEach(slideEl => {\n\t\t\tconst index = typeof slideEl.swiperSlideIndex === 'undefined' ? slideEl.getAttribute('data-swiper-slide-index') * 1 : slideEl.swiperSlideIndex;\n\t\t\tnewSlidesOrder[index] = slideEl;\n\t\t});\n\t\tswiper.slides.forEach(slideEl => {\n\t\t\tslideEl.removeAttribute('data-swiper-slide-index');\n\t\t});\n\t\tnewSlidesOrder.forEach(slideEl => {\n\t\t\tslidesEl.append(slideEl);\n\t\t});\n\t\tswiper.recalcSlides();\n\t\tswiper.slideTo(swiper.realIndex, 0);\n\t}\n\n\tvar loop = {\n\t\tloopCreate,\n\t\tloopFix,\n\t\tloopDestroy\n\t};\n\n\tfunction setGrabCursor(moving) {\n\t\tconst swiper = this;\n\t\tif (!swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) return;\n\t\tconst el = swiper.params.touchEventsTarget === 'container' ? swiper.el : swiper.wrapperEl;\n\t\tif (swiper.isElement) {\n\t\t\tswiper.__preventObserver__ = true;\n\t\t}\n\t\tel.style.cursor = 'move';\n\t\tel.style.cursor = moving ? 'grabbing' : 'grab';\n\t\tif (swiper.isElement) {\n\t\t\trequestAnimationFrame(() => {\n\t\t\t\tswiper.__preventObserver__ = false;\n\t\t\t});\n\t\t}\n\t}\n\n\tfunction unsetGrabCursor() {\n\t\tconst swiper = this;\n\t\tif (swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) {\n\t\t\treturn;\n\t\t}\n\t\tif (swiper.isElement) {\n\t\t\tswiper.__preventObserver__ = true;\n\t\t}\n\t\tswiper[swiper.params.touchEventsTarget === 'container' ? 'el' : 'wrapperEl'].style.cursor = '';\n\t\tif (swiper.isElement) {\n\t\t\trequestAnimationFrame(() => {\n\t\t\t\tswiper.__preventObserver__ = false;\n\t\t\t});\n\t\t}\n\t}\n\n\tvar grabCursor = {\n\t\tsetGrabCursor,\n\t\tunsetGrabCursor\n\t};\n\n\t// Modified from https://stackoverflow.com/questions/54520554/custom-element-getrootnode-closest-function-crossing-multiple-parent-shadowd\n\tfunction closestElement(selector, base) {\n\t\tif (base === void 0) {\n\t\t\tbase = this;\n\t\t}\n\t\tfunction __closestFrom(el) {\n\t\t\tif (!el || el === getDocument() || el === getWindow()) return null;\n\t\t\tif (el.assignedSlot) el = el.assignedSlot;\n\t\t\tconst found = el.closest(selector);\n\t\t\tif (!found && !el.getRootNode) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn found || __closestFrom(el.getRootNode().host);\n\t\t}\n\t\treturn __closestFrom(base);\n\t}\n\tfunction onTouchStart(event) {\n\t\tconst swiper = this;\n\t\tconst document = getDocument();\n\t\tconst window = getWindow();\n\t\tconst data = swiper.touchEventsData;\n\t\tdata.evCache.push(event);\n\t\tconst {\n\t\t\tparams,\n\t\t\ttouches,\n\t\t\tenabled\n\t\t} = swiper;\n\t\tif (!enabled) return;\n\t\tif (!params.simulateTouch && event.pointerType === 'mouse') return;\n\t\tif (swiper.animating && params.preventInteractionOnTransition) {\n\t\t\treturn;\n\t\t}\n\t\tif (!swiper.animating && params.cssMode && params.loop) {\n\t\t\tswiper.loopFix();\n\t\t}\n\t\tlet e = event;\n\t\tif (e.originalEvent) e = e.originalEvent;\n\t\tlet targetEl = e.target;\n\t\tif (params.touchEventsTarget === 'wrapper') {\n\t\t\tif (!swiper.wrapperEl.contains(targetEl)) return;\n\t\t}\n\t\tif ('which' in e && e.which === 3) return;\n\t\tif ('button' in e && e.button > 0) return;\n\t\tif (data.isTouched && data.isMoved) return;\n\n\t\t// change target el for shadow root component\n\t\tconst swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== '';\n\t\t// eslint-disable-next-line\n\t\tconst eventPath = event.composedPath ? event.composedPath() : event.path;\n\t\tif (swipingClassHasValue && e.target && e.target.shadowRoot && eventPath) {\n\t\t\ttargetEl = eventPath[0];\n\t\t}\n\t\tconst noSwipingSelector = params.noSwipingSelector ? params.noSwipingSelector : `.${params.noSwipingClass}`;\n\t\tconst isTargetShadow = !!(e.target && e.target.shadowRoot);\n\n\t\t// use closestElement for shadow root element to get the actual closest for nested shadow root element\n\t\tif (params.noSwiping && (isTargetShadow ? closestElement(noSwipingSelector, targetEl) : targetEl.closest(noSwipingSelector))) {\n\t\t\tswiper.allowClick = true;\n\t\t\treturn;\n\t\t}\n\t\tif (params.swipeHandler) {\n\t\t\tif (!targetEl.closest(params.swipeHandler)) return;\n\t\t}\n\t\ttouches.currentX = e.pageX;\n\t\ttouches.currentY = e.pageY;\n\t\tconst startX = touches.currentX;\n\t\tconst startY = touches.currentY;\n\n\t\t// Do NOT start if iOS edge swipe is detected. Otherwise iOS app cannot swipe-to-go-back anymore\n\n\t\tconst edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;\n\t\tconst edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;\n\t\tif (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window.innerWidth - edgeSwipeThreshold)) {\n\t\t\tif (edgeSwipeDetection === 'prevent') {\n\t\t\t\tevent.preventDefault();\n\t\t\t} else {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tObject.assign(data, {\n\t\t\tisTouched: true,\n\t\t\tisMoved: false,\n\t\t\tallowTouchCallbacks: true,\n\t\t\tisScrolling: undefined,\n\t\t\tstartMoving: undefined\n\t\t});\n\t\ttouches.startX = startX;\n\t\ttouches.startY = startY;\n\t\tdata.touchStartTime = now();\n\t\tswiper.allowClick = true;\n\t\tswiper.updateSize();\n\t\tswiper.swipeDirection = undefined;\n\t\tif (params.threshold > 0) data.allowThresholdMove = false;\n\t\tlet preventDefault = true;\n\t\tif (targetEl.matches(data.focusableElements)) {\n\t\t\tpreventDefault = false;\n\t\t\tif (targetEl.nodeName === 'SELECT') {\n\t\t\t\tdata.isTouched = false;\n\t\t\t}\n\t\t}\n\t\tif (document.activeElement && document.activeElement.matches(data.focusableElements) && document.activeElement !== targetEl) {\n\t\t\tdocument.activeElement.blur();\n\t\t}\n\t\tconst shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;\n\t\tif ((params.touchStartForcePreventDefault || shouldPreventDefault) && !targetEl.isContentEditable) {\n\t\t\te.preventDefault();\n\t\t}\n\t\tif (params.freeMode && params.freeMode.enabled && swiper.freeMode && swiper.animating && !params.cssMode) {\n\t\t\tswiper.freeMode.onTouchStart();\n\t\t}\n\t\tswiper.emit('touchStart', e);\n\t}\n\n\tfunction onTouchMove(event) {\n\t\tconst document = getDocument();\n\t\tconst swiper = this;\n\t\tconst data = swiper.touchEventsData;\n\t\tconst {\n\t\t\tparams,\n\t\t\ttouches,\n\t\t\trtlTranslate: rtl,\n\t\t\tenabled\n\t\t} = swiper;\n\t\tif (!enabled) return;\n\t\tif (!params.simulateTouch && event.pointerType === 'mouse') return;\n\t\tlet e = event;\n\t\tif (e.originalEvent) e = e.originalEvent;\n\t\tif (!data.isTouched) {\n\t\t\tif (data.startMoving && data.isScrolling) {\n\t\t\t\tswiper.emit('touchMoveOpposite', e);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tconst pointerIndex = data.evCache.findIndex(cachedEv => cachedEv.pointerId === e.pointerId);\n\t\tif (pointerIndex >= 0) data.evCache[pointerIndex] = e;\n\t\tconst targetTouch = data.evCache.length > 1 ? data.evCache[0] : e;\n\t\tconst pageX = targetTouch.pageX;\n\t\tconst pageY = targetTouch.pageY;\n\t\tif (e.preventedByNestedSwiper) {\n\t\t\ttouches.startX = pageX;\n\t\t\ttouches.startY = pageY;\n\t\t\treturn;\n\t\t}\n\t\tif (!swiper.allowTouchMove) {\n\t\t\tif (!e.target.matches(data.focusableElements)) {\n\t\t\t\tswiper.allowClick = false;\n\t\t\t}\n\t\t\tif (data.isTouched) {\n\t\t\t\tObject.assign(touches, {\n\t\t\t\t\tstartX: pageX,\n\t\t\t\t\tstartY: pageY,\n\t\t\t\t\tprevX: swiper.touches.currentX,\n\t\t\t\t\tprevY: swiper.touches.currentY,\n\t\t\t\t\tcurrentX: pageX,\n\t\t\t\t\tcurrentY: pageY\n\t\t\t\t});\n\t\t\t\tdata.touchStartTime = now();\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (params.touchReleaseOnEdges && !params.loop) {\n\t\t\tif (swiper.isVertical()) {\n\t\t\t\t// Vertical\n\t\t\t\tif (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {\n\t\t\t\t\tdata.isTouched = false;\n\t\t\t\t\tdata.isMoved = false;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else if (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (document.activeElement) {\n\t\t\tif (e.target === document.activeElement && e.target.matches(data.focusableElements)) {\n\t\t\t\tdata.isMoved = true;\n\t\t\t\tswiper.allowClick = false;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (data.allowTouchCallbacks) {\n\t\t\tswiper.emit('touchMove', e);\n\t\t}\n\t\tif (e.targetTouches && e.targetTouches.length > 1) return;\n\t\ttouches.currentX = pageX;\n\t\ttouches.currentY = pageY;\n\t\tconst diffX = touches.currentX - touches.startX;\n\t\tconst diffY = touches.currentY - touches.startY;\n\t\tif (swiper.params.threshold && Math.sqrt(diffX ** 2 + diffY ** 2) < swiper.params.threshold) return;\n\t\tif (typeof data.isScrolling === 'undefined') {\n\t\t\tlet touchAngle;\n\t\t\tif (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) {\n\t\t\t\tdata.isScrolling = false;\n\t\t\t} else {\n\t\t\t\t// eslint-disable-next-line\n\t\t\t\tif (diffX * diffX + diffY * diffY >= 25) {\n\t\t\t\t\ttouchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;\n\t\t\t\t\tdata.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (data.isScrolling) {\n\t\t\tswiper.emit('touchMoveOpposite', e);\n\t\t}\n\t\tif (typeof data.startMoving === 'undefined') {\n\t\t\tif (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {\n\t\t\t\tdata.startMoving = true;\n\t\t\t}\n\t\t}\n\t\tif (data.isScrolling || swiper.zoom && swiper.params.zoom && swiper.params.zoom.enabled && data.evCache.length > 1) {\n\t\t\tdata.isTouched = false;\n\t\t\treturn;\n\t\t}\n\t\tif (!data.startMoving) {\n\t\t\treturn;\n\t\t}\n\t\tswiper.allowClick = false;\n\t\tif (!params.cssMode && e.cancelable) {\n\t\t\te.preventDefault();\n\t\t}\n\t\tif (params.touchMoveStopPropagation && !params.nested) {\n\t\t\te.stopPropagation();\n\t\t}\n\t\tlet diff = swiper.isHorizontal() ? diffX : diffY;\n\t\tlet touchesDiff = swiper.isHorizontal() ? touches.currentX - touches.previousX : touches.currentY - touches.previousY;\n\t\tif (params.oneWayMovement) {\n\t\t\tdiff = Math.abs(diff) * (rtl ? 1 : -1);\n\t\t\ttouchesDiff = Math.abs(touchesDiff) * (rtl ? 1 : -1);\n\t\t}\n\t\ttouches.diff = diff;\n\t\tdiff *= params.touchRatio;\n\t\tif (rtl) {\n\t\t\tdiff = -diff;\n\t\t\ttouchesDiff = -touchesDiff;\n\t\t}\n\t\tconst prevTouchesDirection = swiper.touchesDirection;\n\t\tswiper.swipeDirection = diff > 0 ? 'prev' : 'next';\n\t\tswiper.touchesDirection = touchesDiff > 0 ? 'prev' : 'next';\n\t\tconst isLoop = swiper.params.loop && !params.cssMode;\n\t\tif (!data.isMoved) {\n\t\t\tif (isLoop) {\n\t\t\t\tswiper.loopFix({\n\t\t\t\t\tdirection: swiper.swipeDirection\n\t\t\t\t});\n\t\t\t}\n\t\t\tdata.startTranslate = swiper.getTranslate();\n\t\t\tswiper.setTransition(0);\n\t\t\tif (swiper.animating) {\n\t\t\t\tconst evt = new window.CustomEvent('transitionend', {\n\t\t\t\t\tbubbles: true,\n\t\t\t\t\tcancelable: true\n\t\t\t\t});\n\t\t\t\tswiper.wrapperEl.dispatchEvent(evt);\n\t\t\t}\n\t\t\tdata.allowMomentumBounce = false;\n\t\t\t// Grab Cursor\n\t\t\tif (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {\n\t\t\t\tswiper.setGrabCursor(true);\n\t\t\t}\n\t\t\tswiper.emit('sliderFirstMove', e);\n\t\t}\n\t\tlet loopFixed;\n\t\tif (data.isMoved && prevTouchesDirection !== swiper.touchesDirection && isLoop && Math.abs(diff) >= 1) {\n\t\t\t// need another loop fix\n\t\t\tswiper.loopFix({\n\t\t\t\tdirection: swiper.swipeDirection,\n\t\t\t\tsetTranslate: true\n\t\t\t});\n\t\t\tloopFixed = true;\n\t\t}\n\t\tswiper.emit('sliderMove', e);\n\t\tdata.isMoved = true;\n\t\tdata.currentTranslate = diff + data.startTranslate;\n\t\tlet disableParentSwiper = true;\n\t\tlet resistanceRatio = params.resistanceRatio;\n\t\tif (params.touchReleaseOnEdges) {\n\t\t\tresistanceRatio = 0;\n\t\t}\n\t\tif (diff > 0) {\n\t\t\tif (isLoop && !loopFixed && data.currentTranslate > (params.centeredSlides ? swiper.minTranslate() - swiper.size / 2 : swiper.minTranslate())) {\n\t\t\t\tswiper.loopFix({\n\t\t\t\t\tdirection: 'prev',\n\t\t\t\t\tsetTranslate: true,\n\t\t\t\t\tactiveSlideIndex: 0\n\t\t\t\t});\n\t\t\t}\n\t\t\tif (data.currentTranslate > swiper.minTranslate()) {\n\t\t\t\tdisableParentSwiper = false;\n\t\t\t\tif (params.resistance) {\n\t\t\t\t\tdata.currentTranslate = swiper.minTranslate() - 1 + (-swiper.minTranslate() + data.startTranslate + diff) ** resistanceRatio;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (diff < 0) {\n\t\t\tif (isLoop && !loopFixed && data.currentTranslate < (params.centeredSlides ? swiper.maxTranslate() + swiper.size / 2 : swiper.maxTranslate())) {\n\t\t\t\tswiper.loopFix({\n\t\t\t\t\tdirection: 'next',\n\t\t\t\t\tsetTranslate: true,\n\t\t\t\t\tactiveSlideIndex: swiper.slides.length - (params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : Math.ceil(parseFloat(params.slidesPerView, 10)))\n\t\t\t\t});\n\t\t\t}\n\t\t\tif (data.currentTranslate < swiper.maxTranslate()) {\n\t\t\t\tdisableParentSwiper = false;\n\t\t\t\tif (params.resistance) {\n\t\t\t\t\tdata.currentTranslate = swiper.maxTranslate() + 1 - (swiper.maxTranslate() - data.startTranslate - diff) ** resistanceRatio;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (disableParentSwiper) {\n\t\t\te.preventedByNestedSwiper = true;\n\t\t}\n\n\t\t// Directions locks\n\t\tif (!swiper.allowSlideNext && swiper.swipeDirection === 'next' && data.currentTranslate < data.startTranslate) {\n\t\t\tdata.currentTranslate = data.startTranslate;\n\t\t}\n\t\tif (!swiper.allowSlidePrev && swiper.swipeDirection === 'prev' && data.currentTranslate > data.startTranslate) {\n\t\t\tdata.currentTranslate = data.startTranslate;\n\t\t}\n\t\tif (!swiper.allowSlidePrev && !swiper.allowSlideNext) {\n\t\t\tdata.currentTranslate = data.startTranslate;\n\t\t}\n\n\t\t// Threshold\n\t\tif (params.threshold > 0) {\n\t\t\tif (Math.abs(diff) > params.threshold || data.allowThresholdMove) {\n\t\t\t\tif (!data.allowThresholdMove) {\n\t\t\t\t\tdata.allowThresholdMove = true;\n\t\t\t\t\ttouches.startX = touches.currentX;\n\t\t\t\t\ttouches.startY = touches.currentY;\n\t\t\t\t\tdata.currentTranslate = data.startTranslate;\n\t\t\t\t\ttouches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdata.currentTranslate = data.startTranslate;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (!params.followFinger || params.cssMode) return;\n\n\t\t// Update active index in free mode\n\t\tif (params.freeMode && params.freeMode.enabled && swiper.freeMode || params.watchSlidesProgress) {\n\t\t\tswiper.updateActiveIndex();\n\t\t\tswiper.updateSlidesClasses();\n\t\t}\n\t\tif (params.freeMode && params.freeMode.enabled && swiper.freeMode) {\n\t\t\tswiper.freeMode.onTouchMove();\n\t\t}\n\t\t// Update progress\n\t\tswiper.updateProgress(data.currentTranslate);\n\t\t// Update translate\n\t\tswiper.setTranslate(data.currentTranslate);\n\t}\n\n\tfunction onTouchEnd(event) {\n\t\tconst swiper = this;\n\t\tconst data = swiper.touchEventsData;\n\t\tconst pointerIndex = data.evCache.findIndex(cachedEv => cachedEv.pointerId === event.pointerId);\n\t\tif (pointerIndex >= 0) {\n\t\t\tdata.evCache.splice(pointerIndex, 1);\n\t\t}\n\t\tif (['pointercancel', 'pointerout', 'pointerleave', 'contextmenu'].includes(event.type)) {\n\t\t\tconst proceed = ['pointercancel', 'contextmenu'].includes(event.type) && (swiper.browser.isSafari || swiper.browser.isWebView);\n\t\t\tif (!proceed) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tconst {\n\t\t\tparams,\n\t\t\ttouches,\n\t\t\trtlTranslate: rtl,\n\t\t\tslidesGrid,\n\t\t\tenabled\n\t\t} = swiper;\n\t\tif (!enabled) return;\n\t\tif (!params.simulateTouch && event.pointerType === 'mouse') return;\n\t\tlet e = event;\n\t\tif (e.originalEvent) e = e.originalEvent;\n\t\tif (data.allowTouchCallbacks) {\n\t\t\tswiper.emit('touchEnd', e);\n\t\t}\n\t\tdata.allowTouchCallbacks = false;\n\t\tif (!data.isTouched) {\n\t\t\tif (data.isMoved && params.grabCursor) {\n\t\t\t\tswiper.setGrabCursor(false);\n\t\t\t}\n\t\t\tdata.isMoved = false;\n\t\t\tdata.startMoving = false;\n\t\t\treturn;\n\t\t}\n\t\t// Return Grab Cursor\n\t\tif (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {\n\t\t\tswiper.setGrabCursor(false);\n\t\t}\n\n\t\t// Time diff\n\t\tconst touchEndTime = now();\n\t\tconst timeDiff = touchEndTime - data.touchStartTime;\n\n\t\t// Tap, doubleTap, Click\n\t\tif (swiper.allowClick) {\n\t\t\tconst pathTree = e.path || e.composedPath && e.composedPath();\n\t\t\tswiper.updateClickedSlide(pathTree && pathTree[0] || e.target);\n\t\t\tswiper.emit('tap click', e);\n\t\t\tif (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {\n\t\t\t\tswiper.emit('doubleTap doubleClick', e);\n\t\t\t}\n\t\t}\n\t\tdata.lastClickTime = now();\n\t\tnextTick(() => {\n\t\t\tif (!swiper.destroyed) swiper.allowClick = true;\n\t\t});\n\t\tif (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {\n\t\t\tdata.isTouched = false;\n\t\t\tdata.isMoved = false;\n\t\t\tdata.startMoving = false;\n\t\t\treturn;\n\t\t}\n\t\tdata.isTouched = false;\n\t\tdata.isMoved = false;\n\t\tdata.startMoving = false;\n\t\tlet currentPos;\n\t\tif (params.followFinger) {\n\t\t\tcurrentPos = rtl ? swiper.translate : -swiper.translate;\n\t\t} else {\n\t\t\tcurrentPos = -data.currentTranslate;\n\t\t}\n\t\tif (params.cssMode) {\n\t\t\treturn;\n\t\t}\n\t\tif (params.freeMode && params.freeMode.enabled) {\n\t\t\tswiper.freeMode.onTouchEnd({\n\t\t\t\tcurrentPos\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\n\t\t// Find current slide\n\t\tlet stopIndex = 0;\n\t\tlet groupSize = swiper.slidesSizesGrid[0];\n\t\tfor (let i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {\n\t\t\tconst increment = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;\n\t\t\tif (typeof slidesGrid[i + increment] !== 'undefined') {\n\t\t\t\tif (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + increment]) {\n\t\t\t\t\tstopIndex = i;\n\t\t\t\t\tgroupSize = slidesGrid[i + increment] - slidesGrid[i];\n\t\t\t\t}\n\t\t\t} else if (currentPos >= slidesGrid[i]) {\n\t\t\t\tstopIndex = i;\n\t\t\t\tgroupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];\n\t\t\t}\n\t\t}\n\t\tlet rewindFirstIndex = null;\n\t\tlet rewindLastIndex = null;\n\t\tif (params.rewind) {\n\t\t\tif (swiper.isBeginning) {\n\t\t\t\trewindLastIndex = params.virtual && params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;\n\t\t\t} else if (swiper.isEnd) {\n\t\t\t\trewindFirstIndex = 0;\n\t\t\t}\n\t\t}\n\t\t// Find current slide size\n\t\tconst ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;\n\t\tconst increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;\n\t\tif (timeDiff > params.longSwipesMs) {\n\t\t\t// Long touches\n\t\t\tif (!params.longSwipes) {\n\t\t\t\tswiper.slideTo(swiper.activeIndex);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (swiper.swipeDirection === 'next') {\n\t\t\t\tif (ratio >= params.longSwipesRatio) swiper.slideTo(params.rewind && swiper.isEnd ? rewindFirstIndex : stopIndex + increment); else swiper.slideTo(stopIndex);\n\t\t\t}\n\t\t\tif (swiper.swipeDirection === 'prev') {\n\t\t\t\tif (ratio > 1 - params.longSwipesRatio) {\n\t\t\t\t\tswiper.slideTo(stopIndex + increment);\n\t\t\t\t} else if (rewindLastIndex !== null && ratio < 0 && Math.abs(ratio) > params.longSwipesRatio) {\n\t\t\t\t\tswiper.slideTo(rewindLastIndex);\n\t\t\t\t} else {\n\t\t\t\t\tswiper.slideTo(stopIndex);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// Short swipes\n\t\t\tif (!params.shortSwipes) {\n\t\t\t\tswiper.slideTo(swiper.activeIndex);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);\n\t\t\tif (!isNavButtonTarget) {\n\t\t\t\tif (swiper.swipeDirection === 'next') {\n\t\t\t\t\tswiper.slideTo(rewindFirstIndex !== null ? rewindFirstIndex : stopIndex + increment);\n\t\t\t\t}\n\t\t\t\tif (swiper.swipeDirection === 'prev') {\n\t\t\t\t\tswiper.slideTo(rewindLastIndex !== null ? rewindLastIndex : stopIndex);\n\t\t\t\t}\n\t\t\t} else if (e.target === swiper.navigation.nextEl) {\n\t\t\t\tswiper.slideTo(stopIndex + increment);\n\t\t\t} else {\n\t\t\t\tswiper.slideTo(stopIndex);\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction onResize() {\n\t\tconst swiper = this;\n\t\tconst {\n\t\t\tparams,\n\t\t\tel\n\t\t} = swiper;\n\t\tif (el && el.offsetWidth === 0) return;\n\n\t\t// Breakpoints\n\t\tif (params.breakpoints) {\n\t\t\tswiper.setBreakpoint();\n\t\t}\n\n\t\t// Save locks\n\t\tconst {\n\t\t\tallowSlideNext,\n\t\t\tallowSlidePrev,\n\t\t\tsnapGrid\n\t\t} = swiper;\n\t\tconst isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n\n\t\t// Disable locks on resize\n\t\tswiper.allowSlideNext = true;\n\t\tswiper.allowSlidePrev = true;\n\t\tswiper.updateSize();\n\t\tswiper.updateSlides();\n\t\tswiper.updateSlidesClasses();\n\t\tconst isVirtualLoop = isVirtual && params.loop;\n\t\tif ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides && !isVirtualLoop) {\n\t\t\tswiper.slideTo(swiper.slides.length - 1, 0, false, true);\n\t\t} else {\n\t\t\tif (swiper.params.loop && !isVirtual) {\n\t\t\t\tswiper.slideToLoop(swiper.realIndex, 0, false, true);\n\t\t\t} else {\n\t\t\t\tswiper.slideTo(swiper.activeIndex, 0, false, true);\n\t\t\t}\n\t\t}\n\t\tif (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {\n\t\t\tclearTimeout(swiper.autoplay.resizeTimeout);\n\t\t\tswiper.autoplay.resizeTimeout = setTimeout(() => {\n\t\t\t\tif (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {\n\t\t\t\t\tswiper.autoplay.resume();\n\t\t\t\t}\n\t\t\t}, 500);\n\t\t}\n\t\t// Return locks after resize\n\t\tswiper.allowSlidePrev = allowSlidePrev;\n\t\tswiper.allowSlideNext = allowSlideNext;\n\t\tif (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {\n\t\t\tswiper.checkOverflow();\n\t\t}\n\t}\n\n\tfunction onClick(e) {\n\t\tconst swiper = this;\n\t\tif (!swiper.enabled) return;\n\t\tif (!swiper.allowClick) {\n\t\t\tif (swiper.params.preventClicks) e.preventDefault();\n\t\t\tif (swiper.params.preventClicksPropagation && swiper.animating) {\n\t\t\t\te.stopPropagation();\n\t\t\t\te.stopImmediatePropagation();\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction onScroll() {\n\t\tconst swiper = this;\n\t\tconst {\n\t\t\twrapperEl,\n\t\t\trtlTranslate,\n\t\t\tenabled\n\t\t} = swiper;\n\t\tif (!enabled) return;\n\t\tswiper.previousTranslate = swiper.translate;\n\t\tif (swiper.isHorizontal()) {\n\t\t\tswiper.translate = -wrapperEl.scrollLeft;\n\t\t} else {\n\t\t\tswiper.translate = -wrapperEl.scrollTop;\n\t\t}\n\t\t// eslint-disable-next-line\n\t\tif (swiper.translate === 0) swiper.translate = 0;\n\t\tswiper.updateActiveIndex();\n\t\tswiper.updateSlidesClasses();\n\t\tlet newProgress;\n\t\tconst translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n\t\tif (translatesDiff === 0) {\n\t\t\tnewProgress = 0;\n\t\t} else {\n\t\t\tnewProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;\n\t\t}\n\t\tif (newProgress !== swiper.progress) {\n\t\t\tswiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);\n\t\t}\n\t\tswiper.emit('setTranslate', swiper.translate, false);\n\t}\n\n\tfunction onLoad(e) {\n\t\tconst swiper = this;\n\t\tprocessLazyPreloader(swiper, e.target);\n\t\tif (swiper.params.cssMode || swiper.params.slidesPerView !== 'auto' && !swiper.params.autoHeight) {\n\t\t\treturn;\n\t\t}\n\t\tswiper.update();\n\t}\n\n\tlet dummyEventAttached = false;\n\tfunction dummyEventListener() { }\n\tconst events = (swiper, method) => {\n\t\tconst document = getDocument();\n\t\tconst {\n\t\t\tparams,\n\t\t\tel,\n\t\t\twrapperEl,\n\t\t\tdevice\n\t\t} = swiper;\n\t\tconst capture = !!params.nested;\n\t\tconst domMethod = method === 'on' ? 'addEventListener' : 'removeEventListener';\n\t\tconst swiperMethod = method;\n\n\t\t// Touch Events\n\t\tel[domMethod]('pointerdown', swiper.onTouchStart, {\n\t\t\tpassive: false\n\t\t});\n\t\tdocument[domMethod]('pointermove', swiper.onTouchMove, {\n\t\t\tpassive: false,\n\t\t\tcapture\n\t\t});\n\t\tdocument[domMethod]('pointerup', swiper.onTouchEnd, {\n\t\t\tpassive: true\n\t\t});\n\t\tdocument[domMethod]('pointercancel', swiper.onTouchEnd, {\n\t\t\tpassive: true\n\t\t});\n\t\tdocument[domMethod]('pointerout', swiper.onTouchEnd, {\n\t\t\tpassive: true\n\t\t});\n\t\tdocument[domMethod]('pointerleave', swiper.onTouchEnd, {\n\t\t\tpassive: true\n\t\t});\n\t\tdocument[domMethod]('contextmenu', swiper.onTouchEnd, {\n\t\t\tpassive: true\n\t\t});\n\n\t\t// Prevent Links Clicks\n\t\tif (params.preventClicks || params.preventClicksPropagation) {\n\t\t\tel[domMethod]('click', swiper.onClick, true);\n\t\t}\n\t\tif (params.cssMode) {\n\t\t\twrapperEl[domMethod]('scroll', swiper.onScroll);\n\t\t}\n\n\t\t// Resize handler\n\t\tif (params.updateOnWindowResize) {\n\t\t\tswiper[swiperMethod](device.ios || device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate', onResize, true);\n\t\t} else {\n\t\t\tswiper[swiperMethod]('observerUpdate', onResize, true);\n\t\t}\n\n\t\t// Images loader\n\t\tel[domMethod]('load', swiper.onLoad, {\n\t\t\tcapture: true\n\t\t});\n\t};\n\tfunction attachEvents() {\n\t\tconst swiper = this;\n\t\tconst document = getDocument();\n\t\tconst {\n\t\t\tparams\n\t\t} = swiper;\n\t\tswiper.onTouchStart = onTouchStart.bind(swiper);\n\t\tswiper.onTouchMove = onTouchMove.bind(swiper);\n\t\tswiper.onTouchEnd = onTouchEnd.bind(swiper);\n\t\tif (params.cssMode) {\n\t\t\tswiper.onScroll = onScroll.bind(swiper);\n\t\t}\n\t\tswiper.onClick = onClick.bind(swiper);\n\t\tswiper.onLoad = onLoad.bind(swiper);\n\t\tif (!dummyEventAttached) {\n\t\t\tdocument.addEventListener('touchstart', dummyEventListener);\n\t\t\tdummyEventAttached = true;\n\t\t}\n\t\tevents(swiper, 'on');\n\t}\n\tfunction detachEvents() {\n\t\tconst swiper = this;\n\t\tevents(swiper, 'off');\n\t}\n\tvar events$1 = {\n\t\tattachEvents,\n\t\tdetachEvents\n\t};\n\n\tconst isGridEnabled = (swiper, params) => {\n\t\treturn swiper.grid && params.grid && params.grid.rows > 1;\n\t};\n\tfunction setBreakpoint() {\n\t\tconst swiper = this;\n\t\tconst {\n\t\t\trealIndex,\n\t\t\tinitialized,\n\t\t\tparams,\n\t\t\tel\n\t\t} = swiper;\n\t\tconst breakpoints = params.breakpoints;\n\t\tif (!breakpoints || breakpoints && Object.keys(breakpoints).length === 0) return;\n\n\t\t// Get breakpoint for window width and update parameters\n\t\tconst breakpoint = swiper.getBreakpoint(breakpoints, swiper.params.breakpointsBase, swiper.el);\n\t\tif (!breakpoint || swiper.currentBreakpoint === breakpoint) return;\n\t\tconst breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : undefined;\n\t\tconst breakpointParams = breakpointOnlyParams || swiper.originalParams;\n\t\tconst wasMultiRow = isGridEnabled(swiper, params);\n\t\tconst isMultiRow = isGridEnabled(swiper, breakpointParams);\n\t\tconst wasEnabled = params.enabled;\n\t\tif (wasMultiRow && !isMultiRow) {\n\t\t\tel.classList.remove(`${params.containerModifierClass}grid`, `${params.containerModifierClass}grid-column`);\n\t\t\tswiper.emitContainerClasses();\n\t\t} else if (!wasMultiRow && isMultiRow) {\n\t\t\tel.classList.add(`${params.containerModifierClass}grid`);\n\t\t\tif (breakpointParams.grid.fill && breakpointParams.grid.fill === 'column' || !breakpointParams.grid.fill && params.grid.fill === 'column') {\n\t\t\t\tel.classList.add(`${params.containerModifierClass}grid-column`);\n\t\t\t}\n\t\t\tswiper.emitContainerClasses();\n\t\t}\n\n\t\t// Toggle navigation, pagination, scrollbar\n\t\t['navigation', 'pagination', 'scrollbar'].forEach(prop => {\n\t\t\tif (typeof breakpointParams[prop] === 'undefined') return;\n\t\t\tconst wasModuleEnabled = params[prop] && params[prop].enabled;\n\t\t\tconst isModuleEnabled = breakpointParams[prop] && breakpointParams[prop].enabled;\n\t\t\tif (wasModuleEnabled && !isModuleEnabled) {\n\t\t\t\tswiper[prop].disable();\n\t\t\t}\n\t\t\tif (!wasModuleEnabled && isModuleEnabled) {\n\t\t\t\tswiper[prop].enable();\n\t\t\t}\n\t\t});\n\t\tconst directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;\n\t\tconst needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);\n\t\tif (directionChanged && initialized) {\n\t\t\tswiper.changeDirection();\n\t\t}\n\t\textend(swiper.params, breakpointParams);\n\t\tconst isEnabled = swiper.params.enabled;\n\t\tObject.assign(swiper, {\n\t\t\tallowTouchMove: swiper.params.allowTouchMove,\n\t\t\tallowSlideNext: swiper.params.allowSlideNext,\n\t\t\tallowSlidePrev: swiper.params.allowSlidePrev\n\t\t});\n\t\tif (wasEnabled && !isEnabled) {\n\t\t\tswiper.disable();\n\t\t} else if (!wasEnabled && isEnabled) {\n\t\t\tswiper.enable();\n\t\t}\n\t\tswiper.currentBreakpoint = breakpoint;\n\t\tswiper.emit('_beforeBreakpoint', breakpointParams);\n\t\tif (needsReLoop && initialized) {\n\t\t\tswiper.loopDestroy();\n\t\t\tswiper.loopCreate(realIndex);\n\t\t\tswiper.updateSlides();\n\t\t}\n\t\tswiper.emit('breakpoint', breakpointParams);\n\t}\n\n\tfunction getBreakpoint(breakpoints, base, containerEl) {\n\t\tif (base === void 0) {\n\t\t\tbase = 'window';\n\t\t}\n\t\tif (!breakpoints || base === 'container' && !containerEl) return undefined;\n\t\tlet breakpoint = false;\n\t\tconst window = getWindow();\n\t\tconst currentHeight = base === 'window' ? window.innerHeight : containerEl.clientHeight;\n\t\tconst points = Object.keys(breakpoints).map(point => {\n\t\t\tif (typeof point === 'string' && point.indexOf('@') === 0) {\n\t\t\t\tconst minRatio = parseFloat(point.substr(1));\n\t\t\t\tconst value = currentHeight * minRatio;\n\t\t\t\treturn {\n\t\t\t\t\tvalue,\n\t\t\t\t\tpoint\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tvalue: point,\n\t\t\t\tpoint\n\t\t\t};\n\t\t});\n\t\tpoints.sort((a, b) => parseInt(a.value, 10) - parseInt(b.value, 10));\n\t\tfor (let i = 0; i < points.length; i += 1) {\n\t\t\tconst {\n\t\t\t\tpoint,\n\t\t\t\tvalue\n\t\t\t} = points[i];\n\t\t\tif (base === 'window') {\n\t\t\t\tif (window.matchMedia(`(min-width: ${value}px)`).matches) {\n\t\t\t\t\tbreakpoint = point;\n\t\t\t\t}\n\t\t\t} else if (value <= containerEl.clientWidth) {\n\t\t\t\tbreakpoint = point;\n\t\t\t}\n\t\t}\n\t\treturn breakpoint || 'max';\n\t}\n\n\tvar breakpoints = {\n\t\tsetBreakpoint,\n\t\tgetBreakpoint\n\t};\n\n\tfunction prepareClasses(entries, prefix) {\n\t\tconst resultClasses = [];\n\t\tentries.forEach(item => {\n\t\t\tif (typeof item === 'object') {\n\t\t\t\tObject.keys(item).forEach(classNames => {\n\t\t\t\t\tif (item[classNames]) {\n\t\t\t\t\t\tresultClasses.push(prefix + classNames);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else if (typeof item === 'string') {\n\t\t\t\tresultClasses.push(prefix + item);\n\t\t\t}\n\t\t});\n\t\treturn resultClasses;\n\t}\n\tfunction addClasses() {\n\t\tconst swiper = this;\n\t\tconst {\n\t\t\tclassNames,\n\t\t\tparams,\n\t\t\trtl,\n\t\t\tel,\n\t\t\tdevice\n\t\t} = swiper;\n\t\t// prettier-ignore\n\t\tconst suffixes = prepareClasses(['initialized', params.direction, {\n\t\t\t'free-mode': swiper.params.freeMode && params.freeMode.enabled\n\t\t}, {\n\t\t\t\t'autoheight': params.autoHeight\n\t\t\t}, {\n\t\t\t\t'rtl': rtl\n\t\t\t}, {\n\t\t\t\t'grid': params.grid && params.grid.rows > 1\n\t\t\t}, {\n\t\t\t\t'grid-column': params.grid && params.grid.rows > 1 && params.grid.fill === 'column'\n\t\t\t}, {\n\t\t\t\t'android': device.android\n\t\t\t}, {\n\t\t\t\t'ios': device.ios\n\t\t\t}, {\n\t\t\t\t'css-mode': params.cssMode\n\t\t\t}, {\n\t\t\t\t'centered': params.cssMode && params.centeredSlides\n\t\t\t}, {\n\t\t\t\t'watch-progress': params.watchSlidesProgress\n\t\t\t}], params.containerModifierClass);\n\t\tclassNames.push(...suffixes);\n\t\tel.classList.add(...classNames);\n\t\tswiper.emitContainerClasses();\n\t}\n\n\tfunction removeClasses() {\n\t\tconst swiper = this;\n\t\tconst {\n\t\t\tel,\n\t\t\tclassNames\n\t\t} = swiper;\n\t\tel.classList.remove(...classNames);\n\t\tswiper.emitContainerClasses();\n\t}\n\n\tvar classes = {\n\t\taddClasses,\n\t\tremoveClasses\n\t};\n\n\tfunction checkOverflow() {\n\t\tconst swiper = this;\n\t\tconst {\n\t\t\tisLocked: wasLocked,\n\t\t\tparams\n\t\t} = swiper;\n\t\tconst {\n\t\t\tslidesOffsetBefore\n\t\t} = params;\n\t\tif (slidesOffsetBefore) {\n\t\t\tconst lastSlideIndex = swiper.slides.length - 1;\n\t\t\tconst lastSlideRightEdge = swiper.slidesGrid[lastSlideIndex] + swiper.slidesSizesGrid[lastSlideIndex] + slidesOffsetBefore * 2;\n\t\t\tswiper.isLocked = swiper.size > lastSlideRightEdge;\n\t\t} else {\n\t\t\tswiper.isLocked = swiper.snapGrid.length === 1;\n\t\t}\n\t\tif (params.allowSlideNext === true) {\n\t\t\tswiper.allowSlideNext = !swiper.isLocked;\n\t\t}\n\t\tif (params.allowSlidePrev === true) {\n\t\t\tswiper.allowSlidePrev = !swiper.isLocked;\n\t\t}\n\t\tif (wasLocked && wasLocked !== swiper.isLocked) {\n\t\t\tswiper.isEnd = false;\n\t\t}\n\t\tif (wasLocked !== swiper.isLocked) {\n\t\t\tswiper.emit(swiper.isLocked ? 'lock' : 'unlock');\n\t\t}\n\t}\n\tvar checkOverflow$1 = {\n\t\tcheckOverflow\n\t};\n\n\tvar defaults = {\n\t\tinit: true,\n\t\tdirection: 'horizontal',\n\t\toneWayMovement: false,\n\t\ttouchEventsTarget: 'wrapper',\n\t\tinitialSlide: 0,\n\t\tspeed: 300,\n\t\tcssMode: false,\n\t\tupdateOnWindowResize: true,\n\t\tresizeObserver: true,\n\t\tnested: false,\n\t\tcreateElements: false,\n\t\tenabled: true,\n\t\tfocusableElements: 'input, select, option, textarea, button, video, label',\n\t\t// Overrides\n\t\twidth: null,\n\t\theight: null,\n\t\t//\n\t\tpreventInteractionOnTransition: false,\n\t\t// ssr\n\t\tuserAgent: null,\n\t\turl: null,\n\t\t// To support iOS's swipe-to-go-back gesture (when being used in-app).\n\t\tedgeSwipeDetection: false,\n\t\tedgeSwipeThreshold: 20,\n\t\t// Autoheight\n\t\tautoHeight: false,\n\t\t// Set wrapper width\n\t\tsetWrapperSize: false,\n\t\t// Virtual Translate\n\t\tvirtualTranslate: false,\n\t\t// Effects\n\t\teffect: 'slide',\n\t\t// 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'\n\n\t\t// Breakpoints\n\t\tbreakpoints: undefined,\n\t\tbreakpointsBase: 'window',\n\t\t// Slides grid\n\t\tspaceBetween: 0,\n\t\tslidesPerView: 1,\n\t\tslidesPerGroup: 1,\n\t\tslidesPerGroupSkip: 0,\n\t\tslidesPerGroupAuto: false,\n\t\tcenteredSlides: false,\n\t\tcenteredSlidesBounds: false,\n\t\tslidesOffsetBefore: 0,\n\t\t// in px\n\t\tslidesOffsetAfter: 0,\n\t\t// in px\n\t\tnormalizeSlideIndex: true,\n\t\tcenterInsufficientSlides: false,\n\t\t// Disable swiper and hide navigation when container not overflow\n\t\twatchOverflow: true,\n\t\t// Round length\n\t\troundLengths: false,\n\t\t// Touches\n\t\ttouchRatio: 1,\n\t\ttouchAngle: 45,\n\t\tsimulateTouch: true,\n\t\tshortSwipes: true,\n\t\tlongSwipes: true,\n\t\tlongSwipesRatio: 0.5,\n\t\tlongSwipesMs: 300,\n\t\tfollowFinger: true,\n\t\tallowTouchMove: true,\n\t\tthreshold: 5,\n\t\ttouchMoveStopPropagation: false,\n\t\ttouchStartPreventDefault: true,\n\t\ttouchStartForcePreventDefault: false,\n\t\ttouchReleaseOnEdges: false,\n\t\t// Unique Navigation Elements\n\t\tuniqueNavElements: true,\n\t\t// Resistance\n\t\tresistance: true,\n\t\tresistanceRatio: 0.85,\n\t\t// Progress\n\t\twatchSlidesProgress: false,\n\t\t// Cursor\n\t\tgrabCursor: false,\n\t\t// Clicks\n\t\tpreventClicks: true,\n\t\tpreventClicksPropagation: true,\n\t\tslideToClickedSlide: false,\n\t\t// loop\n\t\tloop: false,\n\t\tloopedSlides: null,\n\t\tloopPreventsSliding: true,\n\t\t// rewind\n\t\trewind: false,\n\t\t// Swiping/no swiping\n\t\tallowSlidePrev: true,\n\t\tallowSlideNext: true,\n\t\tswipeHandler: null,\n\t\t// '.swipe-handler',\n\t\tnoSwiping: true,\n\t\tnoSwipingClass: 'swiper-no-swiping',\n\t\tnoSwipingSelector: null,\n\t\t// Passive Listeners\n\t\tpassiveListeners: true,\n\t\tmaxBackfaceHiddenSlides: 10,\n\t\t// NS\n\t\tcontainerModifierClass: 'swiper-',\n\t\t// NEW\n\t\tslideClass: 'swiper-slide',\n\t\tslideActiveClass: 'swiper-slide-active',\n\t\tslideVisibleClass: 'swiper-slide-visible',\n\t\tslideNextClass: 'swiper-slide-next',\n\t\tslidePrevClass: 'swiper-slide-prev',\n\t\twrapperClass: 'swiper-wrapper',\n\t\tlazyPreloaderClass: 'swiper-lazy-preloader',\n\t\tlazyPreloadPrevNext: 0,\n\t\t// Callbacks\n\t\trunCallbacksOnInit: true,\n\t\t// Internals\n\t\t_emitClasses: false\n\t};\n\n\tfunction moduleExtendParams(params, allModulesParams) {\n\t\treturn function extendParams(obj) {\n\t\t\tif (obj === void 0) {\n\t\t\t\tobj = {};\n\t\t\t}\n\t\t\tconst moduleParamName = Object.keys(obj)[0];\n\t\t\tconst moduleParams = obj[moduleParamName];\n\t\t\tif (typeof moduleParams !== 'object' || moduleParams === null) {\n\t\t\t\textend(allModulesParams, obj);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (['navigation', 'pagination', 'scrollbar'].indexOf(moduleParamName) >= 0 && params[moduleParamName] === true) {\n\t\t\t\tparams[moduleParamName] = {\n\t\t\t\t\tauto: true\n\t\t\t\t};\n\t\t\t}\n\t\t\tif (!(moduleParamName in params && 'enabled' in moduleParams)) {\n\t\t\t\textend(allModulesParams, obj);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (params[moduleParamName] === true) {\n\t\t\t\tparams[moduleParamName] = {\n\t\t\t\t\tenabled: true\n\t\t\t\t};\n\t\t\t}\n\t\t\tif (typeof params[moduleParamName] === 'object' && !('enabled' in params[moduleParamName])) {\n\t\t\t\tparams[moduleParamName].enabled = true;\n\t\t\t}\n\t\t\tif (!params[moduleParamName]) params[moduleParamName] = {\n\t\t\t\tenabled: false\n\t\t\t};\n\t\t\textend(allModulesParams, obj);\n\t\t};\n\t}\n\n\t/* eslint no-param-reassign: \"off\" */\n\tconst prototypes = {\n\t\teventsEmitter,\n\t\tupdate,\n\t\ttranslate,\n\t\ttransition,\n\t\tslide,\n\t\tloop,\n\t\tgrabCursor,\n\t\tevents: events$1,\n\t\tbreakpoints,\n\t\tcheckOverflow: checkOverflow$1,\n\t\tclasses\n\t};\n\tconst extendedDefaults = {};\n\tclass Swiper {\n\t\tconstructor() {\n\t\t\tlet el;\n\t\t\tlet params;\n\t\t\tfor (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n\t\t\t\targs[_key] = arguments[_key];\n\t\t\t}\n\t\t\tif (args.length === 1 && args[0].constructor && Object.prototype.toString.call(args[0]).slice(8, -1) === 'Object') {\n\t\t\t\tparams = args[0];\n\t\t\t} else {\n\t\t\t\t[el, params] = args;\n\t\t\t}\n\t\t\tif (!params) params = {};\n\t\t\tparams = extend({}, params);\n\t\t\tif (el && !params.el) params.el = el;\n\t\t\tconst document = getDocument();\n\t\t\tif (params.el && typeof params.el === 'string' && document.querySelectorAll(params.el).length > 1) {\n\t\t\t\tconst swipers = [];\n\t\t\t\tdocument.querySelectorAll(params.el).forEach(containerEl => {\n\t\t\t\t\tconst newParams = extend({}, params, {\n\t\t\t\t\t\tel: containerEl\n\t\t\t\t\t});\n\t\t\t\t\tswipers.push(new Swiper(newParams));\n\t\t\t\t});\n\t\t\t\t// eslint-disable-next-line no-constructor-return\n\t\t\t\treturn swipers;\n\t\t\t}\n\n\t\t\t// Swiper Instance\n\t\t\tconst swiper = this;\n\t\t\tswiper.__swiper__ = true;\n\t\t\tswiper.support = getSupport();\n\t\t\tswiper.device = getDevice({\n\t\t\t\tuserAgent: params.userAgent\n\t\t\t});\n\t\t\tswiper.browser = getBrowser();\n\t\t\tswiper.eventsListeners = {};\n\t\t\tswiper.eventsAnyListeners = [];\n\t\t\tswiper.modules = [...swiper.__modules__];\n\t\t\tif (params.modules && Array.isArray(params.modules)) {\n\t\t\t\tswiper.modules.push(...params.modules);\n\t\t\t}\n\t\t\tconst allModulesParams = {};\n\t\t\tswiper.modules.forEach(mod => {\n\t\t\t\tmod({\n\t\t\t\t\tparams,\n\t\t\t\t\tswiper,\n\t\t\t\t\textendParams: moduleExtendParams(params, allModulesParams),\n\t\t\t\t\ton: swiper.on.bind(swiper),\n\t\t\t\t\tonce: swiper.once.bind(swiper),\n\t\t\t\t\toff: swiper.off.bind(swiper),\n\t\t\t\t\temit: swiper.emit.bind(swiper)\n\t\t\t\t});\n\t\t\t});\n\n\t\t\t// Extend defaults with modules params\n\t\t\tconst swiperParams = extend({}, defaults, allModulesParams);\n\n\t\t\t// Extend defaults with passed params\n\t\t\tswiper.params = extend({}, swiperParams, extendedDefaults, params);\n\t\t\tswiper.originalParams = extend({}, swiper.params);\n\t\t\tswiper.passedParams = extend({}, params);\n\n\t\t\t// add event listeners\n\t\t\tif (swiper.params && swiper.params.on) {\n\t\t\t\tObject.keys(swiper.params.on).forEach(eventName => {\n\t\t\t\t\tswiper.on(eventName, swiper.params.on[eventName]);\n\t\t\t\t});\n\t\t\t}\n\t\t\tif (swiper.params && swiper.params.onAny) {\n\t\t\t\tswiper.onAny(swiper.params.onAny);\n\t\t\t}\n\n\t\t\t// Extend Swiper\n\t\t\tObject.assign(swiper, {\n\t\t\t\tenabled: swiper.params.enabled,\n\t\t\t\tel,\n\t\t\t\t// Classes\n\t\t\t\tclassNames: [],\n\t\t\t\t// Slides\n\t\t\t\tslides: [],\n\t\t\t\tslidesGrid: [],\n\t\t\t\tsnapGrid: [],\n\t\t\t\tslidesSizesGrid: [],\n\t\t\t\t// isDirection\n\t\t\t\tisHorizontal() {\n\t\t\t\t\treturn swiper.params.direction === 'horizontal';\n\t\t\t\t},\n\t\t\t\tisVertical() {\n\t\t\t\t\treturn swiper.params.direction === 'vertical';\n\t\t\t\t},\n\t\t\t\t// Indexes\n\t\t\t\tactiveIndex: 0,\n\t\t\t\trealIndex: 0,\n\t\t\t\t//\n\t\t\t\tisBeginning: true,\n\t\t\t\tisEnd: false,\n\t\t\t\t// Props\n\t\t\t\ttranslate: 0,\n\t\t\t\tpreviousTranslate: 0,\n\t\t\t\tprogress: 0,\n\t\t\t\tvelocity: 0,\n\t\t\t\tanimating: false,\n\t\t\t\tcssOverflowAdjustment() {\n\t\t\t\t\t// Returns 0 unless `translate` is > 2**23\n\t\t\t\t\t// Should be subtracted from css values to prevent overflow\n\t\t\t\t\treturn Math.trunc(this.translate / 2 ** 23) * 2 ** 23;\n\t\t\t\t},\n\t\t\t\t// Locks\n\t\t\t\tallowSlideNext: swiper.params.allowSlideNext,\n\t\t\t\tallowSlidePrev: swiper.params.allowSlidePrev,\n\t\t\t\t// Touch Events\n\t\t\t\ttouchEventsData: {\n\t\t\t\t\tisTouched: undefined,\n\t\t\t\t\tisMoved: undefined,\n\t\t\t\t\tallowTouchCallbacks: undefined,\n\t\t\t\t\ttouchStartTime: undefined,\n\t\t\t\t\tisScrolling: undefined,\n\t\t\t\t\tcurrentTranslate: undefined,\n\t\t\t\t\tstartTranslate: undefined,\n\t\t\t\t\tallowThresholdMove: undefined,\n\t\t\t\t\t// Form elements to match\n\t\t\t\t\tfocusableElements: swiper.params.focusableElements,\n\t\t\t\t\t// Last click time\n\t\t\t\t\tlastClickTime: 0,\n\t\t\t\t\tclickTimeout: undefined,\n\t\t\t\t\t// Velocities\n\t\t\t\t\tvelocities: [],\n\t\t\t\t\tallowMomentumBounce: undefined,\n\t\t\t\t\tstartMoving: undefined,\n\t\t\t\t\tevCache: []\n\t\t\t\t},\n\t\t\t\t// Clicks\n\t\t\t\tallowClick: true,\n\t\t\t\t// Touches\n\t\t\t\tallowTouchMove: swiper.params.allowTouchMove,\n\t\t\t\ttouches: {\n\t\t\t\t\tstartX: 0,\n\t\t\t\t\tstartY: 0,\n\t\t\t\t\tcurrentX: 0,\n\t\t\t\t\tcurrentY: 0,\n\t\t\t\t\tdiff: 0\n\t\t\t\t},\n\t\t\t\t// Images\n\t\t\t\timagesToLoad: [],\n\t\t\t\timagesLoaded: 0\n\t\t\t});\n\t\t\tswiper.emit('_swiper');\n\n\t\t\t// Init\n\t\t\tif (swiper.params.init) {\n\t\t\t\tswiper.init();\n\t\t\t}\n\n\t\t\t// Return app instance\n\t\t\t// eslint-disable-next-line no-constructor-return\n\t\t\treturn swiper;\n\t\t}\n\t\tgetSlideIndex(slideEl) {\n\t\t\tconst {\n\t\t\t\tslidesEl,\n\t\t\t\tparams\n\t\t\t} = this;\n\t\t\tconst slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);\n\t\t\tconst firstSlideIndex = elementIndex(slides[0]);\n\t\t\treturn elementIndex(slideEl) - firstSlideIndex;\n\t\t}\n\t\tgetSlideIndexByData(index) {\n\t\t\treturn this.getSlideIndex(this.slides.filter(slideEl => slideEl.getAttribute('data-swiper-slide-index') * 1 === index)[0]);\n\t\t}\n\t\trecalcSlides() {\n\t\t\tconst swiper = this;\n\t\t\tconst {\n\t\t\t\tslidesEl,\n\t\t\t\tparams\n\t\t\t} = swiper;\n\t\t\tswiper.slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);\n\t\t}\n\t\tenable() {\n\t\t\tconst swiper = this;\n\t\t\tif (swiper.enabled) return;\n\t\t\tswiper.enabled = true;\n\t\t\tif (swiper.params.grabCursor) {\n\t\t\t\tswiper.setGrabCursor();\n\t\t\t}\n\t\t\tswiper.emit('enable');\n\t\t}\n\t\tdisable() {\n\t\t\tconst swiper = this;\n\t\t\tif (!swiper.enabled) return;\n\t\t\tswiper.enabled = false;\n\t\t\tif (swiper.params.grabCursor) {\n\t\t\t\tswiper.unsetGrabCursor();\n\t\t\t}\n\t\t\tswiper.emit('disable');\n\t\t}\n\t\tsetProgress(progress, speed) {\n\t\t\tconst swiper = this;\n\t\t\tprogress = Math.min(Math.max(progress, 0), 1);\n\t\t\tconst min = swiper.minTranslate();\n\t\t\tconst max = swiper.maxTranslate();\n\t\t\tconst current = (max - min) * progress + min;\n\t\t\tswiper.translateTo(current, typeof speed === 'undefined' ? 0 : speed);\n\t\t\tswiper.updateActiveIndex();\n\t\t\tswiper.updateSlidesClasses();\n\t\t}\n\t\temitContainerClasses() {\n\t\t\tconst swiper = this;\n\t\t\tif (!swiper.params._emitClasses || !swiper.el) return;\n\t\t\tconst cls = swiper.el.className.split(' ').filter(className => {\n\t\t\t\treturn className.indexOf('swiper') === 0 || className.indexOf(swiper.params.containerModifierClass) === 0;\n\t\t\t});\n\t\t\tswiper.emit('_containerClasses', cls.join(' '));\n\t\t}\n\t\tgetSlideClasses(slideEl) {\n\t\t\tconst swiper = this;\n\t\t\tif (swiper.destroyed) return '';\n\t\t\treturn slideEl.className.split(' ').filter(className => {\n\t\t\t\treturn className.indexOf('swiper-slide') === 0 || className.indexOf(swiper.params.slideClass) === 0;\n\t\t\t}).join(' ');\n\t\t}\n\t\temitSlidesClasses() {\n\t\t\tconst swiper = this;\n\t\t\tif (!swiper.params._emitClasses || !swiper.el) return;\n\t\t\tconst updates = [];\n\t\t\tswiper.slides.forEach(slideEl => {\n\t\t\t\tconst classNames = swiper.getSlideClasses(slideEl);\n\t\t\t\tupdates.push({\n\t\t\t\t\tslideEl,\n\t\t\t\t\tclassNames\n\t\t\t\t});\n\t\t\t\tswiper.emit('_slideClass', slideEl, classNames);\n\t\t\t});\n\t\t\tswiper.emit('_slideClasses', updates);\n\t\t}\n\t\tslidesPerViewDynamic(view, exact) {\n\t\t\tif (view === void 0) {\n\t\t\t\tview = 'current';\n\t\t\t}\n\t\t\tif (exact === void 0) {\n\t\t\t\texact = false;\n\t\t\t}\n\t\t\tconst swiper = this;\n\t\t\tconst {\n\t\t\t\tparams,\n\t\t\t\tslides,\n\t\t\t\tslidesGrid,\n\t\t\t\tslidesSizesGrid,\n\t\t\t\tsize: swiperSize,\n\t\t\t\tactiveIndex\n\t\t\t} = swiper;\n\t\t\tlet spv = 1;\n\t\t\tif (params.centeredSlides) {\n\t\t\t\tlet slideSize = slides[activeIndex] ? slides[activeIndex].swiperSlideSize : 0;\n\t\t\t\tlet breakLoop;\n\t\t\t\tfor (let i = activeIndex + 1; i < slides.length; i += 1) {\n\t\t\t\t\tif (slides[i] && !breakLoop) {\n\t\t\t\t\t\tslideSize += slides[i].swiperSlideSize;\n\t\t\t\t\t\tspv += 1;\n\t\t\t\t\t\tif (slideSize > swiperSize) breakLoop = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (let i = activeIndex - 1; i >= 0; i -= 1) {\n\t\t\t\t\tif (slides[i] && !breakLoop) {\n\t\t\t\t\t\tslideSize += slides[i].swiperSlideSize;\n\t\t\t\t\t\tspv += 1;\n\t\t\t\t\t\tif (slideSize > swiperSize) breakLoop = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// eslint-disable-next-line\n\t\t\t\tif (view === 'current') {\n\t\t\t\t\tfor (let i = activeIndex + 1; i < slides.length; i += 1) {\n\t\t\t\t\t\tconst slideInView = exact ? slidesGrid[i] + slidesSizesGrid[i] - slidesGrid[activeIndex] < swiperSize : slidesGrid[i] - slidesGrid[activeIndex] < swiperSize;\n\t\t\t\t\t\tif (slideInView) {\n\t\t\t\t\t\t\tspv += 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// previous\n\t\t\t\t\tfor (let i = activeIndex - 1; i >= 0; i -= 1) {\n\t\t\t\t\t\tconst slideInView = slidesGrid[activeIndex] - slidesGrid[i] < swiperSize;\n\t\t\t\t\t\tif (slideInView) {\n\t\t\t\t\t\t\tspv += 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn spv;\n\t\t}\n\t\tupdate() {\n\t\t\tconst swiper = this;\n\t\t\tif (!swiper || swiper.destroyed) return;\n\t\t\tconst {\n\t\t\t\tsnapGrid,\n\t\t\t\tparams\n\t\t\t} = swiper;\n\t\t\t// Breakpoints\n\t\t\tif (params.breakpoints) {\n\t\t\t\tswiper.setBreakpoint();\n\t\t\t}\n\t\t\t[...swiper.el.querySelectorAll('[loading=\"lazy\"]')].forEach(imageEl => {\n\t\t\t\tif (imageEl.complete) {\n\t\t\t\t\tprocessLazyPreloader(swiper, imageEl);\n\t\t\t\t}\n\t\t\t});\n\t\t\tswiper.updateSize();\n\t\t\tswiper.updateSlides();\n\t\t\tswiper.updateProgress();\n\t\t\tswiper.updateSlidesClasses();\n\t\t\tfunction setTranslate() {\n\t\t\t\tconst translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;\n\t\t\t\tconst newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());\n\t\t\t\tswiper.setTranslate(newTranslate);\n\t\t\t\tswiper.updateActiveIndex();\n\t\t\t\tswiper.updateSlidesClasses();\n\t\t\t}\n\t\t\tlet translated;\n\t\t\tif (params.freeMode && params.freeMode.enabled && !params.cssMode) {\n\t\t\t\tsetTranslate();\n\t\t\t\tif (params.autoHeight) {\n\t\t\t\t\tswiper.updateAutoHeight();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !params.centeredSlides) {\n\t\t\t\t\tconst slides = swiper.virtual && params.virtual.enabled ? swiper.virtual.slides : swiper.slides;\n\t\t\t\t\ttranslated = swiper.slideTo(slides.length - 1, 0, false, true);\n\t\t\t\t} else {\n\t\t\t\t\ttranslated = swiper.slideTo(swiper.activeIndex, 0, false, true);\n\t\t\t\t}\n\t\t\t\tif (!translated) {\n\t\t\t\t\tsetTranslate();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (params.watchOverflow && snapGrid !== swiper.snapGrid) {\n\t\t\t\tswiper.checkOverflow();\n\t\t\t}\n\t\t\tswiper.emit('update');\n\t\t}\n\t\tchangeDirection(newDirection, needUpdate) {\n\t\t\tif (needUpdate === void 0) {\n\t\t\t\tneedUpdate = true;\n\t\t\t}\n\t\t\tconst swiper = this;\n\t\t\tconst currentDirection = swiper.params.direction;\n\t\t\tif (!newDirection) {\n\t\t\t\t// eslint-disable-next-line\n\t\t\t\tnewDirection = currentDirection === 'horizontal' ? 'vertical' : 'horizontal';\n\t\t\t}\n\t\t\tif (newDirection === currentDirection || newDirection !== 'horizontal' && newDirection !== 'vertical') {\n\t\t\t\treturn swiper;\n\t\t\t}\n\t\t\tswiper.el.classList.remove(`${swiper.params.containerModifierClass}${currentDirection}`);\n\t\t\tswiper.el.classList.add(`${swiper.params.containerModifierClass}${newDirection}`);\n\t\t\tswiper.emitContainerClasses();\n\t\t\tswiper.params.direction = newDirection;\n\t\t\tswiper.slides.forEach(slideEl => {\n\t\t\t\tif (newDirection === 'vertical') {\n\t\t\t\t\tslideEl.style.width = '';\n\t\t\t\t} else {\n\t\t\t\t\tslideEl.style.height = '';\n\t\t\t\t}\n\t\t\t});\n\t\t\tswiper.emit('changeDirection');\n\t\t\tif (needUpdate) swiper.update();\n\t\t\treturn swiper;\n\t\t}\n\t\tchangeLanguageDirection(direction) {\n\t\t\tconst swiper = this;\n\t\t\tif (swiper.rtl && direction === 'rtl' || !swiper.rtl && direction === 'ltr') return;\n\t\t\tswiper.rtl = direction === 'rtl';\n\t\t\tswiper.rtlTranslate = swiper.params.direction === 'horizontal' && swiper.rtl;\n\t\t\tif (swiper.rtl) {\n\t\t\t\tswiper.el.classList.add(`${swiper.params.containerModifierClass}rtl`);\n\t\t\t\tswiper.el.dir = 'rtl';\n\t\t\t} else {\n\t\t\t\tswiper.el.classList.remove(`${swiper.params.containerModifierClass}rtl`);\n\t\t\t\tswiper.el.dir = 'ltr';\n\t\t\t}\n\t\t\tswiper.update();\n\t\t}\n\t\tmount(element) {\n\t\t\tconst swiper = this;\n\t\t\tif (swiper.mounted) return true;\n\n\t\t\t// Find el\n\t\t\tlet el = element || swiper.params.el;\n\t\t\tif (typeof el === 'string') {\n\t\t\t\tel = document.querySelector(el);\n\t\t\t}\n\t\t\tif (!el) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tel.swiper = swiper;\n\t\t\tif (el.parentNode && el.parentNode.host && el.parentNode.host.nodeName === 'SWIPER-CONTAINER') {\n\t\t\t\tswiper.isElement = true;\n\t\t\t}\n\t\t\tconst getWrapperSelector = () => {\n\t\t\t\treturn `.${(swiper.params.wrapperClass || '').trim().split(' ').join('.')}`;\n\t\t\t};\n\t\t\tconst getWrapper = () => {\n\t\t\t\tif (el && el.shadowRoot && el.shadowRoot.querySelector) {\n\t\t\t\t\tconst res = el.shadowRoot.querySelector(getWrapperSelector());\n\t\t\t\t\t// Children needs to return slot items\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t\treturn elementChildren(el, getWrapperSelector())[0];\n\t\t\t};\n\t\t\t// Find Wrapper\n\t\t\tlet wrapperEl = getWrapper();\n\t\t\tif (!wrapperEl && swiper.params.createElements) {\n\t\t\t\twrapperEl = createElement('div', swiper.params.wrapperClass);\n\t\t\t\tel.append(wrapperEl);\n\t\t\t\telementChildren(el, `.${swiper.params.slideClass}`).forEach(slideEl => {\n\t\t\t\t\twrapperEl.append(slideEl);\n\t\t\t\t});\n\t\t\t}\n\t\t\tObject.assign(swiper, {\n\t\t\t\tel,\n\t\t\t\twrapperEl,\n\t\t\t\tslidesEl: swiper.isElement && !el.parentNode.host.slideSlots ? el.parentNode.host : wrapperEl,\n\t\t\t\thostEl: swiper.isElement ? el.parentNode.host : el,\n\t\t\t\tmounted: true,\n\t\t\t\t// RTL\n\t\t\t\trtl: el.dir.toLowerCase() === 'rtl' || elementStyle(el, 'direction') === 'rtl',\n\t\t\t\trtlTranslate: swiper.params.direction === 'horizontal' && (el.dir.toLowerCase() === 'rtl' || elementStyle(el, 'direction') === 'rtl'),\n\t\t\t\twrongRTL: elementStyle(wrapperEl, 'display') === '-webkit-box'\n\t\t\t});\n\t\t\treturn true;\n\t\t}\n\t\tinit(el) {\n\t\t\tconst swiper = this;\n\t\t\tif (swiper.initialized) return swiper;\n\t\t\tconst mounted = swiper.mount(el);\n\t\t\tif (mounted === false) return swiper;\n\t\t\tswiper.emit('beforeInit');\n\n\t\t\t// Set breakpoint\n\t\t\tif (swiper.params.breakpoints) {\n\t\t\t\tswiper.setBreakpoint();\n\t\t\t}\n\n\t\t\t// Add Classes\n\t\t\tswiper.addClasses();\n\n\t\t\t// Update size\n\t\t\tswiper.updateSize();\n\n\t\t\t// Update slides\n\t\t\tswiper.updateSlides();\n\t\t\tif (swiper.params.watchOverflow) {\n\t\t\t\tswiper.checkOverflow();\n\t\t\t}\n\n\t\t\t// Set Grab Cursor\n\t\t\tif (swiper.params.grabCursor && swiper.enabled) {\n\t\t\t\tswiper.setGrabCursor();\n\t\t\t}\n\n\t\t\t// Slide To Initial Slide\n\t\t\tif (swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) {\n\t\t\t\tswiper.slideTo(swiper.params.initialSlide + swiper.virtual.slidesBefore, 0, swiper.params.runCallbacksOnInit, false, true);\n\t\t\t} else {\n\t\t\t\tswiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, false, true);\n\t\t\t}\n\n\t\t\t// Create loop\n\t\t\tif (swiper.params.loop) {\n\t\t\t\tswiper.loopCreate();\n\t\t\t}\n\n\t\t\t// Attach events\n\t\t\tswiper.attachEvents();\n\t\t\tconst lazyElements = [...swiper.el.querySelectorAll('[loading=\"lazy\"]')];\n\t\t\tif (swiper.isElement) {\n\t\t\t\tlazyElements.push(...swiper.hostEl.querySelectorAll('[loading=\"lazy\"]'));\n\t\t\t}\n\t\t\tlazyElements.forEach(imageEl => {\n\t\t\t\tif (imageEl.complete) {\n\t\t\t\t\tprocessLazyPreloader(swiper, imageEl);\n\t\t\t\t} else {\n\t\t\t\t\timageEl.addEventListener('load', e => {\n\t\t\t\t\t\tprocessLazyPreloader(swiper, e.target);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t\tpreload(swiper);\n\n\t\t\t// Init Flag\n\t\t\tswiper.initialized = true;\n\t\t\tpreload(swiper);\n\n\t\t\t// Emit\n\t\t\tswiper.emit('init');\n\t\t\tswiper.emit('afterInit');\n\t\t\treturn swiper;\n\t\t}\n\t\tdestroy(deleteInstance, cleanStyles) {\n\t\t\tif (deleteInstance === void 0) {\n\t\t\t\tdeleteInstance = true;\n\t\t\t}\n\t\t\tif (cleanStyles === void 0) {\n\t\t\t\tcleanStyles = true;\n\t\t\t}\n\t\t\tconst swiper = this;\n\t\t\tconst {\n\t\t\t\tparams,\n\t\t\t\tel,\n\t\t\t\twrapperEl,\n\t\t\t\tslides\n\t\t\t} = swiper;\n\t\t\tif (typeof swiper.params === 'undefined' || swiper.destroyed) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tswiper.emit('beforeDestroy');\n\n\t\t\t// Init Flag\n\t\t\tswiper.initialized = false;\n\n\t\t\t// Detach events\n\t\t\tswiper.detachEvents();\n\n\t\t\t// Destroy loop\n\t\t\tif (params.loop) {\n\t\t\t\tswiper.loopDestroy();\n\t\t\t}\n\n\t\t\t// Cleanup styles\n\t\t\tif (cleanStyles) {\n\t\t\t\tswiper.removeClasses();\n\t\t\t\tel.removeAttribute('style');\n\t\t\t\twrapperEl.removeAttribute('style');\n\t\t\t\tif (slides && slides.length) {\n\t\t\t\t\tslides.forEach(slideEl => {\n\t\t\t\t\t\tslideEl.classList.remove(params.slideVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass);\n\t\t\t\t\t\tslideEl.removeAttribute('style');\n\t\t\t\t\t\tslideEl.removeAttribute('data-swiper-slide-index');\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\tswiper.emit('destroy');\n\n\t\t\t// Detach emitter events\n\t\t\tObject.keys(swiper.eventsListeners).forEach(eventName => {\n\t\t\t\tswiper.off(eventName);\n\t\t\t});\n\t\t\tif (deleteInstance !== false) {\n\t\t\t\tswiper.el.swiper = null;\n\t\t\t\tdeleteProps(swiper);\n\t\t\t}\n\t\t\tswiper.destroyed = true;\n\t\t\treturn null;\n\t\t}\n\t\tstatic extendDefaults(newDefaults) {\n\t\t\textend(extendedDefaults, newDefaults);\n\t\t}\n\t\tstatic get extendedDefaults() {\n\t\t\treturn extendedDefaults;\n\t\t}\n\t\tstatic get defaults() {\n\t\t\treturn defaults;\n\t\t}\n\t\tstatic installModule(mod) {\n\t\t\tif (!Swiper.prototype.__modules__) Swiper.prototype.__modules__ = [];\n\t\t\tconst modules = Swiper.prototype.__modules__;\n\t\t\tif (typeof mod === 'function' && modules.indexOf(mod) < 0) {\n\t\t\t\tmodules.push(mod);\n\t\t\t}\n\t\t}\n\t\tstatic use(module) {\n\t\t\tif (Array.isArray(module)) {\n\t\t\t\tmodule.forEach(m => Swiper.installModule(m));\n\t\t\t\treturn Swiper;\n\t\t\t}\n\t\t\tSwiper.installModule(module);\n\t\t\treturn Swiper;\n\t\t}\n\t}\n\tObject.keys(prototypes).forEach(prototypeGroup => {\n\t\tObject.keys(prototypes[prototypeGroup]).forEach(protoMethod => {\n\t\t\tSwiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];\n\t\t});\n\t});\n\tSwiper.use([Resize, Observer]);\n\n\tfunction Virtual(_ref) {\n\t\tlet {\n\t\t\tswiper,\n\t\t\textendParams,\n\t\t\ton,\n\t\t\temit\n\t\t} = _ref;\n\t\textendParams({\n\t\t\tvirtual: {\n\t\t\t\tenabled: false,\n\t\t\t\tslides: [],\n\t\t\t\tcache: true,\n\t\t\t\trenderSlide: null,\n\t\t\t\trenderExternal: null,\n\t\t\t\trenderExternalUpdate: true,\n\t\t\t\taddSlidesBefore: 0,\n\t\t\t\taddSlidesAfter: 0\n\t\t\t}\n\t\t});\n\t\tlet cssModeTimeout;\n\t\tconst document = getDocument();\n\t\tswiper.virtual = {\n\t\t\tcache: {},\n\t\t\tfrom: undefined,\n\t\t\tto: undefined,\n\t\t\tslides: [],\n\t\t\toffset: 0,\n\t\t\tslidesGrid: []\n\t\t};\n\t\tconst tempDOM = document.createElement('div');\n\t\tfunction renderSlide(slide, index) {\n\t\t\tconst params = swiper.params.virtual;\n\t\t\tif (params.cache && swiper.virtual.cache[index]) {\n\t\t\t\treturn swiper.virtual.cache[index];\n\t\t\t}\n\t\t\t// eslint-disable-next-line\n\t\t\tlet slideEl;\n\t\t\tif (params.renderSlide) {\n\t\t\t\tslideEl = params.renderSlide.call(swiper, slide, index);\n\t\t\t\tif (typeof slideEl === 'string') {\n\t\t\t\t\ttempDOM.innerHTML = slideEl;\n\t\t\t\t\tslideEl = tempDOM.children[0];\n\t\t\t\t}\n\t\t\t} else if (swiper.isElement) {\n\t\t\t\tslideEl = createElement('swiper-slide');\n\t\t\t} else {\n\t\t\t\tslideEl = createElement('div', swiper.params.slideClass);\n\t\t\t}\n\t\t\tslideEl.setAttribute('data-swiper-slide-index', index);\n\t\t\tif (!params.renderSlide) {\n\t\t\t\tslideEl.innerHTML = slide;\n\t\t\t}\n\t\t\tif (params.cache) swiper.virtual.cache[index] = slideEl;\n\t\t\treturn slideEl;\n\t\t}\n\t\tfunction update(force) {\n\t\t\tconst {\n\t\t\t\tslidesPerView,\n\t\t\t\tslidesPerGroup,\n\t\t\t\tcenteredSlides,\n\t\t\t\tloop: isLoop\n\t\t\t} = swiper.params;\n\t\t\tconst {\n\t\t\t\taddSlidesBefore,\n\t\t\t\taddSlidesAfter\n\t\t\t} = swiper.params.virtual;\n\t\t\tconst {\n\t\t\t\tfrom: previousFrom,\n\t\t\t\tto: previousTo,\n\t\t\t\tslides,\n\t\t\t\tslidesGrid: previousSlidesGrid,\n\t\t\t\toffset: previousOffset\n\t\t\t} = swiper.virtual;\n\t\t\tif (!swiper.params.cssMode) {\n\t\t\t\tswiper.updateActiveIndex();\n\t\t\t}\n\t\t\tconst activeIndex = swiper.activeIndex || 0;\n\t\t\tlet offsetProp;\n\t\t\tif (swiper.rtlTranslate) offsetProp = 'right'; else offsetProp = swiper.isHorizontal() ? 'left' : 'top';\n\t\t\tlet slidesAfter;\n\t\t\tlet slidesBefore;\n\t\t\tif (centeredSlides) {\n\t\t\t\tslidesAfter = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesAfter;\n\t\t\t\tslidesBefore = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesBefore;\n\t\t\t} else {\n\t\t\t\tslidesAfter = slidesPerView + (slidesPerGroup - 1) + addSlidesAfter;\n\t\t\t\tslidesBefore = (isLoop ? slidesPerView : slidesPerGroup) + addSlidesBefore;\n\t\t\t}\n\t\t\tlet from = activeIndex - slidesBefore;\n\t\t\tlet to = activeIndex + slidesAfter;\n\t\t\tif (!isLoop) {\n\t\t\t\tfrom = Math.max(from, 0);\n\t\t\t\tto = Math.min(to, slides.length - 1);\n\t\t\t}\n\t\t\tlet offset = (swiper.slidesGrid[from] || 0) - (swiper.slidesGrid[0] || 0);\n\t\t\tif (isLoop && activeIndex >= slidesBefore) {\n\t\t\t\tfrom -= slidesBefore;\n\t\t\t\tif (!centeredSlides) offset += swiper.slidesGrid[0];\n\t\t\t} else if (isLoop && activeIndex < slidesBefore) {\n\t\t\t\tfrom = -slidesBefore;\n\t\t\t\tif (centeredSlides) offset += swiper.slidesGrid[0];\n\t\t\t}\n\t\t\tObject.assign(swiper.virtual, {\n\t\t\t\tfrom,\n\t\t\t\tto,\n\t\t\t\toffset,\n\t\t\t\tslidesGrid: swiper.slidesGrid,\n\t\t\t\tslidesBefore,\n\t\t\t\tslidesAfter\n\t\t\t});\n\t\t\tfunction onRendered() {\n\t\t\t\tswiper.updateSlides();\n\t\t\t\tswiper.updateProgress();\n\t\t\t\tswiper.updateSlidesClasses();\n\t\t\t\temit('virtualUpdate');\n\t\t\t}\n\t\t\tif (previousFrom === from && previousTo === to && !force) {\n\t\t\t\tif (swiper.slidesGrid !== previousSlidesGrid && offset !== previousOffset) {\n\t\t\t\t\tswiper.slides.forEach(slideEl => {\n\t\t\t\t\t\tslideEl.style[offsetProp] = `${offset - Math.abs(swiper.cssOverflowAdjustment())}px`;\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tswiper.updateProgress();\n\t\t\t\temit('virtualUpdate');\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (swiper.params.virtual.renderExternal) {\n\t\t\t\tswiper.params.virtual.renderExternal.call(swiper, {\n\t\t\t\t\toffset,\n\t\t\t\t\tfrom,\n\t\t\t\t\tto,\n\t\t\t\t\tslides: function getSlides() {\n\t\t\t\t\t\tconst slidesToRender = [];\n\t\t\t\t\t\tfor (let i = from; i <= to; i += 1) {\n\t\t\t\t\t\t\tslidesToRender.push(slides[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn slidesToRender;\n\t\t\t\t\t}()\n\t\t\t\t});\n\t\t\t\tif (swiper.params.virtual.renderExternalUpdate) {\n\t\t\t\t\tonRendered();\n\t\t\t\t} else {\n\t\t\t\t\temit('virtualUpdate');\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst prependIndexes = [];\n\t\t\tconst appendIndexes = [];\n\t\t\tconst getSlideIndex = index => {\n\t\t\t\tlet slideIndex = index;\n\t\t\t\tif (index < 0) {\n\t\t\t\t\tslideIndex = slides.length + index;\n\t\t\t\t} else if (slideIndex >= slides.length) {\n\t\t\t\t\t// eslint-disable-next-line\n\t\t\t\t\tslideIndex = slideIndex - slides.length;\n\t\t\t\t}\n\t\t\t\treturn slideIndex;\n\t\t\t};\n\t\t\tif (force) {\n\t\t\t\tswiper.slidesEl.querySelectorAll(`.${swiper.params.slideClass}, swiper-slide`).forEach(slideEl => {\n\t\t\t\t\tslideEl.remove();\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tfor (let i = previousFrom; i <= previousTo; i += 1) {\n\t\t\t\t\tif (i < from || i > to) {\n\t\t\t\t\t\tconst slideIndex = getSlideIndex(i);\n\t\t\t\t\t\tswiper.slidesEl.querySelectorAll(`.${swiper.params.slideClass}[data-swiper-slide-index=\"${slideIndex}\"], swiper-slide[data-swiper-slide-index=\"${slideIndex}\"]`).forEach(slideEl => {\n\t\t\t\t\t\t\tslideEl.remove();\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst loopFrom = isLoop ? -slides.length : 0;\n\t\t\tconst loopTo = isLoop ? slides.length * 2 : slides.length;\n\t\t\tfor (let i = loopFrom; i < loopTo; i += 1) {\n\t\t\t\tif (i >= from && i <= to) {\n\t\t\t\t\tconst slideIndex = getSlideIndex(i);\n\t\t\t\t\tif (typeof previousTo === 'undefined' || force) {\n\t\t\t\t\t\tappendIndexes.push(slideIndex);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (i > previousTo) appendIndexes.push(slideIndex);\n\t\t\t\t\t\tif (i < previousFrom) prependIndexes.push(slideIndex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tappendIndexes.forEach(index => {\n\t\t\t\tswiper.slidesEl.append(renderSlide(slides[index], index));\n\t\t\t});\n\t\t\tif (isLoop) {\n\t\t\t\tfor (let i = prependIndexes.length - 1; i >= 0; i -= 1) {\n\t\t\t\t\tconst index = prependIndexes[i];\n\t\t\t\t\tswiper.slidesEl.prepend(renderSlide(slides[index], index));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tprependIndexes.sort((a, b) => b - a);\n\t\t\t\tprependIndexes.forEach(index => {\n\t\t\t\t\tswiper.slidesEl.prepend(renderSlide(slides[index], index));\n\t\t\t\t});\n\t\t\t}\n\t\t\telementChildren(swiper.slidesEl, '.swiper-slide, swiper-slide').forEach(slideEl => {\n\t\t\t\tslideEl.style[offsetProp] = `${offset - Math.abs(swiper.cssOverflowAdjustment())}px`;\n\t\t\t});\n\t\t\tonRendered();\n\t\t}\n\t\tfunction appendSlide(slides) {\n\t\t\tif (typeof slides === 'object' && 'length' in slides) {\n\t\t\t\tfor (let i = 0; i < slides.length; i += 1) {\n\t\t\t\t\tif (slides[i]) swiper.virtual.slides.push(slides[i]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tswiper.virtual.slides.push(slides);\n\t\t\t}\n\t\t\tupdate(true);\n\t\t}\n\t\tfunction prependSlide(slides) {\n\t\t\tconst activeIndex = swiper.activeIndex;\n\t\t\tlet newActiveIndex = activeIndex + 1;\n\t\t\tlet numberOfNewSlides = 1;\n\t\t\tif (Array.isArray(slides)) {\n\t\t\t\tfor (let i = 0; i < slides.length; i += 1) {\n\t\t\t\t\tif (slides[i]) swiper.virtual.slides.unshift(slides[i]);\n\t\t\t\t}\n\t\t\t\tnewActiveIndex = activeIndex + slides.length;\n\t\t\t\tnumberOfNewSlides = slides.length;\n\t\t\t} else {\n\t\t\t\tswiper.virtual.slides.unshift(slides);\n\t\t\t}\n\t\t\tif (swiper.params.virtual.cache) {\n\t\t\t\tconst cache = swiper.virtual.cache;\n\t\t\t\tconst newCache = {};\n\t\t\t\tObject.keys(cache).forEach(cachedIndex => {\n\t\t\t\t\tconst cachedEl = cache[cachedIndex];\n\t\t\t\t\tconst cachedElIndex = cachedEl.getAttribute('data-swiper-slide-index');\n\t\t\t\t\tif (cachedElIndex) {\n\t\t\t\t\t\tcachedEl.setAttribute('data-swiper-slide-index', parseInt(cachedElIndex, 10) + numberOfNewSlides);\n\t\t\t\t\t}\n\t\t\t\t\tnewCache[parseInt(cachedIndex, 10) + numberOfNewSlides] = cachedEl;\n\t\t\t\t});\n\t\t\t\tswiper.virtual.cache = newCache;\n\t\t\t}\n\t\t\tupdate(true);\n\t\t\tswiper.slideTo(newActiveIndex, 0);\n\t\t}\n\t\tfunction removeSlide(slidesIndexes) {\n\t\t\tif (typeof slidesIndexes === 'undefined' || slidesIndexes === null) return;\n\t\t\tlet activeIndex = swiper.activeIndex;\n\t\t\tif (Array.isArray(slidesIndexes)) {\n\t\t\t\tfor (let i = slidesIndexes.length - 1; i >= 0; i -= 1) {\n\t\t\t\t\tswiper.virtual.slides.splice(slidesIndexes[i], 1);\n\t\t\t\t\tif (swiper.params.virtual.cache) {\n\t\t\t\t\t\tdelete swiper.virtual.cache[slidesIndexes[i]];\n\t\t\t\t\t}\n\t\t\t\t\tif (slidesIndexes[i] < activeIndex) activeIndex -= 1;\n\t\t\t\t\tactiveIndex = Math.max(activeIndex, 0);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tswiper.virtual.slides.splice(slidesIndexes, 1);\n\t\t\t\tif (swiper.params.virtual.cache) {\n\t\t\t\t\tdelete swiper.virtual.cache[slidesIndexes];\n\t\t\t\t}\n\t\t\t\tif (slidesIndexes < activeIndex) activeIndex -= 1;\n\t\t\t\tactiveIndex = Math.max(activeIndex, 0);\n\t\t\t}\n\t\t\tupdate(true);\n\t\t\tswiper.slideTo(activeIndex, 0);\n\t\t}\n\t\tfunction removeAllSlides() {\n\t\t\tswiper.virtual.slides = [];\n\t\t\tif (swiper.params.virtual.cache) {\n\t\t\t\tswiper.virtual.cache = {};\n\t\t\t}\n\t\t\tupdate(true);\n\t\t\tswiper.slideTo(0, 0);\n\t\t}\n\t\ton('beforeInit', () => {\n\t\t\tif (!swiper.params.virtual.enabled) return;\n\t\t\tlet domSlidesAssigned;\n\t\t\tif (typeof swiper.passedParams.virtual.slides === 'undefined') {\n\t\t\t\tconst slides = [...swiper.slidesEl.children].filter(el => el.matches(`.${swiper.params.slideClass}, swiper-slide`));\n\t\t\t\tif (slides && slides.length) {\n\t\t\t\t\tswiper.virtual.slides = [...slides];\n\t\t\t\t\tdomSlidesAssigned = true;\n\t\t\t\t\tslides.forEach((slideEl, slideIndex) => {\n\t\t\t\t\t\tslideEl.setAttribute('data-swiper-slide-index', slideIndex);\n\t\t\t\t\t\tswiper.virtual.cache[slideIndex] = slideEl;\n\t\t\t\t\t\tslideEl.remove();\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!domSlidesAssigned) {\n\t\t\t\tswiper.virtual.slides = swiper.params.virtual.slides;\n\t\t\t}\n\t\t\tswiper.classNames.push(`${swiper.params.containerModifierClass}virtual`);\n\t\t\tswiper.params.watchSlidesProgress = true;\n\t\t\tswiper.originalParams.watchSlidesProgress = true;\n\t\t\tif (!swiper.params.initialSlide) {\n\t\t\t\tupdate();\n\t\t\t}\n\t\t});\n\t\ton('setTranslate', () => {\n\t\t\tif (!swiper.params.virtual.enabled) return;\n\t\t\tif (swiper.params.cssMode && !swiper._immediateVirtual) {\n\t\t\t\tclearTimeout(cssModeTimeout);\n\t\t\t\tcssModeTimeout = setTimeout(() => {\n\t\t\t\t\tupdate();\n\t\t\t\t}, 100);\n\t\t\t} else {\n\t\t\t\tupdate();\n\t\t\t}\n\t\t});\n\t\ton('init update resize', () => {\n\t\t\tif (!swiper.params.virtual.enabled) return;\n\t\t\tif (swiper.params.cssMode) {\n\t\t\t\tsetCSSProperty(swiper.wrapperEl, '--swiper-virtual-size', `${swiper.virtualSize}px`);\n\t\t\t}\n\t\t});\n\t\tObject.assign(swiper.virtual, {\n\t\t\tappendSlide,\n\t\t\tprependSlide,\n\t\t\tremoveSlide,\n\t\t\tremoveAllSlides,\n\t\t\tupdate\n\t\t});\n\t}\n\n\t/* eslint-disable consistent-return */\n\tfunction Keyboard(_ref) {\n\t\tlet {\n\t\t\tswiper,\n\t\t\textendParams,\n\t\t\ton,\n\t\t\temit\n\t\t} = _ref;\n\t\tconst document = getDocument();\n\t\tconst window = getWindow();\n\t\tswiper.keyboard = {\n\t\t\tenabled: false\n\t\t};\n\t\textendParams({\n\t\t\tkeyboard: {\n\t\t\t\tenabled: false,\n\t\t\t\tonlyInViewport: true,\n\t\t\t\tpageUpDown: true\n\t\t\t}\n\t\t});\n\t\tfunction handle(event) {\n\t\t\tif (!swiper.enabled) return;\n\t\t\tconst {\n\t\t\t\trtlTranslate: rtl\n\t\t\t} = swiper;\n\t\t\tlet e = event;\n\t\t\tif (e.originalEvent) e = e.originalEvent; // jquery fix\n\t\t\tconst kc = e.keyCode || e.charCode;\n\t\t\tconst pageUpDown = swiper.params.keyboard.pageUpDown;\n\t\t\tconst isPageUp = pageUpDown && kc === 33;\n\t\t\tconst isPageDown = pageUpDown && kc === 34;\n\t\t\tconst isArrowLeft = kc === 37;\n\t\t\tconst isArrowRight = kc === 39;\n\t\t\tconst isArrowUp = kc === 38;\n\t\t\tconst isArrowDown = kc === 40;\n\t\t\t// Directions locks\n\t\t\tif (!swiper.allowSlideNext && (swiper.isHorizontal() && isArrowRight || swiper.isVertical() && isArrowDown || isPageDown)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!swiper.allowSlidePrev && (swiper.isHorizontal() && isArrowLeft || swiper.isVertical() && isArrowUp || isPageUp)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\tif (document.activeElement && document.activeElement.nodeName && (document.activeElement.nodeName.toLowerCase() === 'input' || document.activeElement.nodeName.toLowerCase() === 'textarea')) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\tif (swiper.params.keyboard.onlyInViewport && (isPageUp || isPageDown || isArrowLeft || isArrowRight || isArrowUp || isArrowDown)) {\n\t\t\t\tlet inView = false;\n\t\t\t\t// Check that swiper should be inside of visible area of window\n\t\t\t\tif (elementParents(swiper.el, `.${swiper.params.slideClass}, swiper-slide`).length > 0 && elementParents(swiper.el, `.${swiper.params.slideActiveClass}`).length === 0) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t\t\tconst el = swiper.el;\n\t\t\t\tconst swiperWidth = el.clientWidth;\n\t\t\t\tconst swiperHeight = el.clientHeight;\n\t\t\t\tconst windowWidth = window.innerWidth;\n\t\t\t\tconst windowHeight = window.innerHeight;\n\t\t\t\tconst swiperOffset = elementOffset(el);\n\t\t\t\tif (rtl) swiperOffset.left -= el.scrollLeft;\n\t\t\t\tconst swiperCoord = [[swiperOffset.left, swiperOffset.top], [swiperOffset.left + swiperWidth, swiperOffset.top], [swiperOffset.left, swiperOffset.top + swiperHeight], [swiperOffset.left + swiperWidth, swiperOffset.top + swiperHeight]];\n\t\t\t\tfor (let i = 0; i < swiperCoord.length; i += 1) {\n\t\t\t\t\tconst point = swiperCoord[i];\n\t\t\t\t\tif (point[0] >= 0 && point[0] <= windowWidth && point[1] >= 0 && point[1] <= windowHeight) {\n\t\t\t\t\t\tif (point[0] === 0 && point[1] === 0) continue; // eslint-disable-line\n\t\t\t\t\t\tinView = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!inView) return undefined;\n\t\t\t}\n\t\t\tif (swiper.isHorizontal()) {\n\t\t\t\tif (isPageUp || isPageDown || isArrowLeft || isArrowRight) {\n\t\t\t\t\tif (e.preventDefault) e.preventDefault(); else e.returnValue = false;\n\t\t\t\t}\n\t\t\t\tif ((isPageDown || isArrowRight) && !rtl || (isPageUp || isArrowLeft) && rtl) swiper.slideNext();\n\t\t\t\tif ((isPageUp || isArrowLeft) && !rtl || (isPageDown || isArrowRight) && rtl) swiper.slidePrev();\n\t\t\t} else {\n\t\t\t\tif (isPageUp || isPageDown || isArrowUp || isArrowDown) {\n\t\t\t\t\tif (e.preventDefault) e.preventDefault(); else e.returnValue = false;\n\t\t\t\t}\n\t\t\t\tif (isPageDown || isArrowDown) swiper.slideNext();\n\t\t\t\tif (isPageUp || isArrowUp) swiper.slidePrev();\n\t\t\t}\n\t\t\temit('keyPress', kc);\n\t\t\treturn undefined;\n\t\t}\n\t\tfunction enable() {\n\t\t\tif (swiper.keyboard.enabled) return;\n\t\t\tdocument.addEventListener('keydown', handle);\n\t\t\tswiper.keyboard.enabled = true;\n\t\t}\n\t\tfunction disable() {\n\t\t\tif (!swiper.keyboard.enabled) return;\n\t\t\tdocument.removeEventListener('keydown', handle);\n\t\t\tswiper.keyboard.enabled = false;\n\t\t}\n\t\ton('init', () => {\n\t\t\tif (swiper.params.keyboard.enabled) {\n\t\t\t\tenable();\n\t\t\t}\n\t\t});\n\t\ton('destroy', () => {\n\t\t\tif (swiper.keyboard.enabled) {\n\t\t\t\tdisable();\n\t\t\t}\n\t\t});\n\t\tObject.assign(swiper.keyboard, {\n\t\t\tenable,\n\t\t\tdisable\n\t\t});\n\t}\n\n\t/* eslint-disable consistent-return */\n\tfunction Mousewheel(_ref) {\n\t\tlet {\n\t\t\tswiper,\n\t\t\textendParams,\n\t\t\ton,\n\t\t\temit\n\t\t} = _ref;\n\t\tconst window = getWindow();\n\t\textendParams({\n\t\t\tmousewheel: {\n\t\t\t\tenabled: false,\n\t\t\t\treleaseOnEdges: false,\n\t\t\t\tinvert: false,\n\t\t\t\tforceToAxis: false,\n\t\t\t\tsensitivity: 1,\n\t\t\t\teventsTarget: 'container',\n\t\t\t\tthresholdDelta: null,\n\t\t\t\tthresholdTime: null,\n\t\t\t\tnoMousewheelClass: 'swiper-no-mousewheel'\n\t\t\t}\n\t\t});\n\t\tswiper.mousewheel = {\n\t\t\tenabled: false\n\t\t};\n\t\tlet timeout;\n\t\tlet lastScrollTime = now();\n\t\tlet lastEventBeforeSnap;\n\t\tconst recentWheelEvents = [];\n\t\tfunction normalize(e) {\n\t\t\t// Reasonable defaults\n\t\t\tconst PIXEL_STEP = 10;\n\t\t\tconst LINE_HEIGHT = 40;\n\t\t\tconst PAGE_HEIGHT = 800;\n\t\t\tlet sX = 0;\n\t\t\tlet sY = 0; // spinX, spinY\n\t\t\tlet pX = 0;\n\t\t\tlet pY = 0; // pixelX, pixelY\n\n\t\t\t// Legacy\n\t\t\tif ('detail' in e) {\n\t\t\t\tsY = e.detail;\n\t\t\t}\n\t\t\tif ('wheelDelta' in e) {\n\t\t\t\tsY = -e.wheelDelta / 120;\n\t\t\t}\n\t\t\tif ('wheelDeltaY' in e) {\n\t\t\t\tsY = -e.wheelDeltaY / 120;\n\t\t\t}\n\t\t\tif ('wheelDeltaX' in e) {\n\t\t\t\tsX = -e.wheelDeltaX / 120;\n\t\t\t}\n\n\t\t\t// side scrolling on FF with DOMMouseScroll\n\t\t\tif ('axis' in e && e.axis === e.HORIZONTAL_AXIS) {\n\t\t\t\tsX = sY;\n\t\t\t\tsY = 0;\n\t\t\t}\n\t\t\tpX = sX * PIXEL_STEP;\n\t\t\tpY = sY * PIXEL_STEP;\n\t\t\tif ('deltaY' in e) {\n\t\t\t\tpY = e.deltaY;\n\t\t\t}\n\t\t\tif ('deltaX' in e) {\n\t\t\t\tpX = e.deltaX;\n\t\t\t}\n\t\t\tif (e.shiftKey && !pX) {\n\t\t\t\t// if user scrolls with shift he wants horizontal scroll\n\t\t\t\tpX = pY;\n\t\t\t\tpY = 0;\n\t\t\t}\n\t\t\tif ((pX || pY) && e.deltaMode) {\n\t\t\t\tif (e.deltaMode === 1) {\n\t\t\t\t\t// delta in LINE units\n\t\t\t\t\tpX *= LINE_HEIGHT;\n\t\t\t\t\tpY *= LINE_HEIGHT;\n\t\t\t\t} else {\n\t\t\t\t\t// delta in PAGE units\n\t\t\t\t\tpX *= PAGE_HEIGHT;\n\t\t\t\t\tpY *= PAGE_HEIGHT;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Fall-back if spin cannot be determined\n\t\t\tif (pX && !sX) {\n\t\t\t\tsX = pX < 1 ? -1 : 1;\n\t\t\t}\n\t\t\tif (pY && !sY) {\n\t\t\t\tsY = pY < 1 ? -1 : 1;\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tspinX: sX,\n\t\t\t\tspinY: sY,\n\t\t\t\tpixelX: pX,\n\t\t\t\tpixelY: pY\n\t\t\t};\n\t\t}\n\t\tfunction handleMouseEnter() {\n\t\t\tif (!swiper.enabled) return;\n\t\t\tswiper.mouseEntered = true;\n\t\t}\n\t\tfunction handleMouseLeave() {\n\t\t\tif (!swiper.enabled) return;\n\t\t\tswiper.mouseEntered = false;\n\t\t}\n\t\tfunction animateSlider(newEvent) {\n\t\t\tif (swiper.params.mousewheel.thresholdDelta && newEvent.delta < swiper.params.mousewheel.thresholdDelta) {\n\t\t\t\t// Prevent if delta of wheel scroll delta is below configured threshold\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (swiper.params.mousewheel.thresholdTime && now() - lastScrollTime < swiper.params.mousewheel.thresholdTime) {\n\t\t\t\t// Prevent if time between scrolls is below configured threshold\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// If the movement is NOT big enough and\n\t\t\t// if the last time the user scrolled was too close to the current one (avoid continuously triggering the slider):\n\t\t\t//   Don't go any further (avoid insignificant scroll movement).\n\t\t\tif (newEvent.delta >= 6 && now() - lastScrollTime < 60) {\n\t\t\t\t// Return false as a default\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t// If user is scrolling towards the end:\n\t\t\t//   If the slider hasn't hit the latest slide or\n\t\t\t//   if the slider is a loop and\n\t\t\t//   if the slider isn't moving right now:\n\t\t\t//     Go to next slide and\n\t\t\t//     emit a scroll event.\n\t\t\t// Else (the user is scrolling towards the beginning) and\n\t\t\t// if the slider hasn't hit the first slide or\n\t\t\t// if the slider is a loop and\n\t\t\t// if the slider isn't moving right now:\n\t\t\t//   Go to prev slide and\n\t\t\t//   emit a scroll event.\n\t\t\tif (newEvent.direction < 0) {\n\t\t\t\tif ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {\n\t\t\t\t\tswiper.slideNext();\n\t\t\t\t\temit('scroll', newEvent.raw);\n\t\t\t\t}\n\t\t\t} else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {\n\t\t\t\tswiper.slidePrev();\n\t\t\t\temit('scroll', newEvent.raw);\n\t\t\t}\n\t\t\t// If you got here is because an animation has been triggered so store the current time\n\t\t\tlastScrollTime = new window.Date().getTime();\n\t\t\t// Return false as a default\n\t\t\treturn false;\n\t\t}\n\t\tfunction releaseScroll(newEvent) {\n\t\t\tconst params = swiper.params.mousewheel;\n\t\t\tif (newEvent.direction < 0) {\n\t\t\t\tif (swiper.isEnd && !swiper.params.loop && params.releaseOnEdges) {\n\t\t\t\t\t// Return true to animate scroll on edges\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t} else if (swiper.isBeginning && !swiper.params.loop && params.releaseOnEdges) {\n\t\t\t\t// Return true to animate scroll on edges\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tfunction handle(event) {\n\t\t\tlet e = event;\n\t\t\tlet disableParentSwiper = true;\n\t\t\tif (!swiper.enabled) return;\n\n\t\t\t// Ignore event if the target or its parents have the swiper-no-mousewheel class\n\t\t\tif (event.target.closest(`.${swiper.params.mousewheel.noMousewheelClass}`)) return;\n\t\t\tconst params = swiper.params.mousewheel;\n\t\t\tif (swiper.params.cssMode) {\n\t\t\t\te.preventDefault();\n\t\t\t}\n\t\t\tlet targetEl = swiper.el;\n\t\t\tif (swiper.params.mousewheel.eventsTarget !== 'container') {\n\t\t\t\ttargetEl = document.querySelector(swiper.params.mousewheel.eventsTarget);\n\t\t\t}\n\t\t\tconst targetElContainsTarget = targetEl && targetEl.contains(e.target);\n\t\t\tif (!swiper.mouseEntered && !targetElContainsTarget && !params.releaseOnEdges) return true;\n\t\t\tif (e.originalEvent) e = e.originalEvent; // jquery fix\n\t\t\tlet delta = 0;\n\t\t\tconst rtlFactor = swiper.rtlTranslate ? -1 : 1;\n\t\t\tconst data = normalize(e);\n\t\t\tif (params.forceToAxis) {\n\t\t\t\tif (swiper.isHorizontal()) {\n\t\t\t\t\tif (Math.abs(data.pixelX) > Math.abs(data.pixelY)) delta = -data.pixelX * rtlFactor; else return true;\n\t\t\t\t} else if (Math.abs(data.pixelY) > Math.abs(data.pixelX)) delta = -data.pixelY; else return true;\n\t\t\t} else {\n\t\t\t\tdelta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;\n\t\t\t}\n\t\t\tif (delta === 0) return true;\n\t\t\tif (params.invert) delta = -delta;\n\n\t\t\t// Get the scroll positions\n\t\t\tlet positions = swiper.getTranslate() + delta * params.sensitivity;\n\t\t\tif (positions >= swiper.minTranslate()) positions = swiper.minTranslate();\n\t\t\tif (positions <= swiper.maxTranslate()) positions = swiper.maxTranslate();\n\n\t\t\t// When loop is true:\n\t\t\t//     the disableParentSwiper will be true.\n\t\t\t// When loop is false:\n\t\t\t//     if the scroll positions is not on edge,\n\t\t\t//     then the disableParentSwiper will be true.\n\t\t\t//     if the scroll on edge positions,\n\t\t\t//     then the disableParentSwiper will be false.\n\t\t\tdisableParentSwiper = swiper.params.loop ? true : !(positions === swiper.minTranslate() || positions === swiper.maxTranslate());\n\t\t\tif (disableParentSwiper && swiper.params.nested) e.stopPropagation();\n\t\t\tif (!swiper.params.freeMode || !swiper.params.freeMode.enabled) {\n\t\t\t\t// Register the new event in a variable which stores the relevant data\n\t\t\t\tconst newEvent = {\n\t\t\t\t\ttime: now(),\n\t\t\t\t\tdelta: Math.abs(delta),\n\t\t\t\t\tdirection: Math.sign(delta),\n\t\t\t\t\traw: event\n\t\t\t\t};\n\n\t\t\t\t// Keep the most recent events\n\t\t\t\tif (recentWheelEvents.length >= 2) {\n\t\t\t\t\trecentWheelEvents.shift(); // only store the last N events\n\t\t\t\t}\n\n\t\t\t\tconst prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;\n\t\t\t\trecentWheelEvents.push(newEvent);\n\n\t\t\t\t// If there is at least one previous recorded event:\n\t\t\t\t//   If direction has changed or\n\t\t\t\t//   if the scroll is quicker than the previous one:\n\t\t\t\t//     Animate the slider.\n\t\t\t\t// Else (this is the first time the wheel is moved):\n\t\t\t\t//     Animate the slider.\n\t\t\t\tif (prevEvent) {\n\t\t\t\t\tif (newEvent.direction !== prevEvent.direction || newEvent.delta > prevEvent.delta || newEvent.time > prevEvent.time + 150) {\n\t\t\t\t\t\tanimateSlider(newEvent);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tanimateSlider(newEvent);\n\t\t\t\t}\n\n\t\t\t\t// If it's time to release the scroll:\n\t\t\t\t//   Return now so you don't hit the preventDefault.\n\t\t\t\tif (releaseScroll(newEvent)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Freemode or scrollContainer:\n\n\t\t\t\t// If we recently snapped after a momentum scroll, then ignore wheel events\n\t\t\t\t// to give time for the deceleration to finish. Stop ignoring after 500 msecs\n\t\t\t\t// or if it's a new scroll (larger delta or inverse sign as last event before\n\t\t\t\t// an end-of-momentum snap).\n\t\t\t\tconst newEvent = {\n\t\t\t\t\ttime: now(),\n\t\t\t\t\tdelta: Math.abs(delta),\n\t\t\t\t\tdirection: Math.sign(delta)\n\t\t\t\t};\n\t\t\t\tconst ignoreWheelEvents = lastEventBeforeSnap && newEvent.time < lastEventBeforeSnap.time + 500 && newEvent.delta <= lastEventBeforeSnap.delta && newEvent.direction === lastEventBeforeSnap.direction;\n\t\t\t\tif (!ignoreWheelEvents) {\n\t\t\t\t\tlastEventBeforeSnap = undefined;\n\t\t\t\t\tlet position = swiper.getTranslate() + delta * params.sensitivity;\n\t\t\t\t\tconst wasBeginning = swiper.isBeginning;\n\t\t\t\t\tconst wasEnd = swiper.isEnd;\n\t\t\t\t\tif (position >= swiper.minTranslate()) position = swiper.minTranslate();\n\t\t\t\t\tif (position <= swiper.maxTranslate()) position = swiper.maxTranslate();\n\t\t\t\t\tswiper.setTransition(0);\n\t\t\t\t\tswiper.setTranslate(position);\n\t\t\t\t\tswiper.updateProgress();\n\t\t\t\t\tswiper.updateActiveIndex();\n\t\t\t\t\tswiper.updateSlidesClasses();\n\t\t\t\t\tif (!wasBeginning && swiper.isBeginning || !wasEnd && swiper.isEnd) {\n\t\t\t\t\t\tswiper.updateSlidesClasses();\n\t\t\t\t\t}\n\t\t\t\t\tif (swiper.params.loop) {\n\t\t\t\t\t\tswiper.loopFix({\n\t\t\t\t\t\t\tdirection: newEvent.direction < 0 ? 'next' : 'prev',\n\t\t\t\t\t\t\tbyMousewheel: true\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tif (swiper.params.freeMode.sticky) {\n\t\t\t\t\t\t// When wheel scrolling starts with sticky (aka snap) enabled, then detect\n\t\t\t\t\t\t// the end of a momentum scroll by storing recent (N=15?) wheel events.\n\t\t\t\t\t\t// 1. do all N events have decreasing or same (absolute value) delta?\n\t\t\t\t\t\t// 2. did all N events arrive in the last M (M=500?) msecs?\n\t\t\t\t\t\t// 3. does the earliest event have an (absolute value) delta that's\n\t\t\t\t\t\t//    at least P (P=1?) larger than the most recent event's delta?\n\t\t\t\t\t\t// 4. does the latest event have a delta that's smaller than Q (Q=6?) pixels?\n\t\t\t\t\t\t// If 1-4 are \"yes\" then we're near the end of a momentum scroll deceleration.\n\t\t\t\t\t\t// Snap immediately and ignore remaining wheel events in this scroll.\n\t\t\t\t\t\t// See comment above for \"remaining wheel events in this scroll\" determination.\n\t\t\t\t\t\t// If 1-4 aren't satisfied, then wait to snap until 500ms after the last event.\n\t\t\t\t\t\tclearTimeout(timeout);\n\t\t\t\t\t\ttimeout = undefined;\n\t\t\t\t\t\tif (recentWheelEvents.length >= 15) {\n\t\t\t\t\t\t\trecentWheelEvents.shift(); // only store the last N events\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;\n\t\t\t\t\t\tconst firstEvent = recentWheelEvents[0];\n\t\t\t\t\t\trecentWheelEvents.push(newEvent);\n\t\t\t\t\t\tif (prevEvent && (newEvent.delta > prevEvent.delta || newEvent.direction !== prevEvent.direction)) {\n\t\t\t\t\t\t\t// Increasing or reverse-sign delta means the user started scrolling again. Clear the wheel event log.\n\t\t\t\t\t\t\trecentWheelEvents.splice(0);\n\t\t\t\t\t\t} else if (recentWheelEvents.length >= 15 && newEvent.time - firstEvent.time < 500 && firstEvent.delta - newEvent.delta >= 1 && newEvent.delta <= 6) {\n\t\t\t\t\t\t\t// We're at the end of the deceleration of a momentum scroll, so there's no need\n\t\t\t\t\t\t\t// to wait for more events. Snap ASAP on the next tick.\n\t\t\t\t\t\t\t// Also, because there's some remaining momentum we'll bias the snap in the\n\t\t\t\t\t\t\t// direction of the ongoing scroll because it's better UX for the scroll to snap\n\t\t\t\t\t\t\t// in the same direction as the scroll instead of reversing to snap.  Therefore,\n\t\t\t\t\t\t\t// if it's already scrolled more than 20% in the current direction, keep going.\n\t\t\t\t\t\t\tconst snapToThreshold = delta > 0 ? 0.8 : 0.2;\n\t\t\t\t\t\t\tlastEventBeforeSnap = newEvent;\n\t\t\t\t\t\t\trecentWheelEvents.splice(0);\n\t\t\t\t\t\t\ttimeout = nextTick(() => {\n\t\t\t\t\t\t\t\tswiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);\n\t\t\t\t\t\t\t}, 0); // no delay; move on next tick\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!timeout) {\n\t\t\t\t\t\t\t// if we get here, then we haven't detected the end of a momentum scroll, so\n\t\t\t\t\t\t\t// we'll consider a scroll \"complete\" when there haven't been any wheel events\n\t\t\t\t\t\t\t// for 500ms.\n\t\t\t\t\t\t\ttimeout = nextTick(() => {\n\t\t\t\t\t\t\t\tconst snapToThreshold = 0.5;\n\t\t\t\t\t\t\t\tlastEventBeforeSnap = newEvent;\n\t\t\t\t\t\t\t\trecentWheelEvents.splice(0);\n\t\t\t\t\t\t\t\tswiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);\n\t\t\t\t\t\t\t}, 500);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Emit event\n\t\t\t\t\tif (!ignoreWheelEvents) emit('scroll', e);\n\n\t\t\t\t\t// Stop autoplay\n\t\t\t\t\tif (swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction) swiper.autoplay.stop();\n\t\t\t\t\t// Return page scroll on edge positions\n\t\t\t\t\tif (params.releaseOnEdges && (position === swiper.minTranslate() || position === swiper.maxTranslate())) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (e.preventDefault) e.preventDefault(); else e.returnValue = false;\n\t\t\treturn false;\n\t\t}\n\t\tfunction events(method) {\n\t\t\tlet targetEl = swiper.el;\n\t\t\tif (swiper.params.mousewheel.eventsTarget !== 'container') {\n\t\t\t\ttargetEl = document.querySelector(swiper.params.mousewheel.eventsTarget);\n\t\t\t}\n\t\t\ttargetEl[method]('mouseenter', handleMouseEnter);\n\t\t\ttargetEl[method]('mouseleave', handleMouseLeave);\n\t\t\ttargetEl[method]('wheel', handle);\n\t\t}\n\t\tfunction enable() {\n\t\t\tif (swiper.params.cssMode) {\n\t\t\t\tswiper.wrapperEl.removeEventListener('wheel', handle);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (swiper.mousewheel.enabled) return false;\n\t\t\tevents('addEventListener');\n\t\t\tswiper.mousewheel.enabled = true;\n\t\t\treturn true;\n\t\t}\n\t\tfunction disable() {\n\t\t\tif (swiper.params.cssMode) {\n\t\t\t\tswiper.wrapperEl.addEventListener(event, handle);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (!swiper.mousewheel.enabled) return false;\n\t\t\tevents('removeEventListener');\n\t\t\tswiper.mousewheel.enabled = false;\n\t\t\treturn true;\n\t\t}\n\t\ton('init', () => {\n\t\t\tif (!swiper.params.mousewheel.enabled && swiper.params.cssMode) {\n\t\t\t\tdisable();\n\t\t\t}\n\t\t\tif (swiper.params.mousewheel.enabled) enable();\n\t\t});\n\t\ton('destroy', () => {\n\t\t\tif (swiper.params.cssMode) {\n\t\t\t\tenable();\n\t\t\t}\n\t\t\tif (swiper.mousewheel.enabled) disable();\n\t\t});\n\t\tObject.assign(swiper.mousewheel, {\n\t\t\tenable,\n\t\t\tdisable\n\t\t});\n\t}\n\n\tfunction createElementIfNotDefined(swiper, originalParams, params, checkProps) {\n\t\tif (swiper.params.createElements) {\n\t\t\tObject.keys(checkProps).forEach(key => {\n\t\t\t\tif (!params[key] && params.auto === true) {\n\t\t\t\t\tlet element = elementChildren(swiper.el, `.${checkProps[key]}`)[0];\n\t\t\t\t\tif (!element) {\n\t\t\t\t\t\telement = createElement('div', checkProps[key]);\n\t\t\t\t\t\telement.className = checkProps[key];\n\t\t\t\t\t\tswiper.el.append(element);\n\t\t\t\t\t}\n\t\t\t\t\tparams[key] = element;\n\t\t\t\t\toriginalParams[key] = element;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn params;\n\t}\n\n\tfunction Navigation(_ref) {\n\t\tlet {\n\t\t\tswiper,\n\t\t\textendParams,\n\t\t\ton,\n\t\t\temit\n\t\t} = _ref;\n\t\textendParams({\n\t\t\tnavigation: {\n\t\t\t\tnextEl: null,\n\t\t\t\tprevEl: null,\n\t\t\t\thideOnClick: false,\n\t\t\t\tdisabledClass: 'swiper-button-disabled',\n\t\t\t\thiddenClass: 'swiper-button-hidden',\n\t\t\t\tlockClass: 'swiper-button-lock',\n\t\t\t\tnavigationDisabledClass: 'swiper-navigation-disabled'\n\t\t\t}\n\t\t});\n\t\tswiper.navigation = {\n\t\t\tnextEl: null,\n\t\t\tprevEl: null\n\t\t};\n\t\tconst makeElementsArray = el => (Array.isArray(el) ? el : [el]).filter(e => !!e);\n\t\tfunction getEl(el) {\n\t\t\tlet res;\n\t\t\tif (el && typeof el === 'string' && swiper.isElement) {\n\t\t\t\tres = swiper.el.querySelector(el);\n\t\t\t\tif (res) return res;\n\t\t\t}\n\t\t\tif (el) {\n\t\t\t\tif (typeof el === 'string') res = [...document.querySelectorAll(el)];\n\t\t\t\tif (swiper.params.uniqueNavElements && typeof el === 'string' && res.length > 1 && swiper.el.querySelectorAll(el).length === 1) {\n\t\t\t\t\tres = swiper.el.querySelector(el);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (el && !res) return el;\n\t\t\t// if (Array.isArray(res) && res.length === 1) res = res[0];\n\t\t\treturn res;\n\t\t}\n\t\tfunction toggleEl(el, disabled) {\n\t\t\tconst params = swiper.params.navigation;\n\t\t\tel = makeElementsArray(el);\n\t\t\tel.forEach(subEl => {\n\t\t\t\tif (subEl) {\n\t\t\t\t\tsubEl.classList[disabled ? 'add' : 'remove'](...params.disabledClass.split(' '));\n\t\t\t\t\tif (subEl.tagName === 'BUTTON') subEl.disabled = disabled;\n\t\t\t\t\tif (swiper.params.watchOverflow && swiper.enabled) {\n\t\t\t\t\t\tsubEl.classList[swiper.isLocked ? 'add' : 'remove'](params.lockClass);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tfunction update() {\n\t\t\t// Update Navigation Buttons\n\t\t\tconst {\n\t\t\t\tnextEl,\n\t\t\t\tprevEl\n\t\t\t} = swiper.navigation;\n\t\t\tif (swiper.params.loop) {\n\t\t\t\ttoggleEl(prevEl, false);\n\t\t\t\ttoggleEl(nextEl, false);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttoggleEl(prevEl, swiper.isBeginning && !swiper.params.rewind);\n\t\t\ttoggleEl(nextEl, swiper.isEnd && !swiper.params.rewind);\n\t\t}\n\t\tfunction onPrevClick(e) {\n\t\t\te.preventDefault();\n\t\t\tif (swiper.isBeginning && !swiper.params.loop && !swiper.params.rewind) return;\n\t\t\tswiper.slidePrev();\n\t\t\temit('navigationPrev');\n\t\t}\n\t\tfunction onNextClick(e) {\n\t\t\te.preventDefault();\n\t\t\tif (swiper.isEnd && !swiper.params.loop && !swiper.params.rewind) return;\n\t\t\tswiper.slideNext();\n\t\t\temit('navigationNext');\n\t\t}\n\t\tfunction init() {\n\t\t\tconst params = swiper.params.navigation;\n\t\t\tswiper.params.navigation = createElementIfNotDefined(swiper, swiper.originalParams.navigation, swiper.params.navigation, {\n\t\t\t\tnextEl: 'swiper-button-next',\n\t\t\t\tprevEl: 'swiper-button-prev'\n\t\t\t});\n\t\t\tif (!(params.nextEl || params.prevEl)) return;\n\t\t\tlet nextEl = getEl(params.nextEl);\n\t\t\tlet prevEl = getEl(params.prevEl);\n\t\t\tObject.assign(swiper.navigation, {\n\t\t\t\tnextEl,\n\t\t\t\tprevEl\n\t\t\t});\n\t\t\tnextEl = makeElementsArray(nextEl);\n\t\t\tprevEl = makeElementsArray(prevEl);\n\t\t\tconst initButton = (el, dir) => {\n\t\t\t\tif (el) {\n\t\t\t\t\tel.addEventListener('click', dir === 'next' ? onNextClick : onPrevClick);\n\t\t\t\t}\n\t\t\t\tif (!swiper.enabled && el) {\n\t\t\t\t\tel.classList.add(...params.lockClass.split(' '));\n\t\t\t\t}\n\t\t\t};\n\t\t\tnextEl.forEach(el => initButton(el, 'next'));\n\t\t\tprevEl.forEach(el => initButton(el, 'prev'));\n\t\t}\n\t\tfunction destroy() {\n\t\t\tlet {\n\t\t\t\tnextEl,\n\t\t\t\tprevEl\n\t\t\t} = swiper.navigation;\n\t\t\tnextEl = makeElementsArray(nextEl);\n\t\t\tprevEl = makeElementsArray(prevEl);\n\t\t\tconst destroyButton = (el, dir) => {\n\t\t\t\tel.removeEventListener('click', dir === 'next' ? onNextClick : onPrevClick);\n\t\t\t\tel.classList.remove(...swiper.params.navigation.disabledClass.split(' '));\n\t\t\t};\n\t\t\tnextEl.forEach(el => destroyButton(el, 'next'));\n\t\t\tprevEl.forEach(el => destroyButton(el, 'prev'));\n\t\t}\n\t\ton('init', () => {\n\t\t\tif (swiper.params.navigation.enabled === false) {\n\t\t\t\t// eslint-disable-next-line\n\t\t\t\tdisable();\n\t\t\t} else {\n\t\t\t\tinit();\n\t\t\t\tupdate();\n\t\t\t}\n\t\t});\n\t\ton('toEdge fromEdge lock unlock', () => {\n\t\t\tupdate();\n\t\t});\n\t\ton('destroy', () => {\n\t\t\tdestroy();\n\t\t});\n\t\ton('enable disable', () => {\n\t\t\tlet {\n\t\t\t\tnextEl,\n\t\t\t\tprevEl\n\t\t\t} = swiper.navigation;\n\t\t\tnextEl = makeElementsArray(nextEl);\n\t\t\tprevEl = makeElementsArray(prevEl);\n\t\t\t[...nextEl, ...prevEl].filter(el => !!el).forEach(el => el.classList[swiper.enabled ? 'remove' : 'add'](swiper.params.navigation.lockClass));\n\t\t});\n\t\ton('click', (_s, e) => {\n\t\t\tlet {\n\t\t\t\tnextEl,\n\t\t\t\tprevEl\n\t\t\t} = swiper.navigation;\n\t\t\tnextEl = makeElementsArray(nextEl);\n\t\t\tprevEl = makeElementsArray(prevEl);\n\t\t\tconst targetEl = e.target;\n\t\t\tif (swiper.params.navigation.hideOnClick && !prevEl.includes(targetEl) && !nextEl.includes(targetEl)) {\n\t\t\t\tif (swiper.pagination && swiper.params.pagination && swiper.params.pagination.clickable && (swiper.pagination.el === targetEl || swiper.pagination.el.contains(targetEl))) return;\n\t\t\t\tlet isHidden;\n\t\t\t\tif (nextEl.length) {\n\t\t\t\t\tisHidden = nextEl[0].classList.contains(swiper.params.navigation.hiddenClass);\n\t\t\t\t} else if (prevEl.length) {\n\t\t\t\t\tisHidden = prevEl[0].classList.contains(swiper.params.navigation.hiddenClass);\n\t\t\t\t}\n\t\t\t\tif (isHidden === true) {\n\t\t\t\t\temit('navigationShow');\n\t\t\t\t} else {\n\t\t\t\t\temit('navigationHide');\n\t\t\t\t}\n\t\t\t\t[...nextEl, ...prevEl].filter(el => !!el).forEach(el => el.classList.toggle(swiper.params.navigation.hiddenClass));\n\t\t\t}\n\t\t});\n\t\tconst enable = () => {\n\t\t\tswiper.el.classList.remove(...swiper.params.navigation.navigationDisabledClass.split(' '));\n\t\t\tinit();\n\t\t\tupdate();\n\t\t};\n\t\tconst disable = () => {\n\t\t\tswiper.el.classList.add(...swiper.params.navigation.navigationDisabledClass.split(' '));\n\t\t\tdestroy();\n\t\t};\n\t\tObject.assign(swiper.navigation, {\n\t\t\tenable,\n\t\t\tdisable,\n\t\t\tupdate,\n\t\t\tinit,\n\t\t\tdestroy\n\t\t});\n\t}\n\n\tfunction classesToSelector(classes) {\n\t\tif (classes === void 0) {\n\t\t\tclasses = '';\n\t\t}\n\t\treturn `.${classes.trim().replace(/([\\.:!+\\/])/g, '\\\\$1') // eslint-disable-line\n\t\t\t.replace(/ /g, '.')}`;\n\t}\n\n\tfunction Pagination(_ref) {\n\t\tlet {\n\t\t\tswiper,\n\t\t\textendParams,\n\t\t\ton,\n\t\t\temit\n\t\t} = _ref;\n\t\tconst pfx = 'swiper-pagination';\n\t\textendParams({\n\t\t\tpagination: {\n\t\t\t\tel: null,\n\t\t\t\tbulletElement: 'span',\n\t\t\t\tclickable: false,\n\t\t\t\thideOnClick: false,\n\t\t\t\trenderBullet: null,\n\t\t\t\trenderProgressbar: null,\n\t\t\t\trenderFraction: null,\n\t\t\t\trenderCustom: null,\n\t\t\t\tprogressbarOpposite: false,\n\t\t\t\ttype: 'bullets',\n\t\t\t\t// 'bullets' or 'progressbar' or 'fraction' or 'custom'\n\t\t\t\tdynamicBullets: false,\n\t\t\t\tdynamicMainBullets: 1,\n\t\t\t\tformatFractionCurrent: number => number,\n\t\t\t\tformatFractionTotal: number => number,\n\t\t\t\tbulletClass: `${pfx}-bullet`,\n\t\t\t\tbulletActiveClass: `${pfx}-bullet-active`,\n\t\t\t\tmodifierClass: `${pfx}-`,\n\t\t\t\tcurrentClass: `${pfx}-current`,\n\t\t\t\ttotalClass: `${pfx}-total`,\n\t\t\t\thiddenClass: `${pfx}-hidden`,\n\t\t\t\tprogressbarFillClass: `${pfx}-progressbar-fill`,\n\t\t\t\tprogressbarOppositeClass: `${pfx}-progressbar-opposite`,\n\t\t\t\tclickableClass: `${pfx}-clickable`,\n\t\t\t\tlockClass: `${pfx}-lock`,\n\t\t\t\thorizontalClass: `${pfx}-horizontal`,\n\t\t\t\tverticalClass: `${pfx}-vertical`,\n\t\t\t\tpaginationDisabledClass: `${pfx}-disabled`\n\t\t\t}\n\t\t});\n\t\tswiper.pagination = {\n\t\t\tel: null,\n\t\t\tbullets: []\n\t\t};\n\t\tlet bulletSize;\n\t\tlet dynamicBulletIndex = 0;\n\t\tconst makeElementsArray = el => (Array.isArray(el) ? el : [el]).filter(e => !!e);\n\t\tfunction isPaginationDisabled() {\n\t\t\treturn !swiper.params.pagination.el || !swiper.pagination.el || Array.isArray(swiper.pagination.el) && swiper.pagination.el.length === 0;\n\t\t}\n\t\tfunction setSideBullets(bulletEl, position) {\n\t\t\tconst {\n\t\t\t\tbulletActiveClass\n\t\t\t} = swiper.params.pagination;\n\t\t\tif (!bulletEl) return;\n\t\t\tbulletEl = bulletEl[`${position === 'prev' ? 'previous' : 'next'}ElementSibling`];\n\t\t\tif (bulletEl) {\n\t\t\t\tbulletEl.classList.add(`${bulletActiveClass}-${position}`);\n\t\t\t\tbulletEl = bulletEl[`${position === 'prev' ? 'previous' : 'next'}ElementSibling`];\n\t\t\t\tif (bulletEl) {\n\t\t\t\t\tbulletEl.classList.add(`${bulletActiveClass}-${position}-${position}`);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfunction onBulletClick(e) {\n\t\t\tconst bulletEl = e.target.closest(classesToSelector(swiper.params.pagination.bulletClass));\n\t\t\tif (!bulletEl) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\te.preventDefault();\n\t\t\tconst index = elementIndex(bulletEl) * swiper.params.slidesPerGroup;\n\t\t\tif (swiper.params.loop) {\n\t\t\t\tif (swiper.realIndex === index) return;\n\t\t\t\tconst realIndex = swiper.realIndex;\n\t\t\t\tconst newSlideIndex = swiper.getSlideIndexByData(index);\n\t\t\t\tconst currentSlideIndex = swiper.getSlideIndexByData(swiper.realIndex);\n\t\t\t\tif (newSlideIndex > swiper.slides.length - swiper.loopedSlides) {\n\t\t\t\t\tconst indexBeforeLoopFix = swiper.activeIndex;\n\t\t\t\t\tswiper.loopFix({\n\t\t\t\t\t\tdirection: newSlideIndex > currentSlideIndex ? 'next' : 'prev',\n\t\t\t\t\t\tactiveSlideIndex: newSlideIndex,\n\t\t\t\t\t\tslideTo: false\n\t\t\t\t\t});\n\t\t\t\t\tconst indexAfterFix = swiper.activeIndex;\n\t\t\t\t\tif (indexBeforeLoopFix === indexAfterFix) {\n\t\t\t\t\t\tswiper.slideToLoop(realIndex, 0, false, true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tswiper.slideToLoop(index);\n\t\t\t} else {\n\t\t\t\tswiper.slideTo(index);\n\t\t\t}\n\t\t}\n\t\tfunction update() {\n\t\t\t// Render || Update Pagination bullets/items\n\t\t\tconst rtl = swiper.rtl;\n\t\t\tconst params = swiper.params.pagination;\n\t\t\tif (isPaginationDisabled()) return;\n\t\t\tlet el = swiper.pagination.el;\n\t\t\tel = makeElementsArray(el);\n\t\t\t// Current/Total\n\t\t\tlet current;\n\t\t\tlet previousIndex;\n\t\t\tconst slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;\n\t\t\tconst total = swiper.params.loop ? Math.ceil(slidesLength / swiper.params.slidesPerGroup) : swiper.snapGrid.length;\n\t\t\tif (swiper.params.loop) {\n\t\t\t\tpreviousIndex = swiper.previousRealIndex || 0;\n\t\t\t\tcurrent = swiper.params.slidesPerGroup > 1 ? Math.floor(swiper.realIndex / swiper.params.slidesPerGroup) : swiper.realIndex;\n\t\t\t} else if (typeof swiper.snapIndex !== 'undefined') {\n\t\t\t\tcurrent = swiper.snapIndex;\n\t\t\t\tpreviousIndex = swiper.previousSnapIndex;\n\t\t\t} else {\n\t\t\t\tpreviousIndex = swiper.previousIndex || 0;\n\t\t\t\tcurrent = swiper.activeIndex || 0;\n\t\t\t}\n\t\t\t// Types\n\t\t\tif (params.type === 'bullets' && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {\n\t\t\t\tconst bullets = swiper.pagination.bullets;\n\t\t\t\tlet firstIndex;\n\t\t\t\tlet lastIndex;\n\t\t\t\tlet midIndex;\n\t\t\t\tif (params.dynamicBullets) {\n\t\t\t\t\tbulletSize = elementOuterSize(bullets[0], swiper.isHorizontal() ? 'width' : 'height', true);\n\t\t\t\t\tel.forEach(subEl => {\n\t\t\t\t\t\tsubEl.style[swiper.isHorizontal() ? 'width' : 'height'] = `${bulletSize * (params.dynamicMainBullets + 4)}px`;\n\t\t\t\t\t});\n\t\t\t\t\tif (params.dynamicMainBullets > 1 && previousIndex !== undefined) {\n\t\t\t\t\t\tdynamicBulletIndex += current - (previousIndex || 0);\n\t\t\t\t\t\tif (dynamicBulletIndex > params.dynamicMainBullets - 1) {\n\t\t\t\t\t\t\tdynamicBulletIndex = params.dynamicMainBullets - 1;\n\t\t\t\t\t\t} else if (dynamicBulletIndex < 0) {\n\t\t\t\t\t\t\tdynamicBulletIndex = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfirstIndex = Math.max(current - dynamicBulletIndex, 0);\n\t\t\t\t\tlastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);\n\t\t\t\t\tmidIndex = (lastIndex + firstIndex) / 2;\n\t\t\t\t}\n\t\t\t\tbullets.forEach(bulletEl => {\n\t\t\t\t\tconst classesToRemove = [...['', '-next', '-next-next', '-prev', '-prev-prev', '-main'].map(suffix => `${params.bulletActiveClass}${suffix}`)].map(s => typeof s === 'string' && s.includes(' ') ? s.split(' ') : s).flat();\n\t\t\t\t\tbulletEl.classList.remove(...classesToRemove);\n\t\t\t\t});\n\t\t\t\tif (el.length > 1) {\n\t\t\t\t\tbullets.forEach(bullet => {\n\t\t\t\t\t\tconst bulletIndex = elementIndex(bullet);\n\t\t\t\t\t\tif (bulletIndex === current) {\n\t\t\t\t\t\t\tbullet.classList.add(...params.bulletActiveClass.split(' '));\n\t\t\t\t\t\t} else if (swiper.isElement) {\n\t\t\t\t\t\t\tbullet.setAttribute('part', 'bullet');\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (params.dynamicBullets) {\n\t\t\t\t\t\t\tif (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {\n\t\t\t\t\t\t\t\tbullet.classList.add(...`${params.bulletActiveClass}-main`.split(' '));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (bulletIndex === firstIndex) {\n\t\t\t\t\t\t\t\tsetSideBullets(bullet, 'prev');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (bulletIndex === lastIndex) {\n\t\t\t\t\t\t\t\tsetSideBullets(bullet, 'next');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tconst bullet = bullets[current];\n\t\t\t\t\tif (bullet) {\n\t\t\t\t\t\tbullet.classList.add(...params.bulletActiveClass.split(' '));\n\t\t\t\t\t}\n\t\t\t\t\tif (swiper.isElement) {\n\t\t\t\t\t\tbullets.forEach((bulletEl, bulletIndex) => {\n\t\t\t\t\t\t\tbulletEl.setAttribute('part', bulletIndex === current ? 'bullet-active' : 'bullet');\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tif (params.dynamicBullets) {\n\t\t\t\t\t\tconst firstDisplayedBullet = bullets[firstIndex];\n\t\t\t\t\t\tconst lastDisplayedBullet = bullets[lastIndex];\n\t\t\t\t\t\tfor (let i = firstIndex; i <= lastIndex; i += 1) {\n\t\t\t\t\t\t\tif (bullets[i]) {\n\t\t\t\t\t\t\t\tbullets[i].classList.add(...`${params.bulletActiveClass}-main`.split(' '));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsetSideBullets(firstDisplayedBullet, 'prev');\n\t\t\t\t\t\tsetSideBullets(lastDisplayedBullet, 'next');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (params.dynamicBullets) {\n\t\t\t\t\tconst dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);\n\t\t\t\t\tconst bulletsOffset = (bulletSize * dynamicBulletsLength - bulletSize) / 2 - midIndex * bulletSize;\n\t\t\t\t\tconst offsetProp = rtl ? 'right' : 'left';\n\t\t\t\t\tbullets.forEach(bullet => {\n\t\t\t\t\t\tbullet.style[swiper.isHorizontal() ? offsetProp : 'top'] = `${bulletsOffset}px`;\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\tel.forEach((subEl, subElIndex) => {\n\t\t\t\tif (params.type === 'fraction') {\n\t\t\t\t\tsubEl.querySelectorAll(classesToSelector(params.currentClass)).forEach(fractionEl => {\n\t\t\t\t\t\tfractionEl.textContent = params.formatFractionCurrent(current + 1);\n\t\t\t\t\t});\n\t\t\t\t\tsubEl.querySelectorAll(classesToSelector(params.totalClass)).forEach(totalEl => {\n\t\t\t\t\t\ttotalEl.textContent = params.formatFractionTotal(total);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tif (params.type === 'progressbar') {\n\t\t\t\t\tlet progressbarDirection;\n\t\t\t\t\tif (params.progressbarOpposite) {\n\t\t\t\t\t\tprogressbarDirection = swiper.isHorizontal() ? 'vertical' : 'horizontal';\n\t\t\t\t\t} else {\n\t\t\t\t\t\tprogressbarDirection = swiper.isHorizontal() ? 'horizontal' : 'vertical';\n\t\t\t\t\t}\n\t\t\t\t\tconst scale = (current + 1) / total;\n\t\t\t\t\tlet scaleX = 1;\n\t\t\t\t\tlet scaleY = 1;\n\t\t\t\t\tif (progressbarDirection === 'horizontal') {\n\t\t\t\t\t\tscaleX = scale;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tscaleY = scale;\n\t\t\t\t\t}\n\t\t\t\t\tsubEl.querySelectorAll(classesToSelector(params.progressbarFillClass)).forEach(progressEl => {\n\t\t\t\t\t\tprogressEl.style.transform = `translate3d(0,0,0) scaleX(${scaleX}) scaleY(${scaleY})`;\n\t\t\t\t\t\tprogressEl.style.transitionDuration = `${swiper.params.speed}ms`;\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tif (params.type === 'custom' && params.renderCustom) {\n\t\t\t\t\tsubEl.innerHTML = params.renderCustom(swiper, current + 1, total);\n\t\t\t\t\tif (subElIndex === 0) emit('paginationRender', subEl);\n\t\t\t\t} else {\n\t\t\t\t\tif (subElIndex === 0) emit('paginationRender', subEl);\n\t\t\t\t\temit('paginationUpdate', subEl);\n\t\t\t\t}\n\t\t\t\tif (swiper.params.watchOverflow && swiper.enabled) {\n\t\t\t\t\tsubEl.classList[swiper.isLocked ? 'add' : 'remove'](params.lockClass);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tfunction render() {\n\t\t\t// Render Container\n\t\t\tconst params = swiper.params.pagination;\n\t\t\tif (isPaginationDisabled()) return;\n\t\t\tconst slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;\n\t\t\tlet el = swiper.pagination.el;\n\t\t\tel = makeElementsArray(el);\n\t\t\tlet paginationHTML = '';\n\t\t\tif (params.type === 'bullets') {\n\t\t\t\tlet numberOfBullets = swiper.params.loop ? Math.ceil(slidesLength / swiper.params.slidesPerGroup) : swiper.snapGrid.length;\n\t\t\t\tif (swiper.params.freeMode && swiper.params.freeMode.enabled && numberOfBullets > slidesLength) {\n\t\t\t\t\tnumberOfBullets = slidesLength;\n\t\t\t\t}\n\t\t\t\tfor (let i = 0; i < numberOfBullets; i += 1) {\n\t\t\t\t\tif (params.renderBullet) {\n\t\t\t\t\t\tpaginationHTML += params.renderBullet.call(swiper, i, params.bulletClass);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// prettier-ignore\n\t\t\t\t\t\tpaginationHTML += `<${params.bulletElement} ${swiper.isElement ? 'part=\"bullet\"' : ''} class=\"${params.bulletClass}\"></${params.bulletElement}>`;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (params.type === 'fraction') {\n\t\t\t\tif (params.renderFraction) {\n\t\t\t\t\tpaginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);\n\t\t\t\t} else {\n\t\t\t\t\tpaginationHTML = `<span class=\"${params.currentClass}\"></span>` + ' / ' + `<span class=\"${params.totalClass}\"></span>`;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (params.type === 'progressbar') {\n\t\t\t\tif (params.renderProgressbar) {\n\t\t\t\t\tpaginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);\n\t\t\t\t} else {\n\t\t\t\t\tpaginationHTML = `<span class=\"${params.progressbarFillClass}\"></span>`;\n\t\t\t\t}\n\t\t\t}\n\t\t\tswiper.pagination.bullets = [];\n\t\t\tel.forEach(subEl => {\n\t\t\t\tif (params.type !== 'custom') {\n\t\t\t\t\tsubEl.innerHTML = paginationHTML || '';\n\t\t\t\t}\n\t\t\t\tif (params.type === 'bullets') {\n\t\t\t\t\tswiper.pagination.bullets.push(...subEl.querySelectorAll(classesToSelector(params.bulletClass)));\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (params.type !== 'custom') {\n\t\t\t\temit('paginationRender', el[0]);\n\t\t\t}\n\t\t}\n\t\tfunction init() {\n\t\t\tswiper.params.pagination = createElementIfNotDefined(swiper, swiper.originalParams.pagination, swiper.params.pagination, {\n\t\t\t\tel: 'swiper-pagination'\n\t\t\t});\n\t\t\tconst params = swiper.params.pagination;\n\t\t\tif (!params.el) return;\n\t\t\tlet el;\n\t\t\tif (typeof params.el === 'string' && swiper.isElement) {\n\t\t\t\tel = swiper.el.querySelector(params.el);\n\t\t\t}\n\t\t\tif (!el && typeof params.el === 'string') {\n\t\t\t\tel = [...document.querySelectorAll(params.el)];\n\t\t\t}\n\t\t\tif (!el) {\n\t\t\t\tel = params.el;\n\t\t\t}\n\t\t\tif (!el || el.length === 0) return;\n\t\t\tif (swiper.params.uniqueNavElements && typeof params.el === 'string' && Array.isArray(el) && el.length > 1) {\n\t\t\t\tel = [...swiper.el.querySelectorAll(params.el)];\n\t\t\t\t// check if it belongs to another nested Swiper\n\t\t\t\tif (el.length > 1) {\n\t\t\t\t\tel = el.filter(subEl => {\n\t\t\t\t\t\tif (elementParents(subEl, '.swiper')[0] !== swiper.el) return false;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t})[0];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (Array.isArray(el) && el.length === 1) el = el[0];\n\t\t\tObject.assign(swiper.pagination, {\n\t\t\t\tel\n\t\t\t});\n\t\t\tel = makeElementsArray(el);\n\t\t\tel.forEach(subEl => {\n\t\t\t\tif (params.type === 'bullets' && params.clickable) {\n\t\t\t\t\tsubEl.classList.add(...(params.clickableClass || '').split(' '));\n\t\t\t\t}\n\t\t\t\tsubEl.classList.add(params.modifierClass + params.type);\n\t\t\t\tsubEl.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);\n\t\t\t\tif (params.type === 'bullets' && params.dynamicBullets) {\n\t\t\t\t\tsubEl.classList.add(`${params.modifierClass}${params.type}-dynamic`);\n\t\t\t\t\tdynamicBulletIndex = 0;\n\t\t\t\t\tif (params.dynamicMainBullets < 1) {\n\t\t\t\t\t\tparams.dynamicMainBullets = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (params.type === 'progressbar' && params.progressbarOpposite) {\n\t\t\t\t\tsubEl.classList.add(params.progressbarOppositeClass);\n\t\t\t\t}\n\t\t\t\tif (params.clickable) {\n\t\t\t\t\tsubEl.addEventListener('click', onBulletClick);\n\t\t\t\t}\n\t\t\t\tif (!swiper.enabled) {\n\t\t\t\t\tsubEl.classList.add(params.lockClass);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tfunction destroy() {\n\t\t\tconst params = swiper.params.pagination;\n\t\t\tif (isPaginationDisabled()) return;\n\t\t\tlet el = swiper.pagination.el;\n\t\t\tif (el) {\n\t\t\t\tel = makeElementsArray(el);\n\t\t\t\tel.forEach(subEl => {\n\t\t\t\t\tsubEl.classList.remove(params.hiddenClass);\n\t\t\t\t\tsubEl.classList.remove(params.modifierClass + params.type);\n\t\t\t\t\tsubEl.classList.remove(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);\n\t\t\t\t\tif (params.clickable) {\n\t\t\t\t\t\tsubEl.classList.remove(...(params.clickableClass || '').split(' '));\n\t\t\t\t\t\tsubEl.removeEventListener('click', onBulletClick);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\tif (swiper.pagination.bullets) swiper.pagination.bullets.forEach(subEl => subEl.classList.remove(...params.bulletActiveClass.split(' ')));\n\t\t}\n\t\ton('changeDirection', () => {\n\t\t\tif (!swiper.pagination || !swiper.pagination.el) return;\n\t\t\tconst params = swiper.params.pagination;\n\t\t\tlet {\n\t\t\t\tel\n\t\t\t} = swiper.pagination;\n\t\t\tel = makeElementsArray(el);\n\t\t\tel.forEach(subEl => {\n\t\t\t\tsubEl.classList.remove(params.horizontalClass, params.verticalClass);\n\t\t\t\tsubEl.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);\n\t\t\t});\n\t\t});\n\t\ton('init', () => {\n\t\t\tif (swiper.params.pagination.enabled === false) {\n\t\t\t\t// eslint-disable-next-line\n\t\t\t\tdisable();\n\t\t\t} else {\n\t\t\t\tinit();\n\t\t\t\trender();\n\t\t\t\tupdate();\n\t\t\t}\n\t\t});\n\t\ton('activeIndexChange', () => {\n\t\t\tif (typeof swiper.snapIndex === 'undefined') {\n\t\t\t\tupdate();\n\t\t\t}\n\t\t});\n\t\ton('snapIndexChange', () => {\n\t\t\tupdate();\n\t\t});\n\t\ton('snapGridLengthChange', () => {\n\t\t\trender();\n\t\t\tupdate();\n\t\t});\n\t\ton('destroy', () => {\n\t\t\tdestroy();\n\t\t});\n\t\ton('enable disable', () => {\n\t\t\tlet {\n\t\t\t\tel\n\t\t\t} = swiper.pagination;\n\t\t\tif (el) {\n\t\t\t\tel = makeElementsArray(el);\n\t\t\t\tel.forEach(subEl => subEl.classList[swiper.enabled ? 'remove' : 'add'](swiper.params.pagination.lockClass));\n\t\t\t}\n\t\t});\n\t\ton('lock unlock', () => {\n\t\t\tupdate();\n\t\t});\n\t\ton('click', (_s, e) => {\n\t\t\tconst targetEl = e.target;\n\t\t\tconst el = makeElementsArray(swiper.pagination.el);\n\t\t\tif (swiper.params.pagination.el && swiper.params.pagination.hideOnClick && el && el.length > 0 && !targetEl.classList.contains(swiper.params.pagination.bulletClass)) {\n\t\t\t\tif (swiper.navigation && (swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl || swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl)) return;\n\t\t\t\tconst isHidden = el[0].classList.contains(swiper.params.pagination.hiddenClass);\n\t\t\t\tif (isHidden === true) {\n\t\t\t\t\temit('paginationShow');\n\t\t\t\t} else {\n\t\t\t\t\temit('paginationHide');\n\t\t\t\t}\n\t\t\t\tel.forEach(subEl => subEl.classList.toggle(swiper.params.pagination.hiddenClass));\n\t\t\t}\n\t\t});\n\t\tconst enable = () => {\n\t\t\tswiper.el.classList.remove(swiper.params.pagination.paginationDisabledClass);\n\t\t\tlet {\n\t\t\t\tel\n\t\t\t} = swiper.pagination;\n\t\t\tif (el) {\n\t\t\t\tel = makeElementsArray(el);\n\t\t\t\tel.forEach(subEl => subEl.classList.remove(swiper.params.pagination.paginationDisabledClass));\n\t\t\t}\n\t\t\tinit();\n\t\t\trender();\n\t\t\tupdate();\n\t\t};\n\t\tconst disable = () => {\n\t\t\tswiper.el.classList.add(swiper.params.pagination.paginationDisabledClass);\n\t\t\tlet {\n\t\t\t\tel\n\t\t\t} = swiper.pagination;\n\t\t\tif (el) {\n\t\t\t\tel = makeElementsArray(el);\n\t\t\t\tel.forEach(subEl => subEl.classList.add(swiper.params.pagination.paginationDisabledClass));\n\t\t\t}\n\t\t\tdestroy();\n\t\t};\n\t\tObject.assign(swiper.pagination, {\n\t\t\tenable,\n\t\t\tdisable,\n\t\t\trender,\n\t\t\tupdate,\n\t\t\tinit,\n\t\t\tdestroy\n\t\t});\n\t}\n\n\tfunction Scrollbar(_ref) {\n\t\tlet {\n\t\t\tswiper,\n\t\t\textendParams,\n\t\t\ton,\n\t\t\temit\n\t\t} = _ref;\n\t\tconst document = getDocument();\n\t\tlet isTouched = false;\n\t\tlet timeout = null;\n\t\tlet dragTimeout = null;\n\t\tlet dragStartPos;\n\t\tlet dragSize;\n\t\tlet trackSize;\n\t\tlet divider;\n\t\textendParams({\n\t\t\tscrollbar: {\n\t\t\t\tel: null,\n\t\t\t\tdragSize: 'auto',\n\t\t\t\thide: false,\n\t\t\t\tdraggable: false,\n\t\t\t\tsnapOnRelease: true,\n\t\t\t\tlockClass: 'swiper-scrollbar-lock',\n\t\t\t\tdragClass: 'swiper-scrollbar-drag',\n\t\t\t\tscrollbarDisabledClass: 'swiper-scrollbar-disabled',\n\t\t\t\thorizontalClass: `swiper-scrollbar-horizontal`,\n\t\t\t\tverticalClass: `swiper-scrollbar-vertical`\n\t\t\t}\n\t\t});\n\t\tswiper.scrollbar = {\n\t\t\tel: null,\n\t\t\tdragEl: null\n\t\t};\n\t\tfunction setTranslate() {\n\t\t\tif (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n\t\t\tconst {\n\t\t\t\tscrollbar,\n\t\t\t\trtlTranslate: rtl\n\t\t\t} = swiper;\n\t\t\tconst {\n\t\t\t\tdragEl,\n\t\t\t\tel\n\t\t\t} = scrollbar;\n\t\t\tconst params = swiper.params.scrollbar;\n\t\t\tconst progress = swiper.params.loop ? swiper.progressLoop : swiper.progress;\n\t\t\tlet newSize = dragSize;\n\t\t\tlet newPos = (trackSize - dragSize) * progress;\n\t\t\tif (rtl) {\n\t\t\t\tnewPos = -newPos;\n\t\t\t\tif (newPos > 0) {\n\t\t\t\t\tnewSize = dragSize - newPos;\n\t\t\t\t\tnewPos = 0;\n\t\t\t\t} else if (-newPos + dragSize > trackSize) {\n\t\t\t\t\tnewSize = trackSize + newPos;\n\t\t\t\t}\n\t\t\t} else if (newPos < 0) {\n\t\t\t\tnewSize = dragSize + newPos;\n\t\t\t\tnewPos = 0;\n\t\t\t} else if (newPos + dragSize > trackSize) {\n\t\t\t\tnewSize = trackSize - newPos;\n\t\t\t}\n\t\t\tif (swiper.isHorizontal()) {\n\t\t\t\tdragEl.style.transform = `translate3d(${newPos}px, 0, 0)`;\n\t\t\t\tdragEl.style.width = `${newSize}px`;\n\t\t\t} else {\n\t\t\t\tdragEl.style.transform = `translate3d(0px, ${newPos}px, 0)`;\n\t\t\t\tdragEl.style.height = `${newSize}px`;\n\t\t\t}\n\t\t\tif (params.hide) {\n\t\t\t\tclearTimeout(timeout);\n\t\t\t\tel.style.opacity = 1;\n\t\t\t\ttimeout = setTimeout(() => {\n\t\t\t\t\tel.style.opacity = 0;\n\t\t\t\t\tel.style.transitionDuration = '400ms';\n\t\t\t\t}, 1000);\n\t\t\t}\n\t\t}\n\t\tfunction setTransition(duration) {\n\t\t\tif (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n\t\t\tswiper.scrollbar.dragEl.style.transitionDuration = `${duration}ms`;\n\t\t}\n\t\tfunction updateSize() {\n\t\t\tif (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n\t\t\tconst {\n\t\t\t\tscrollbar\n\t\t\t} = swiper;\n\t\t\tconst {\n\t\t\t\tdragEl,\n\t\t\t\tel\n\t\t\t} = scrollbar;\n\t\t\tdragEl.style.width = '';\n\t\t\tdragEl.style.height = '';\n\t\t\ttrackSize = swiper.isHorizontal() ? el.offsetWidth : el.offsetHeight;\n\t\t\tdivider = swiper.size / (swiper.virtualSize + swiper.params.slidesOffsetBefore - (swiper.params.centeredSlides ? swiper.snapGrid[0] : 0));\n\t\t\tif (swiper.params.scrollbar.dragSize === 'auto') {\n\t\t\t\tdragSize = trackSize * divider;\n\t\t\t} else {\n\t\t\t\tdragSize = parseInt(swiper.params.scrollbar.dragSize, 10);\n\t\t\t}\n\t\t\tif (swiper.isHorizontal()) {\n\t\t\t\tdragEl.style.width = `${dragSize}px`;\n\t\t\t} else {\n\t\t\t\tdragEl.style.height = `${dragSize}px`;\n\t\t\t}\n\t\t\tif (divider >= 1) {\n\t\t\t\tel.style.display = 'none';\n\t\t\t} else {\n\t\t\t\tel.style.display = '';\n\t\t\t}\n\t\t\tif (swiper.params.scrollbar.hide) {\n\t\t\t\tel.style.opacity = 0;\n\t\t\t}\n\t\t\tif (swiper.params.watchOverflow && swiper.enabled) {\n\t\t\t\tscrollbar.el.classList[swiper.isLocked ? 'add' : 'remove'](swiper.params.scrollbar.lockClass);\n\t\t\t}\n\t\t}\n\t\tfunction getPointerPosition(e) {\n\t\t\treturn swiper.isHorizontal() ? e.clientX : e.clientY;\n\t\t}\n\t\tfunction setDragPosition(e) {\n\t\t\tconst {\n\t\t\t\tscrollbar,\n\t\t\t\trtlTranslate: rtl\n\t\t\t} = swiper;\n\t\t\tconst {\n\t\t\t\tel\n\t\t\t} = scrollbar;\n\t\t\tlet positionRatio;\n\t\t\tpositionRatio = (getPointerPosition(e) - elementOffset(el)[swiper.isHorizontal() ? 'left' : 'top'] - (dragStartPos !== null ? dragStartPos : dragSize / 2)) / (trackSize - dragSize);\n\t\t\tpositionRatio = Math.max(Math.min(positionRatio, 1), 0);\n\t\t\tif (rtl) {\n\t\t\t\tpositionRatio = 1 - positionRatio;\n\t\t\t}\n\t\t\tconst position = swiper.minTranslate() + (swiper.maxTranslate() - swiper.minTranslate()) * positionRatio;\n\t\t\tswiper.updateProgress(position);\n\t\t\tswiper.setTranslate(position);\n\t\t\tswiper.updateActiveIndex();\n\t\t\tswiper.updateSlidesClasses();\n\t\t}\n\t\tfunction onDragStart(e) {\n\t\t\tconst params = swiper.params.scrollbar;\n\t\t\tconst {\n\t\t\t\tscrollbar,\n\t\t\t\twrapperEl\n\t\t\t} = swiper;\n\t\t\tconst {\n\t\t\t\tel,\n\t\t\t\tdragEl\n\t\t\t} = scrollbar;\n\t\t\tisTouched = true;\n\t\t\tdragStartPos = e.target === dragEl ? getPointerPosition(e) - e.target.getBoundingClientRect()[swiper.isHorizontal() ? 'left' : 'top'] : null;\n\t\t\te.preventDefault();\n\t\t\te.stopPropagation();\n\t\t\twrapperEl.style.transitionDuration = '100ms';\n\t\t\tdragEl.style.transitionDuration = '100ms';\n\t\t\tsetDragPosition(e);\n\t\t\tclearTimeout(dragTimeout);\n\t\t\tel.style.transitionDuration = '0ms';\n\t\t\tif (params.hide) {\n\t\t\t\tel.style.opacity = 1;\n\t\t\t}\n\t\t\tif (swiper.params.cssMode) {\n\t\t\t\tswiper.wrapperEl.style['scroll-snap-type'] = 'none';\n\t\t\t}\n\t\t\temit('scrollbarDragStart', e);\n\t\t}\n\t\tfunction onDragMove(e) {\n\t\t\tconst {\n\t\t\t\tscrollbar,\n\t\t\t\twrapperEl\n\t\t\t} = swiper;\n\t\t\tconst {\n\t\t\t\tel,\n\t\t\t\tdragEl\n\t\t\t} = scrollbar;\n\t\t\tif (!isTouched) return;\n\t\t\tif (e.preventDefault) e.preventDefault(); else e.returnValue = false;\n\t\t\tsetDragPosition(e);\n\t\t\twrapperEl.style.transitionDuration = '0ms';\n\t\t\tel.style.transitionDuration = '0ms';\n\t\t\tdragEl.style.transitionDuration = '0ms';\n\t\t\temit('scrollbarDragMove', e);\n\t\t}\n\t\tfunction onDragEnd(e) {\n\t\t\tconst params = swiper.params.scrollbar;\n\t\t\tconst {\n\t\t\t\tscrollbar,\n\t\t\t\twrapperEl\n\t\t\t} = swiper;\n\t\t\tconst {\n\t\t\t\tel\n\t\t\t} = scrollbar;\n\t\t\tif (!isTouched) return;\n\t\t\tisTouched = false;\n\t\t\tif (swiper.params.cssMode) {\n\t\t\t\tswiper.wrapperEl.style['scroll-snap-type'] = '';\n\t\t\t\twrapperEl.style.transitionDuration = '';\n\t\t\t}\n\t\t\tif (params.hide) {\n\t\t\t\tclearTimeout(dragTimeout);\n\t\t\t\tdragTimeout = nextTick(() => {\n\t\t\t\t\tel.style.opacity = 0;\n\t\t\t\t\tel.style.transitionDuration = '400ms';\n\t\t\t\t}, 1000);\n\t\t\t}\n\t\t\temit('scrollbarDragEnd', e);\n\t\t\tif (params.snapOnRelease) {\n\t\t\t\tswiper.slideToClosest();\n\t\t\t}\n\t\t}\n\t\tfunction events(method) {\n\t\t\tconst {\n\t\t\t\tscrollbar,\n\t\t\t\tparams\n\t\t\t} = swiper;\n\t\t\tconst el = scrollbar.el;\n\t\t\tif (!el) return;\n\t\t\tconst target = el;\n\t\t\tconst activeListener = params.passiveListeners ? {\n\t\t\t\tpassive: false,\n\t\t\t\tcapture: false\n\t\t\t} : false;\n\t\t\tconst passiveListener = params.passiveListeners ? {\n\t\t\t\tpassive: true,\n\t\t\t\tcapture: false\n\t\t\t} : false;\n\t\t\tif (!target) return;\n\t\t\tconst eventMethod = method === 'on' ? 'addEventListener' : 'removeEventListener';\n\t\t\ttarget[eventMethod]('pointerdown', onDragStart, activeListener);\n\t\t\tdocument[eventMethod]('pointermove', onDragMove, activeListener);\n\t\t\tdocument[eventMethod]('pointerup', onDragEnd, passiveListener);\n\t\t}\n\t\tfunction enableDraggable() {\n\t\t\tif (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n\t\t\tevents('on');\n\t\t}\n\t\tfunction disableDraggable() {\n\t\t\tif (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n\t\t\tevents('off');\n\t\t}\n\t\tfunction init() {\n\t\t\tconst {\n\t\t\t\tscrollbar,\n\t\t\t\tel: swiperEl\n\t\t\t} = swiper;\n\t\t\tswiper.params.scrollbar = createElementIfNotDefined(swiper, swiper.originalParams.scrollbar, swiper.params.scrollbar, {\n\t\t\t\tel: 'swiper-scrollbar'\n\t\t\t});\n\t\t\tconst params = swiper.params.scrollbar;\n\t\t\tif (!params.el) return;\n\t\t\tlet el;\n\t\t\tif (typeof params.el === 'string' && swiper.isElement) {\n\t\t\t\tel = swiper.el.querySelector(params.el);\n\t\t\t}\n\t\t\tif (!el && typeof params.el === 'string') {\n\t\t\t\tel = document.querySelectorAll(params.el);\n\t\t\t} else if (!el) {\n\t\t\t\tel = params.el;\n\t\t\t}\n\t\t\tif (swiper.params.uniqueNavElements && typeof params.el === 'string' && el.length > 1 && swiperEl.querySelectorAll(params.el).length === 1) {\n\t\t\t\tel = swiperEl.querySelector(params.el);\n\t\t\t}\n\t\t\tif (el.length > 0) el = el[0];\n\t\t\tel.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);\n\t\t\tlet dragEl;\n\t\t\tif (el) {\n\t\t\t\tdragEl = el.querySelector(`.${swiper.params.scrollbar.dragClass}`);\n\t\t\t\tif (!dragEl) {\n\t\t\t\t\tdragEl = createElement('div', swiper.params.scrollbar.dragClass);\n\t\t\t\t\tel.append(dragEl);\n\t\t\t\t}\n\t\t\t}\n\t\t\tObject.assign(scrollbar, {\n\t\t\t\tel,\n\t\t\t\tdragEl\n\t\t\t});\n\t\t\tif (params.draggable) {\n\t\t\t\tenableDraggable();\n\t\t\t}\n\t\t\tif (el) {\n\t\t\t\tel.classList[swiper.enabled ? 'remove' : 'add'](swiper.params.scrollbar.lockClass);\n\t\t\t}\n\t\t}\n\t\tfunction destroy() {\n\t\t\tconst params = swiper.params.scrollbar;\n\t\t\tconst el = swiper.scrollbar.el;\n\t\t\tif (el) {\n\t\t\t\tel.classList.remove(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);\n\t\t\t}\n\t\t\tdisableDraggable();\n\t\t}\n\t\ton('init', () => {\n\t\t\tif (swiper.params.scrollbar.enabled === false) {\n\t\t\t\t// eslint-disable-next-line\n\t\t\t\tdisable();\n\t\t\t} else {\n\t\t\t\tinit();\n\t\t\t\tupdateSize();\n\t\t\t\tsetTranslate();\n\t\t\t}\n\t\t});\n\t\ton('update resize observerUpdate lock unlock', () => {\n\t\t\tupdateSize();\n\t\t});\n\t\ton('setTranslate', () => {\n\t\t\tsetTranslate();\n\t\t});\n\t\ton('setTransition', (_s, duration) => {\n\t\t\tsetTransition(duration);\n\t\t});\n\t\ton('enable disable', () => {\n\t\t\tconst {\n\t\t\t\tel\n\t\t\t} = swiper.scrollbar;\n\t\t\tif (el) {\n\t\t\t\tel.classList[swiper.enabled ? 'remove' : 'add'](swiper.params.scrollbar.lockClass);\n\t\t\t}\n\t\t});\n\t\ton('destroy', () => {\n\t\t\tdestroy();\n\t\t});\n\t\tconst enable = () => {\n\t\t\tswiper.el.classList.remove(swiper.params.scrollbar.scrollbarDisabledClass);\n\t\t\tif (swiper.scrollbar.el) {\n\t\t\t\tswiper.scrollbar.el.classList.remove(swiper.params.scrollbar.scrollbarDisabledClass);\n\t\t\t}\n\t\t\tinit();\n\t\t\tupdateSize();\n\t\t\tsetTranslate();\n\t\t};\n\t\tconst disable = () => {\n\t\t\tswiper.el.classList.add(swiper.params.scrollbar.scrollbarDisabledClass);\n\t\t\tif (swiper.scrollbar.el) {\n\t\t\t\tswiper.scrollbar.el.classList.add(swiper.params.scrollbar.scrollbarDisabledClass);\n\t\t\t}\n\t\t\tdestroy();\n\t\t};\n\t\tObject.assign(swiper.scrollbar, {\n\t\t\tenable,\n\t\t\tdisable,\n\t\t\tupdateSize,\n\t\t\tsetTranslate,\n\t\t\tinit,\n\t\t\tdestroy\n\t\t});\n\t}\n\n\tfunction Parallax(_ref) {\n\t\tlet {\n\t\t\tswiper,\n\t\t\textendParams,\n\t\t\ton\n\t\t} = _ref;\n\t\textendParams({\n\t\t\tparallax: {\n\t\t\t\tenabled: false\n\t\t\t}\n\t\t});\n\t\tconst elementsSelector = '[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]';\n\t\tconst setTransform = (el, progress) => {\n\t\t\tconst {\n\t\t\t\trtl\n\t\t\t} = swiper;\n\t\t\tconst rtlFactor = rtl ? -1 : 1;\n\t\t\tconst p = el.getAttribute('data-swiper-parallax') || '0';\n\t\t\tlet x = el.getAttribute('data-swiper-parallax-x');\n\t\t\tlet y = el.getAttribute('data-swiper-parallax-y');\n\t\t\tconst scale = el.getAttribute('data-swiper-parallax-scale');\n\t\t\tconst opacity = el.getAttribute('data-swiper-parallax-opacity');\n\t\t\tconst rotate = el.getAttribute('data-swiper-parallax-rotate');\n\t\t\tif (x || y) {\n\t\t\t\tx = x || '0';\n\t\t\t\ty = y || '0';\n\t\t\t} else if (swiper.isHorizontal()) {\n\t\t\t\tx = p;\n\t\t\t\ty = '0';\n\t\t\t} else {\n\t\t\t\ty = p;\n\t\t\t\tx = '0';\n\t\t\t}\n\t\t\tif (x.indexOf('%') >= 0) {\n\t\t\t\tx = `${parseInt(x, 10) * progress * rtlFactor}%`;\n\t\t\t} else {\n\t\t\t\tx = `${x * progress * rtlFactor}px`;\n\t\t\t}\n\t\t\tif (y.indexOf('%') >= 0) {\n\t\t\t\ty = `${parseInt(y, 10) * progress}%`;\n\t\t\t} else {\n\t\t\t\ty = `${y * progress}px`;\n\t\t\t}\n\t\t\tif (typeof opacity !== 'undefined' && opacity !== null) {\n\t\t\t\tconst currentOpacity = opacity - (opacity - 1) * (1 - Math.abs(progress));\n\t\t\t\tel.style.opacity = currentOpacity;\n\t\t\t}\n\t\t\tlet transform = `translate3d(${x}, ${y}, 0px)`;\n\t\t\tif (typeof scale !== 'undefined' && scale !== null) {\n\t\t\t\tconst currentScale = scale - (scale - 1) * (1 - Math.abs(progress));\n\t\t\t\ttransform += ` scale(${currentScale})`;\n\t\t\t}\n\t\t\tif (rotate && typeof rotate !== 'undefined' && rotate !== null) {\n\t\t\t\tconst currentRotate = rotate * progress * -1;\n\t\t\t\ttransform += ` rotate(${currentRotate}deg)`;\n\t\t\t}\n\t\t\tel.style.transform = transform;\n\t\t};\n\t\tconst setTranslate = () => {\n\t\t\tconst {\n\t\t\t\tel,\n\t\t\t\tslides,\n\t\t\t\tprogress,\n\t\t\t\tsnapGrid,\n\t\t\t\tisElement\n\t\t\t} = swiper;\n\t\t\tconst elements = elementChildren(el, elementsSelector);\n\t\t\tif (swiper.isElement) {\n\t\t\t\telements.push(...elementChildren(swiper.hostEl, elementsSelector));\n\t\t\t}\n\t\t\telements.forEach(subEl => {\n\t\t\t\tsetTransform(subEl, progress);\n\t\t\t});\n\t\t\tslides.forEach((slideEl, slideIndex) => {\n\t\t\t\tlet slideProgress = slideEl.progress;\n\t\t\t\tif (swiper.params.slidesPerGroup > 1 && swiper.params.slidesPerView !== 'auto') {\n\t\t\t\t\tslideProgress += Math.ceil(slideIndex / 2) - progress * (snapGrid.length - 1);\n\t\t\t\t}\n\t\t\t\tslideProgress = Math.min(Math.max(slideProgress, -1), 1);\n\t\t\t\tslideEl.querySelectorAll(`${elementsSelector}, [data-swiper-parallax-rotate]`).forEach(subEl => {\n\t\t\t\t\tsetTransform(subEl, slideProgress);\n\t\t\t\t});\n\t\t\t});\n\t\t};\n\t\tconst setTransition = function (duration) {\n\t\t\tif (duration === void 0) {\n\t\t\t\tduration = swiper.params.speed;\n\t\t\t}\n\t\t\tconst {\n\t\t\t\tel,\n\t\t\t\thostEl\n\t\t\t} = swiper;\n\t\t\tconst elements = [...el.querySelectorAll(elementsSelector)];\n\t\t\tif (swiper.isElement) {\n\t\t\t\telements.push(...hostEl.querySelectorAll(elementsSelector));\n\t\t\t}\n\t\t\telements.forEach(parallaxEl => {\n\t\t\t\tlet parallaxDuration = parseInt(parallaxEl.getAttribute('data-swiper-parallax-duration'), 10) || duration;\n\t\t\t\tif (duration === 0) parallaxDuration = 0;\n\t\t\t\tparallaxEl.style.transitionDuration = `${parallaxDuration}ms`;\n\t\t\t});\n\t\t};\n\t\ton('beforeInit', () => {\n\t\t\tif (!swiper.params.parallax.enabled) return;\n\t\t\tswiper.params.watchSlidesProgress = true;\n\t\t\tswiper.originalParams.watchSlidesProgress = true;\n\t\t});\n\t\ton('init', () => {\n\t\t\tif (!swiper.params.parallax.enabled) return;\n\t\t\tsetTranslate();\n\t\t});\n\t\ton('setTranslate', () => {\n\t\t\tif (!swiper.params.parallax.enabled) return;\n\t\t\tsetTranslate();\n\t\t});\n\t\ton('setTransition', (_swiper, duration) => {\n\t\t\tif (!swiper.params.parallax.enabled) return;\n\t\t\tsetTransition(duration);\n\t\t});\n\t}\n\n\tfunction Zoom(_ref) {\n\t\tlet {\n\t\t\tswiper,\n\t\t\textendParams,\n\t\t\ton,\n\t\t\temit\n\t\t} = _ref;\n\t\tconst window = getWindow();\n\t\textendParams({\n\t\t\tzoom: {\n\t\t\t\tenabled: false,\n\t\t\t\tmaxRatio: 3,\n\t\t\t\tminRatio: 1,\n\t\t\t\ttoggle: true,\n\t\t\t\tcontainerClass: 'swiper-zoom-container',\n\t\t\t\tzoomedSlideClass: 'swiper-slide-zoomed'\n\t\t\t}\n\t\t});\n\t\tswiper.zoom = {\n\t\t\tenabled: false\n\t\t};\n\t\tlet currentScale = 1;\n\t\tlet isScaling = false;\n\t\tlet fakeGestureTouched;\n\t\tlet fakeGestureMoved;\n\t\tconst evCache = [];\n\t\tconst gesture = {\n\t\t\toriginX: 0,\n\t\t\toriginY: 0,\n\t\t\tslideEl: undefined,\n\t\t\tslideWidth: undefined,\n\t\t\tslideHeight: undefined,\n\t\t\timageEl: undefined,\n\t\t\timageWrapEl: undefined,\n\t\t\tmaxRatio: 3\n\t\t};\n\t\tconst image = {\n\t\t\tisTouched: undefined,\n\t\t\tisMoved: undefined,\n\t\t\tcurrentX: undefined,\n\t\t\tcurrentY: undefined,\n\t\t\tminX: undefined,\n\t\t\tminY: undefined,\n\t\t\tmaxX: undefined,\n\t\t\tmaxY: undefined,\n\t\t\twidth: undefined,\n\t\t\theight: undefined,\n\t\t\tstartX: undefined,\n\t\t\tstartY: undefined,\n\t\t\ttouchesStart: {},\n\t\t\ttouchesCurrent: {}\n\t\t};\n\t\tconst velocity = {\n\t\t\tx: undefined,\n\t\t\ty: undefined,\n\t\t\tprevPositionX: undefined,\n\t\t\tprevPositionY: undefined,\n\t\t\tprevTime: undefined\n\t\t};\n\t\tlet scale = 1;\n\t\tObject.defineProperty(swiper.zoom, 'scale', {\n\t\t\tget() {\n\t\t\t\treturn scale;\n\t\t\t},\n\t\t\tset(value) {\n\t\t\t\tif (scale !== value) {\n\t\t\t\t\tconst imageEl = gesture.imageEl;\n\t\t\t\t\tconst slideEl = gesture.slideEl;\n\t\t\t\t\temit('zoomChange', value, imageEl, slideEl);\n\t\t\t\t}\n\t\t\t\tscale = value;\n\t\t\t}\n\t\t});\n\t\tfunction getDistanceBetweenTouches() {\n\t\t\tif (evCache.length < 2) return 1;\n\t\t\tconst x1 = evCache[0].pageX;\n\t\t\tconst y1 = evCache[0].pageY;\n\t\t\tconst x2 = evCache[1].pageX;\n\t\t\tconst y2 = evCache[1].pageY;\n\t\t\tconst distance = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);\n\t\t\treturn distance;\n\t\t}\n\t\tfunction getScaleOrigin() {\n\t\t\tif (evCache.length < 2) return {\n\t\t\t\tx: null,\n\t\t\t\ty: null\n\t\t\t};\n\t\t\tconst box = gesture.imageEl.getBoundingClientRect();\n\t\t\treturn [(evCache[0].pageX + (evCache[1].pageX - evCache[0].pageX) / 2 - box.x) / currentScale, (evCache[0].pageY + (evCache[1].pageY - evCache[0].pageY) / 2 - box.y) / currentScale];\n\t\t}\n\t\tfunction getSlideSelector() {\n\t\t\treturn swiper.isElement ? `swiper-slide` : `.${swiper.params.slideClass}`;\n\t\t}\n\t\tfunction eventWithinSlide(e) {\n\t\t\tconst slideSelector = getSlideSelector();\n\t\t\tif (e.target.matches(slideSelector)) return true;\n\t\t\tif (swiper.slides.filter(slideEl => slideEl.contains(e.target)).length > 0) return true;\n\t\t\treturn false;\n\t\t}\n\t\tfunction eventWithinZoomContainer(e) {\n\t\t\tconst selector = `.${swiper.params.zoom.containerClass}`;\n\t\t\tif (e.target.matches(selector)) return true;\n\t\t\tif ([...swiper.hostEl.querySelectorAll(selector)].filter(containerEl => containerEl.contains(e.target)).length > 0) return true;\n\t\t\treturn false;\n\t\t}\n\n\t\t// Events\n\t\tfunction onGestureStart(e) {\n\t\t\tif (e.pointerType === 'mouse') {\n\t\t\t\tevCache.splice(0, evCache.length);\n\t\t\t}\n\t\t\tif (!eventWithinSlide(e)) return;\n\t\t\tconst params = swiper.params.zoom;\n\t\t\tfakeGestureTouched = false;\n\t\t\tfakeGestureMoved = false;\n\t\t\tevCache.push(e);\n\t\t\tif (evCache.length < 2) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfakeGestureTouched = true;\n\t\t\tgesture.scaleStart = getDistanceBetweenTouches();\n\t\t\tif (!gesture.slideEl) {\n\t\t\t\tgesture.slideEl = e.target.closest(`.${swiper.params.slideClass}, swiper-slide`);\n\t\t\t\tif (!gesture.slideEl) gesture.slideEl = swiper.slides[swiper.activeIndex];\n\t\t\t\tlet imageEl = gesture.slideEl.querySelector(`.${params.containerClass}`);\n\t\t\t\tif (imageEl) {\n\t\t\t\t\timageEl = imageEl.querySelectorAll('picture, img, svg, canvas, .swiper-zoom-target')[0];\n\t\t\t\t}\n\t\t\t\tgesture.imageEl = imageEl;\n\t\t\t\tif (imageEl) {\n\t\t\t\t\tgesture.imageWrapEl = elementParents(gesture.imageEl, `.${params.containerClass}`)[0];\n\t\t\t\t} else {\n\t\t\t\t\tgesture.imageWrapEl = undefined;\n\t\t\t\t}\n\t\t\t\tif (!gesture.imageWrapEl) {\n\t\t\t\t\tgesture.imageEl = undefined;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tgesture.maxRatio = gesture.imageWrapEl.getAttribute('data-swiper-zoom') || params.maxRatio;\n\t\t\t}\n\t\t\tif (gesture.imageEl) {\n\t\t\t\tconst [originX, originY] = getScaleOrigin();\n\t\t\t\tgesture.originX = originX;\n\t\t\t\tgesture.originY = originY;\n\t\t\t\tgesture.imageEl.style.transitionDuration = '0ms';\n\t\t\t}\n\t\t\tisScaling = true;\n\t\t}\n\t\tfunction onGestureChange(e) {\n\t\t\tif (!eventWithinSlide(e)) return;\n\t\t\tconst params = swiper.params.zoom;\n\t\t\tconst zoom = swiper.zoom;\n\t\t\tconst pointerIndex = evCache.findIndex(cachedEv => cachedEv.pointerId === e.pointerId);\n\t\t\tif (pointerIndex >= 0) evCache[pointerIndex] = e;\n\t\t\tif (evCache.length < 2) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfakeGestureMoved = true;\n\t\t\tgesture.scaleMove = getDistanceBetweenTouches();\n\t\t\tif (!gesture.imageEl) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tzoom.scale = gesture.scaleMove / gesture.scaleStart * currentScale;\n\t\t\tif (zoom.scale > gesture.maxRatio) {\n\t\t\t\tzoom.scale = gesture.maxRatio - 1 + (zoom.scale - gesture.maxRatio + 1) ** 0.5;\n\t\t\t}\n\t\t\tif (zoom.scale < params.minRatio) {\n\t\t\t\tzoom.scale = params.minRatio + 1 - (params.minRatio - zoom.scale + 1) ** 0.5;\n\t\t\t}\n\t\t\tgesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`;\n\t\t}\n\t\tfunction onGestureEnd(e) {\n\t\t\tif (!eventWithinSlide(e)) return;\n\t\t\tif (e.pointerType === 'mouse' && e.type === 'pointerout') return;\n\t\t\tconst params = swiper.params.zoom;\n\t\t\tconst zoom = swiper.zoom;\n\t\t\tconst pointerIndex = evCache.findIndex(cachedEv => cachedEv.pointerId === e.pointerId);\n\t\t\tif (pointerIndex >= 0) evCache.splice(pointerIndex, 1);\n\t\t\tif (!fakeGestureTouched || !fakeGestureMoved) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfakeGestureTouched = false;\n\t\t\tfakeGestureMoved = false;\n\t\t\tif (!gesture.imageEl) return;\n\t\t\tzoom.scale = Math.max(Math.min(zoom.scale, gesture.maxRatio), params.minRatio);\n\t\t\tgesture.imageEl.style.transitionDuration = `${swiper.params.speed}ms`;\n\t\t\tgesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`;\n\t\t\tcurrentScale = zoom.scale;\n\t\t\tisScaling = false;\n\t\t\tif (zoom.scale > 1 && gesture.slideEl) {\n\t\t\t\tgesture.slideEl.classList.add(`${params.zoomedSlideClass}`);\n\t\t\t} else if (zoom.scale <= 1 && gesture.slideEl) {\n\t\t\t\tgesture.slideEl.classList.remove(`${params.zoomedSlideClass}`);\n\t\t\t}\n\t\t\tif (zoom.scale === 1) {\n\t\t\t\tgesture.originX = 0;\n\t\t\t\tgesture.originY = 0;\n\t\t\t\tgesture.slideEl = undefined;\n\t\t\t}\n\t\t}\n\t\tfunction onTouchStart(e) {\n\t\t\tconst device = swiper.device;\n\t\t\tif (!gesture.imageEl) return;\n\t\t\tif (image.isTouched) return;\n\t\t\tif (device.android && e.cancelable) e.preventDefault();\n\t\t\timage.isTouched = true;\n\t\t\tconst event = evCache.length > 0 ? evCache[0] : e;\n\t\t\timage.touchesStart.x = event.pageX;\n\t\t\timage.touchesStart.y = event.pageY;\n\t\t}\n\t\tfunction onTouchMove(e) {\n\t\t\tif (!eventWithinSlide(e) || !eventWithinZoomContainer(e)) return;\n\t\t\tconst zoom = swiper.zoom;\n\t\t\tif (!gesture.imageEl) return;\n\t\t\tif (!image.isTouched || !gesture.slideEl) return;\n\t\t\tif (!image.isMoved) {\n\t\t\t\timage.width = gesture.imageEl.offsetWidth;\n\t\t\t\timage.height = gesture.imageEl.offsetHeight;\n\t\t\t\timage.startX = getTranslate(gesture.imageWrapEl, 'x') || 0;\n\t\t\t\timage.startY = getTranslate(gesture.imageWrapEl, 'y') || 0;\n\t\t\t\tgesture.slideWidth = gesture.slideEl.offsetWidth;\n\t\t\t\tgesture.slideHeight = gesture.slideEl.offsetHeight;\n\t\t\t\tgesture.imageWrapEl.style.transitionDuration = '0ms';\n\t\t\t}\n\t\t\t// Define if we need image drag\n\t\t\tconst scaledWidth = image.width * zoom.scale;\n\t\t\tconst scaledHeight = image.height * zoom.scale;\n\t\t\tif (scaledWidth < gesture.slideWidth && scaledHeight < gesture.slideHeight) return;\n\t\t\timage.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);\n\t\t\timage.maxX = -image.minX;\n\t\t\timage.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);\n\t\t\timage.maxY = -image.minY;\n\t\t\timage.touchesCurrent.x = evCache.length > 0 ? evCache[0].pageX : e.pageX;\n\t\t\timage.touchesCurrent.y = evCache.length > 0 ? evCache[0].pageY : e.pageY;\n\t\t\tconst touchesDiff = Math.max(Math.abs(image.touchesCurrent.x - image.touchesStart.x), Math.abs(image.touchesCurrent.y - image.touchesStart.y));\n\t\t\tif (touchesDiff > 5) {\n\t\t\t\tswiper.allowClick = false;\n\t\t\t}\n\t\t\tif (!image.isMoved && !isScaling) {\n\t\t\t\tif (swiper.isHorizontal() && (Math.floor(image.minX) === Math.floor(image.startX) && image.touchesCurrent.x < image.touchesStart.x || Math.floor(image.maxX) === Math.floor(image.startX) && image.touchesCurrent.x > image.touchesStart.x)) {\n\t\t\t\t\timage.isTouched = false;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (!swiper.isHorizontal() && (Math.floor(image.minY) === Math.floor(image.startY) && image.touchesCurrent.y < image.touchesStart.y || Math.floor(image.maxY) === Math.floor(image.startY) && image.touchesCurrent.y > image.touchesStart.y)) {\n\t\t\t\t\timage.isTouched = false;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (e.cancelable) {\n\t\t\t\te.preventDefault();\n\t\t\t}\n\t\t\te.stopPropagation();\n\t\t\timage.isMoved = true;\n\t\t\tconst scaleRatio = (zoom.scale - currentScale) / (gesture.maxRatio - swiper.params.zoom.minRatio);\n\t\t\tconst {\n\t\t\t\toriginX,\n\t\t\t\toriginY\n\t\t\t} = gesture;\n\t\t\timage.currentX = image.touchesCurrent.x - image.touchesStart.x + image.startX + scaleRatio * (image.width - originX * 2);\n\t\t\timage.currentY = image.touchesCurrent.y - image.touchesStart.y + image.startY + scaleRatio * (image.height - originY * 2);\n\t\t\tif (image.currentX < image.minX) {\n\t\t\t\timage.currentX = image.minX + 1 - (image.minX - image.currentX + 1) ** 0.8;\n\t\t\t}\n\t\t\tif (image.currentX > image.maxX) {\n\t\t\t\timage.currentX = image.maxX - 1 + (image.currentX - image.maxX + 1) ** 0.8;\n\t\t\t}\n\t\t\tif (image.currentY < image.minY) {\n\t\t\t\timage.currentY = image.minY + 1 - (image.minY - image.currentY + 1) ** 0.8;\n\t\t\t}\n\t\t\tif (image.currentY > image.maxY) {\n\t\t\t\timage.currentY = image.maxY - 1 + (image.currentY - image.maxY + 1) ** 0.8;\n\t\t\t}\n\n\t\t\t// Velocity\n\t\t\tif (!velocity.prevPositionX) velocity.prevPositionX = image.touchesCurrent.x;\n\t\t\tif (!velocity.prevPositionY) velocity.prevPositionY = image.touchesCurrent.y;\n\t\t\tif (!velocity.prevTime) velocity.prevTime = Date.now();\n\t\t\tvelocity.x = (image.touchesCurrent.x - velocity.prevPositionX) / (Date.now() - velocity.prevTime) / 2;\n\t\t\tvelocity.y = (image.touchesCurrent.y - velocity.prevPositionY) / (Date.now() - velocity.prevTime) / 2;\n\t\t\tif (Math.abs(image.touchesCurrent.x - velocity.prevPositionX) < 2) velocity.x = 0;\n\t\t\tif (Math.abs(image.touchesCurrent.y - velocity.prevPositionY) < 2) velocity.y = 0;\n\t\t\tvelocity.prevPositionX = image.touchesCurrent.x;\n\t\t\tvelocity.prevPositionY = image.touchesCurrent.y;\n\t\t\tvelocity.prevTime = Date.now();\n\t\t\tgesture.imageWrapEl.style.transform = `translate3d(${image.currentX}px, ${image.currentY}px,0)`;\n\t\t}\n\t\tfunction onTouchEnd() {\n\t\t\tconst zoom = swiper.zoom;\n\t\t\tif (!gesture.imageEl) return;\n\t\t\tif (!image.isTouched || !image.isMoved) {\n\t\t\t\timage.isTouched = false;\n\t\t\t\timage.isMoved = false;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\timage.isTouched = false;\n\t\t\timage.isMoved = false;\n\t\t\tlet momentumDurationX = 300;\n\t\t\tlet momentumDurationY = 300;\n\t\t\tconst momentumDistanceX = velocity.x * momentumDurationX;\n\t\t\tconst newPositionX = image.currentX + momentumDistanceX;\n\t\t\tconst momentumDistanceY = velocity.y * momentumDurationY;\n\t\t\tconst newPositionY = image.currentY + momentumDistanceY;\n\n\t\t\t// Fix duration\n\t\t\tif (velocity.x !== 0) momentumDurationX = Math.abs((newPositionX - image.currentX) / velocity.x);\n\t\t\tif (velocity.y !== 0) momentumDurationY = Math.abs((newPositionY - image.currentY) / velocity.y);\n\t\t\tconst momentumDuration = Math.max(momentumDurationX, momentumDurationY);\n\t\t\timage.currentX = newPositionX;\n\t\t\timage.currentY = newPositionY;\n\t\t\t// Define if we need image drag\n\t\t\tconst scaledWidth = image.width * zoom.scale;\n\t\t\tconst scaledHeight = image.height * zoom.scale;\n\t\t\timage.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);\n\t\t\timage.maxX = -image.minX;\n\t\t\timage.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);\n\t\t\timage.maxY = -image.minY;\n\t\t\timage.currentX = Math.max(Math.min(image.currentX, image.maxX), image.minX);\n\t\t\timage.currentY = Math.max(Math.min(image.currentY, image.maxY), image.minY);\n\t\t\tgesture.imageWrapEl.style.transitionDuration = `${momentumDuration}ms`;\n\t\t\tgesture.imageWrapEl.style.transform = `translate3d(${image.currentX}px, ${image.currentY}px,0)`;\n\t\t}\n\t\tfunction onTransitionEnd() {\n\t\t\tconst zoom = swiper.zoom;\n\t\t\tif (gesture.slideEl && swiper.activeIndex !== swiper.slides.indexOf(gesture.slideEl)) {\n\t\t\t\tif (gesture.imageEl) {\n\t\t\t\t\tgesture.imageEl.style.transform = 'translate3d(0,0,0) scale(1)';\n\t\t\t\t}\n\t\t\t\tif (gesture.imageWrapEl) {\n\t\t\t\t\tgesture.imageWrapEl.style.transform = 'translate3d(0,0,0)';\n\t\t\t\t}\n\t\t\t\tgesture.slideEl.classList.remove(`${swiper.params.zoom.zoomedSlideClass}`);\n\t\t\t\tzoom.scale = 1;\n\t\t\t\tcurrentScale = 1;\n\t\t\t\tgesture.slideEl = undefined;\n\t\t\t\tgesture.imageEl = undefined;\n\t\t\t\tgesture.imageWrapEl = undefined;\n\t\t\t\tgesture.originX = 0;\n\t\t\t\tgesture.originY = 0;\n\t\t\t}\n\t\t}\n\t\tfunction zoomIn(e) {\n\t\t\tconst zoom = swiper.zoom;\n\t\t\tconst params = swiper.params.zoom;\n\t\t\tif (!gesture.slideEl) {\n\t\t\t\tif (e && e.target) {\n\t\t\t\t\tgesture.slideEl = e.target.closest(`.${swiper.params.slideClass}, swiper-slide`);\n\t\t\t\t}\n\t\t\t\tif (!gesture.slideEl) {\n\t\t\t\t\tif (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {\n\t\t\t\t\t\tgesture.slideEl = elementChildren(swiper.slidesEl, `.${swiper.params.slideActiveClass}`)[0];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgesture.slideEl = swiper.slides[swiper.activeIndex];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlet imageEl = gesture.slideEl.querySelector(`.${params.containerClass}`);\n\t\t\t\tif (imageEl) {\n\t\t\t\t\timageEl = imageEl.querySelectorAll('picture, img, svg, canvas, .swiper-zoom-target')[0];\n\t\t\t\t}\n\t\t\t\tgesture.imageEl = imageEl;\n\t\t\t\tif (imageEl) {\n\t\t\t\t\tgesture.imageWrapEl = elementParents(gesture.imageEl, `.${params.containerClass}`)[0];\n\t\t\t\t} else {\n\t\t\t\t\tgesture.imageWrapEl = undefined;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!gesture.imageEl || !gesture.imageWrapEl) return;\n\t\t\tif (swiper.params.cssMode) {\n\t\t\t\tswiper.wrapperEl.style.overflow = 'hidden';\n\t\t\t\tswiper.wrapperEl.style.touchAction = 'none';\n\t\t\t}\n\t\t\tgesture.slideEl.classList.add(`${params.zoomedSlideClass}`);\n\t\t\tlet touchX;\n\t\t\tlet touchY;\n\t\t\tlet offsetX;\n\t\t\tlet offsetY;\n\t\t\tlet diffX;\n\t\t\tlet diffY;\n\t\t\tlet translateX;\n\t\t\tlet translateY;\n\t\t\tlet imageWidth;\n\t\t\tlet imageHeight;\n\t\t\tlet scaledWidth;\n\t\t\tlet scaledHeight;\n\t\t\tlet translateMinX;\n\t\t\tlet translateMinY;\n\t\t\tlet translateMaxX;\n\t\t\tlet translateMaxY;\n\t\t\tlet slideWidth;\n\t\t\tlet slideHeight;\n\t\t\tif (typeof image.touchesStart.x === 'undefined' && e) {\n\t\t\t\ttouchX = e.pageX;\n\t\t\t\ttouchY = e.pageY;\n\t\t\t} else {\n\t\t\t\ttouchX = image.touchesStart.x;\n\t\t\t\ttouchY = image.touchesStart.y;\n\t\t\t}\n\t\t\tconst forceZoomRatio = typeof e === 'number' ? e : null;\n\t\t\tif (currentScale === 1 && forceZoomRatio) {\n\t\t\t\ttouchX = undefined;\n\t\t\t\ttouchY = undefined;\n\t\t\t}\n\t\t\tzoom.scale = forceZoomRatio || gesture.imageWrapEl.getAttribute('data-swiper-zoom') || params.maxRatio;\n\t\t\tcurrentScale = forceZoomRatio || gesture.imageWrapEl.getAttribute('data-swiper-zoom') || params.maxRatio;\n\t\t\tif (e && !(currentScale === 1 && forceZoomRatio)) {\n\t\t\t\tslideWidth = gesture.slideEl.offsetWidth;\n\t\t\t\tslideHeight = gesture.slideEl.offsetHeight;\n\t\t\t\toffsetX = elementOffset(gesture.slideEl).left + window.scrollX;\n\t\t\t\toffsetY = elementOffset(gesture.slideEl).top + window.scrollY;\n\t\t\t\tdiffX = offsetX + slideWidth / 2 - touchX;\n\t\t\t\tdiffY = offsetY + slideHeight / 2 - touchY;\n\t\t\t\timageWidth = gesture.imageEl.offsetWidth;\n\t\t\t\timageHeight = gesture.imageEl.offsetHeight;\n\t\t\t\tscaledWidth = imageWidth * zoom.scale;\n\t\t\t\tscaledHeight = imageHeight * zoom.scale;\n\t\t\t\ttranslateMinX = Math.min(slideWidth / 2 - scaledWidth / 2, 0);\n\t\t\t\ttranslateMinY = Math.min(slideHeight / 2 - scaledHeight / 2, 0);\n\t\t\t\ttranslateMaxX = -translateMinX;\n\t\t\t\ttranslateMaxY = -translateMinY;\n\t\t\t\ttranslateX = diffX * zoom.scale;\n\t\t\t\ttranslateY = diffY * zoom.scale;\n\t\t\t\tif (translateX < translateMinX) {\n\t\t\t\t\ttranslateX = translateMinX;\n\t\t\t\t}\n\t\t\t\tif (translateX > translateMaxX) {\n\t\t\t\t\ttranslateX = translateMaxX;\n\t\t\t\t}\n\t\t\t\tif (translateY < translateMinY) {\n\t\t\t\t\ttranslateY = translateMinY;\n\t\t\t\t}\n\t\t\t\tif (translateY > translateMaxY) {\n\t\t\t\t\ttranslateY = translateMaxY;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ttranslateX = 0;\n\t\t\t\ttranslateY = 0;\n\t\t\t}\n\t\t\tif (forceZoomRatio && zoom.scale === 1) {\n\t\t\t\tgesture.originX = 0;\n\t\t\t\tgesture.originY = 0;\n\t\t\t}\n\t\t\tgesture.imageWrapEl.style.transitionDuration = '300ms';\n\t\t\tgesture.imageWrapEl.style.transform = `translate3d(${translateX}px, ${translateY}px,0)`;\n\t\t\tgesture.imageEl.style.transitionDuration = '300ms';\n\t\t\tgesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`;\n\t\t}\n\t\tfunction zoomOut() {\n\t\t\tconst zoom = swiper.zoom;\n\t\t\tconst params = swiper.params.zoom;\n\t\t\tif (!gesture.slideEl) {\n\t\t\t\tif (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {\n\t\t\t\t\tgesture.slideEl = elementChildren(swiper.slidesEl, `.${swiper.params.slideActiveClass}`)[0];\n\t\t\t\t} else {\n\t\t\t\t\tgesture.slideEl = swiper.slides[swiper.activeIndex];\n\t\t\t\t}\n\t\t\t\tlet imageEl = gesture.slideEl.querySelector(`.${params.containerClass}`);\n\t\t\t\tif (imageEl) {\n\t\t\t\t\timageEl = imageEl.querySelectorAll('picture, img, svg, canvas, .swiper-zoom-target')[0];\n\t\t\t\t}\n\t\t\t\tgesture.imageEl = imageEl;\n\t\t\t\tif (imageEl) {\n\t\t\t\t\tgesture.imageWrapEl = elementParents(gesture.imageEl, `.${params.containerClass}`)[0];\n\t\t\t\t} else {\n\t\t\t\t\tgesture.imageWrapEl = undefined;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!gesture.imageEl || !gesture.imageWrapEl) return;\n\t\t\tif (swiper.params.cssMode) {\n\t\t\t\tswiper.wrapperEl.style.overflow = '';\n\t\t\t\tswiper.wrapperEl.style.touchAction = '';\n\t\t\t}\n\t\t\tzoom.scale = 1;\n\t\t\tcurrentScale = 1;\n\t\t\tgesture.imageWrapEl.style.transitionDuration = '300ms';\n\t\t\tgesture.imageWrapEl.style.transform = 'translate3d(0,0,0)';\n\t\t\tgesture.imageEl.style.transitionDuration = '300ms';\n\t\t\tgesture.imageEl.style.transform = 'translate3d(0,0,0) scale(1)';\n\t\t\tgesture.slideEl.classList.remove(`${params.zoomedSlideClass}`);\n\t\t\tgesture.slideEl = undefined;\n\t\t\tgesture.originX = 0;\n\t\t\tgesture.originY = 0;\n\t\t}\n\n\t\t// Toggle Zoom\n\t\tfunction zoomToggle(e) {\n\t\t\tconst zoom = swiper.zoom;\n\t\t\tif (zoom.scale && zoom.scale !== 1) {\n\t\t\t\t// Zoom Out\n\t\t\t\tzoomOut();\n\t\t\t} else {\n\t\t\t\t// Zoom In\n\t\t\t\tzoomIn(e);\n\t\t\t}\n\t\t}\n\t\tfunction getListeners() {\n\t\t\tconst passiveListener = swiper.params.passiveListeners ? {\n\t\t\t\tpassive: true,\n\t\t\t\tcapture: false\n\t\t\t} : false;\n\t\t\tconst activeListenerWithCapture = swiper.params.passiveListeners ? {\n\t\t\t\tpassive: false,\n\t\t\t\tcapture: true\n\t\t\t} : true;\n\t\t\treturn {\n\t\t\t\tpassiveListener,\n\t\t\t\tactiveListenerWithCapture\n\t\t\t};\n\t\t}\n\n\t\t// Attach/Detach Events\n\t\tfunction enable() {\n\t\t\tconst zoom = swiper.zoom;\n\t\t\tif (zoom.enabled) return;\n\t\t\tzoom.enabled = true;\n\t\t\tconst {\n\t\t\t\tpassiveListener,\n\t\t\t\tactiveListenerWithCapture\n\t\t\t} = getListeners();\n\n\t\t\t// Scale image\n\t\t\tswiper.wrapperEl.addEventListener('pointerdown', onGestureStart, passiveListener);\n\t\t\tswiper.wrapperEl.addEventListener('pointermove', onGestureChange, activeListenerWithCapture);\n\t\t\t['pointerup', 'pointercancel', 'pointerout'].forEach(eventName => {\n\t\t\t\tswiper.wrapperEl.addEventListener(eventName, onGestureEnd, passiveListener);\n\t\t\t});\n\n\t\t\t// Move image\n\t\t\tswiper.wrapperEl.addEventListener('pointermove', onTouchMove, activeListenerWithCapture);\n\t\t}\n\t\tfunction disable() {\n\t\t\tconst zoom = swiper.zoom;\n\t\t\tif (!zoom.enabled) return;\n\t\t\tzoom.enabled = false;\n\t\t\tconst {\n\t\t\t\tpassiveListener,\n\t\t\t\tactiveListenerWithCapture\n\t\t\t} = getListeners();\n\n\t\t\t// Scale image\n\t\t\tswiper.wrapperEl.removeEventListener('pointerdown', onGestureStart, passiveListener);\n\t\t\tswiper.wrapperEl.removeEventListener('pointermove', onGestureChange, activeListenerWithCapture);\n\t\t\t['pointerup', 'pointercancel', 'pointerout'].forEach(eventName => {\n\t\t\t\tswiper.wrapperEl.removeEventListener(eventName, onGestureEnd, passiveListener);\n\t\t\t});\n\n\t\t\t// Move image\n\t\t\tswiper.wrapperEl.removeEventListener('pointermove', onTouchMove, activeListenerWithCapture);\n\t\t}\n\t\ton('init', () => {\n\t\t\tif (swiper.params.zoom.enabled) {\n\t\t\t\tenable();\n\t\t\t}\n\t\t});\n\t\ton('destroy', () => {\n\t\t\tdisable();\n\t\t});\n\t\ton('touchStart', (_s, e) => {\n\t\t\tif (!swiper.zoom.enabled) return;\n\t\t\tonTouchStart(e);\n\t\t});\n\t\ton('touchEnd', (_s, e) => {\n\t\t\tif (!swiper.zoom.enabled) return;\n\t\t\tonTouchEnd();\n\t\t});\n\t\ton('doubleTap', (_s, e) => {\n\t\t\tif (!swiper.animating && swiper.params.zoom.enabled && swiper.zoom.enabled && swiper.params.zoom.toggle) {\n\t\t\t\tzoomToggle(e);\n\t\t\t}\n\t\t});\n\t\ton('transitionEnd', () => {\n\t\t\tif (swiper.zoom.enabled && swiper.params.zoom.enabled) {\n\t\t\t\tonTransitionEnd();\n\t\t\t}\n\t\t});\n\t\ton('slideChange', () => {\n\t\t\tif (swiper.zoom.enabled && swiper.params.zoom.enabled && swiper.params.cssMode) {\n\t\t\t\tonTransitionEnd();\n\t\t\t}\n\t\t});\n\t\tObject.assign(swiper.zoom, {\n\t\t\tenable,\n\t\t\tdisable,\n\t\t\tin: zoomIn,\n\t\t\tout: zoomOut,\n\t\t\ttoggle: zoomToggle\n\t\t});\n\t}\n\n\t/* eslint no-bitwise: [\"error\", { \"allow\": [\">>\"] }] */\n\tfunction Controller(_ref) {\n\t\tlet {\n\t\t\tswiper,\n\t\t\textendParams,\n\t\t\ton\n\t\t} = _ref;\n\t\textendParams({\n\t\t\tcontroller: {\n\t\t\t\tcontrol: undefined,\n\t\t\t\tinverse: false,\n\t\t\t\tby: 'slide' // or 'container'\n\t\t\t}\n\t\t});\n\n\t\tswiper.controller = {\n\t\t\tcontrol: undefined\n\t\t};\n\t\tfunction LinearSpline(x, y) {\n\t\t\tconst binarySearch = function search() {\n\t\t\t\tlet maxIndex;\n\t\t\t\tlet minIndex;\n\t\t\t\tlet guess;\n\t\t\t\treturn (array, val) => {\n\t\t\t\t\tminIndex = -1;\n\t\t\t\t\tmaxIndex = array.length;\n\t\t\t\t\twhile (maxIndex - minIndex > 1) {\n\t\t\t\t\t\tguess = maxIndex + minIndex >> 1;\n\t\t\t\t\t\tif (array[guess] <= val) {\n\t\t\t\t\t\t\tminIndex = guess;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tmaxIndex = guess;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn maxIndex;\n\t\t\t\t};\n\t\t\t}();\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.lastIndex = x.length - 1;\n\t\t\t// Given an x value (x2), return the expected y2 value:\n\t\t\t// (x1,y1) is the known point before given value,\n\t\t\t// (x3,y3) is the known point after given value.\n\t\t\tlet i1;\n\t\t\tlet i3;\n\t\t\tthis.interpolate = function interpolate(x2) {\n\t\t\t\tif (!x2) return 0;\n\n\t\t\t\t// Get the indexes of x1 and x3 (the array indexes before and after given x2):\n\t\t\t\ti3 = binarySearch(this.x, x2);\n\t\t\t\ti1 = i3 - 1;\n\n\t\t\t\t// We have our indexes i1 & i3, so we can calculate already:\n\t\t\t\t// y2 := ((x2−x1) × (y3−y1)) ÷ (x3−x1) + y1\n\t\t\t\treturn (x2 - this.x[i1]) * (this.y[i3] - this.y[i1]) / (this.x[i3] - this.x[i1]) + this.y[i1];\n\t\t\t};\n\t\t\treturn this;\n\t\t}\n\t\tfunction getInterpolateFunction(c) {\n\t\t\tswiper.controller.spline = swiper.params.loop ? new LinearSpline(swiper.slidesGrid, c.slidesGrid) : new LinearSpline(swiper.snapGrid, c.snapGrid);\n\t\t}\n\t\tfunction setTranslate(_t, byController) {\n\t\t\tconst controlled = swiper.controller.control;\n\t\t\tlet multiplier;\n\t\t\tlet controlledTranslate;\n\t\t\tconst Swiper = swiper.constructor;\n\t\t\tfunction setControlledTranslate(c) {\n\t\t\t\tif (c.destroyed) return;\n\n\t\t\t\t// this will create an Interpolate function based on the snapGrids\n\t\t\t\t// x is the Grid of the scrolled scroller and y will be the controlled scroller\n\t\t\t\t// it makes sense to create this only once and recall it for the interpolation\n\t\t\t\t// the function does a lot of value caching for performance\n\t\t\t\tconst translate = swiper.rtlTranslate ? -swiper.translate : swiper.translate;\n\t\t\t\tif (swiper.params.controller.by === 'slide') {\n\t\t\t\t\tgetInterpolateFunction(c);\n\t\t\t\t\t// i am not sure why the values have to be multiplicated this way, tried to invert the snapGrid\n\t\t\t\t\t// but it did not work out\n\t\t\t\t\tcontrolledTranslate = -swiper.controller.spline.interpolate(-translate);\n\t\t\t\t}\n\t\t\t\tif (!controlledTranslate || swiper.params.controller.by === 'container') {\n\t\t\t\t\tmultiplier = (c.maxTranslate() - c.minTranslate()) / (swiper.maxTranslate() - swiper.minTranslate());\n\t\t\t\t\tif (Number.isNaN(multiplier) || !Number.isFinite(multiplier)) {\n\t\t\t\t\t\tmultiplier = 1;\n\t\t\t\t\t}\n\t\t\t\t\tcontrolledTranslate = (translate - swiper.minTranslate()) * multiplier + c.minTranslate();\n\t\t\t\t}\n\t\t\t\tif (swiper.params.controller.inverse) {\n\t\t\t\t\tcontrolledTranslate = c.maxTranslate() - controlledTranslate;\n\t\t\t\t}\n\t\t\t\tc.updateProgress(controlledTranslate);\n\t\t\t\tc.setTranslate(controlledTranslate, swiper);\n\t\t\t\tc.updateActiveIndex();\n\t\t\t\tc.updateSlidesClasses();\n\t\t\t}\n\t\t\tif (Array.isArray(controlled)) {\n\t\t\t\tfor (let i = 0; i < controlled.length; i += 1) {\n\t\t\t\t\tif (controlled[i] !== byController && controlled[i] instanceof Swiper) {\n\t\t\t\t\t\tsetControlledTranslate(controlled[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (controlled instanceof Swiper && byController !== controlled) {\n\t\t\t\tsetControlledTranslate(controlled);\n\t\t\t}\n\t\t}\n\t\tfunction setTransition(duration, byController) {\n\t\t\tconst Swiper = swiper.constructor;\n\t\t\tconst controlled = swiper.controller.control;\n\t\t\tlet i;\n\t\t\tfunction setControlledTransition(c) {\n\t\t\t\tif (c.destroyed) return;\n\t\t\t\tc.setTransition(duration, swiper);\n\t\t\t\tif (duration !== 0) {\n\t\t\t\t\tc.transitionStart();\n\t\t\t\t\tif (c.params.autoHeight) {\n\t\t\t\t\t\tnextTick(() => {\n\t\t\t\t\t\t\tc.updateAutoHeight();\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\telementTransitionEnd(c.wrapperEl, () => {\n\t\t\t\t\t\tif (!controlled) return;\n\t\t\t\t\t\tc.transitionEnd();\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (Array.isArray(controlled)) {\n\t\t\t\tfor (i = 0; i < controlled.length; i += 1) {\n\t\t\t\t\tif (controlled[i] !== byController && controlled[i] instanceof Swiper) {\n\t\t\t\t\t\tsetControlledTransition(controlled[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (controlled instanceof Swiper && byController !== controlled) {\n\t\t\t\tsetControlledTransition(controlled);\n\t\t\t}\n\t\t}\n\t\tfunction removeSpline() {\n\t\t\tif (!swiper.controller.control) return;\n\t\t\tif (swiper.controller.spline) {\n\t\t\t\tswiper.controller.spline = undefined;\n\t\t\t\tdelete swiper.controller.spline;\n\t\t\t}\n\t\t}\n\t\ton('beforeInit', () => {\n\t\t\tif (typeof window !== 'undefined' && (\n\t\t\t\t// eslint-disable-line\n\t\t\t\ttypeof swiper.params.controller.control === 'string' || swiper.params.controller.control instanceof HTMLElement)) {\n\t\t\t\tconst controlElement = document.querySelector(swiper.params.controller.control);\n\t\t\t\tif (controlElement && controlElement.swiper) {\n\t\t\t\t\tswiper.controller.control = controlElement.swiper;\n\t\t\t\t} else if (controlElement) {\n\t\t\t\t\tconst onControllerSwiper = e => {\n\t\t\t\t\t\tswiper.controller.control = e.detail[0];\n\t\t\t\t\t\tswiper.update();\n\t\t\t\t\t\tcontrolElement.removeEventListener('init', onControllerSwiper);\n\t\t\t\t\t};\n\t\t\t\t\tcontrolElement.addEventListener('init', onControllerSwiper);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tswiper.controller.control = swiper.params.controller.control;\n\t\t});\n\t\ton('update', () => {\n\t\t\tremoveSpline();\n\t\t});\n\t\ton('resize', () => {\n\t\t\tremoveSpline();\n\t\t});\n\t\ton('observerUpdate', () => {\n\t\t\tremoveSpline();\n\t\t});\n\t\ton('setTranslate', (_s, translate, byController) => {\n\t\t\tif (!swiper.controller.control || swiper.controller.control.destroyed) return;\n\t\t\tswiper.controller.setTranslate(translate, byController);\n\t\t});\n\t\ton('setTransition', (_s, duration, byController) => {\n\t\t\tif (!swiper.controller.control || swiper.controller.control.destroyed) return;\n\t\t\tswiper.controller.setTransition(duration, byController);\n\t\t});\n\t\tObject.assign(swiper.controller, {\n\t\t\tsetTranslate,\n\t\t\tsetTransition\n\t\t});\n\t}\n\n\tfunction A11y(_ref) {\n\t\tlet {\n\t\t\tswiper,\n\t\t\textendParams,\n\t\t\ton\n\t\t} = _ref;\n\t\textendParams({\n\t\t\ta11y: {\n\t\t\t\tenabled: true,\n\t\t\t\tnotificationClass: 'swiper-notification',\n\t\t\t\tprevSlideMessage: 'Previous slide',\n\t\t\t\tnextSlideMessage: 'Next slide',\n\t\t\t\tfirstSlideMessage: 'This is the first slide',\n\t\t\t\tlastSlideMessage: 'This is the last slide',\n\t\t\t\tpaginationBulletMessage: 'Go to slide {{index}}',\n\t\t\t\tslideLabelMessage: '{{index}} / {{slidesLength}}',\n\t\t\t\tcontainerMessage: null,\n\t\t\t\tcontainerRoleDescriptionMessage: null,\n\t\t\t\titemRoleDescriptionMessage: null,\n\t\t\t\tslideRole: 'group',\n\t\t\t\tid: null\n\t\t\t}\n\t\t});\n\t\tswiper.a11y = {\n\t\t\tclicked: false\n\t\t};\n\t\tlet liveRegion = null;\n\t\tfunction notify(message) {\n\t\t\tconst notification = liveRegion;\n\t\t\tif (notification.length === 0) return;\n\t\t\tnotification.innerHTML = '';\n\t\t\tnotification.innerHTML = message;\n\t\t}\n\t\tconst makeElementsArray = el => (Array.isArray(el) ? el : [el]).filter(e => !!e);\n\t\tfunction getRandomNumber(size) {\n\t\t\tif (size === void 0) {\n\t\t\t\tsize = 16;\n\t\t\t}\n\t\t\tconst randomChar = () => Math.round(16 * Math.random()).toString(16);\n\t\t\treturn 'x'.repeat(size).replace(/x/g, randomChar);\n\t\t}\n\t\tfunction makeElFocusable(el) {\n\t\t\tel = makeElementsArray(el);\n\t\t\tel.forEach(subEl => {\n\t\t\t\tsubEl.setAttribute('tabIndex', '0');\n\t\t\t});\n\t\t}\n\t\tfunction makeElNotFocusable(el) {\n\t\t\tel = makeElementsArray(el);\n\t\t\tel.forEach(subEl => {\n\t\t\t\tsubEl.setAttribute('tabIndex', '-1');\n\t\t\t});\n\t\t}\n\t\tfunction addElRole(el, role) {\n\t\t\tel = makeElementsArray(el);\n\t\t\tel.forEach(subEl => {\n\t\t\t\tsubEl.setAttribute('role', role);\n\t\t\t});\n\t\t}\n\t\tfunction addElRoleDescription(el, description) {\n\t\t\tel = makeElementsArray(el);\n\t\t\tel.forEach(subEl => {\n\t\t\t\tsubEl.setAttribute('aria-roledescription', description);\n\t\t\t});\n\t\t}\n\t\tfunction addElControls(el, controls) {\n\t\t\tel = makeElementsArray(el);\n\t\t\tel.forEach(subEl => {\n\t\t\t\tsubEl.setAttribute('aria-controls', controls);\n\t\t\t});\n\t\t}\n\t\tfunction addElLabel(el, label) {\n\t\t\tel = makeElementsArray(el);\n\t\t\tel.forEach(subEl => {\n\t\t\t\tsubEl.setAttribute('aria-label', label);\n\t\t\t});\n\t\t}\n\t\tfunction addElId(el, id) {\n\t\t\tel = makeElementsArray(el);\n\t\t\tel.forEach(subEl => {\n\t\t\t\tsubEl.setAttribute('id', id);\n\t\t\t});\n\t\t}\n\t\tfunction addElLive(el, live) {\n\t\t\tel = makeElementsArray(el);\n\t\t\tel.forEach(subEl => {\n\t\t\t\tsubEl.setAttribute('aria-live', live);\n\t\t\t});\n\t\t}\n\t\tfunction disableEl(el) {\n\t\t\tel = makeElementsArray(el);\n\t\t\tel.forEach(subEl => {\n\t\t\t\tsubEl.setAttribute('aria-disabled', true);\n\t\t\t});\n\t\t}\n\t\tfunction enableEl(el) {\n\t\t\tel = makeElementsArray(el);\n\t\t\tel.forEach(subEl => {\n\t\t\t\tsubEl.setAttribute('aria-disabled', false);\n\t\t\t});\n\t\t}\n\t\tfunction onEnterOrSpaceKey(e) {\n\t\t\tif (e.keyCode !== 13 && e.keyCode !== 32) return;\n\t\t\tconst params = swiper.params.a11y;\n\t\t\tconst targetEl = e.target;\n\t\t\tif (swiper.pagination && swiper.pagination.el && (targetEl === swiper.pagination.el || swiper.pagination.el.contains(e.target))) {\n\t\t\t\tif (!e.target.matches(classesToSelector(swiper.params.pagination.bulletClass))) return;\n\t\t\t}\n\t\t\tif (swiper.navigation && swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl) {\n\t\t\t\tif (!(swiper.isEnd && !swiper.params.loop)) {\n\t\t\t\t\tswiper.slideNext();\n\t\t\t\t}\n\t\t\t\tif (swiper.isEnd) {\n\t\t\t\t\tnotify(params.lastSlideMessage);\n\t\t\t\t} else {\n\t\t\t\t\tnotify(params.nextSlideMessage);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (swiper.navigation && swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl) {\n\t\t\t\tif (!(swiper.isBeginning && !swiper.params.loop)) {\n\t\t\t\t\tswiper.slidePrev();\n\t\t\t\t}\n\t\t\t\tif (swiper.isBeginning) {\n\t\t\t\t\tnotify(params.firstSlideMessage);\n\t\t\t\t} else {\n\t\t\t\t\tnotify(params.prevSlideMessage);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (swiper.pagination && targetEl.matches(classesToSelector(swiper.params.pagination.bulletClass))) {\n\t\t\t\ttargetEl.click();\n\t\t\t}\n\t\t}\n\t\tfunction updateNavigation() {\n\t\t\tif (swiper.params.loop || swiper.params.rewind || !swiper.navigation) return;\n\t\t\tconst {\n\t\t\t\tnextEl,\n\t\t\t\tprevEl\n\t\t\t} = swiper.navigation;\n\t\t\tif (prevEl) {\n\t\t\t\tif (swiper.isBeginning) {\n\t\t\t\t\tdisableEl(prevEl);\n\t\t\t\t\tmakeElNotFocusable(prevEl);\n\t\t\t\t} else {\n\t\t\t\t\tenableEl(prevEl);\n\t\t\t\t\tmakeElFocusable(prevEl);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (nextEl) {\n\t\t\t\tif (swiper.isEnd) {\n\t\t\t\t\tdisableEl(nextEl);\n\t\t\t\t\tmakeElNotFocusable(nextEl);\n\t\t\t\t} else {\n\t\t\t\t\tenableEl(nextEl);\n\t\t\t\t\tmakeElFocusable(nextEl);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfunction hasPagination() {\n\t\t\treturn swiper.pagination && swiper.pagination.bullets && swiper.pagination.bullets.length;\n\t\t}\n\t\tfunction hasClickablePagination() {\n\t\t\treturn hasPagination() && swiper.params.pagination.clickable;\n\t\t}\n\t\tfunction updatePagination() {\n\t\t\tconst params = swiper.params.a11y;\n\t\t\tif (!hasPagination()) return;\n\t\t\tswiper.pagination.bullets.forEach(bulletEl => {\n\t\t\t\tif (swiper.params.pagination.clickable) {\n\t\t\t\t\tmakeElFocusable(bulletEl);\n\t\t\t\t\tif (!swiper.params.pagination.renderBullet) {\n\t\t\t\t\t\taddElRole(bulletEl, 'button');\n\t\t\t\t\t\taddElLabel(bulletEl, params.paginationBulletMessage.replace(/\\{\\{index\\}\\}/, elementIndex(bulletEl) + 1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (bulletEl.matches(classesToSelector(swiper.params.pagination.bulletActiveClass))) {\n\t\t\t\t\tbulletEl.setAttribute('aria-current', 'true');\n\t\t\t\t} else {\n\t\t\t\t\tbulletEl.removeAttribute('aria-current');\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tconst initNavEl = (el, wrapperId, message) => {\n\t\t\tmakeElFocusable(el);\n\t\t\tif (el.tagName !== 'BUTTON') {\n\t\t\t\taddElRole(el, 'button');\n\t\t\t\tel.addEventListener('keydown', onEnterOrSpaceKey);\n\t\t\t}\n\t\t\taddElLabel(el, message);\n\t\t\taddElControls(el, wrapperId);\n\t\t};\n\t\tconst handlePointerDown = () => {\n\t\t\tswiper.a11y.clicked = true;\n\t\t};\n\t\tconst handlePointerUp = () => {\n\t\t\trequestAnimationFrame(() => {\n\t\t\t\trequestAnimationFrame(() => {\n\t\t\t\t\tif (!swiper.destroyed) {\n\t\t\t\t\t\tswiper.a11y.clicked = false;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t};\n\t\tconst handleFocus = e => {\n\t\t\tif (swiper.a11y.clicked) return;\n\t\t\tconst slideEl = e.target.closest(`.${swiper.params.slideClass}, swiper-slide`);\n\t\t\tif (!slideEl || !swiper.slides.includes(slideEl)) return;\n\t\t\tconst isActive = swiper.slides.indexOf(slideEl) === swiper.activeIndex;\n\t\t\tconst isVisible = swiper.params.watchSlidesProgress && swiper.visibleSlides && swiper.visibleSlides.includes(slideEl);\n\t\t\tif (isActive || isVisible) return;\n\t\t\tif (e.sourceCapabilities && e.sourceCapabilities.firesTouchEvents) return;\n\t\t\tif (swiper.isHorizontal()) {\n\t\t\t\tswiper.el.scrollLeft = 0;\n\t\t\t} else {\n\t\t\t\tswiper.el.scrollTop = 0;\n\t\t\t}\n\t\t\tswiper.slideTo(swiper.slides.indexOf(slideEl), 0);\n\t\t};\n\t\tconst initSlides = () => {\n\t\t\tconst params = swiper.params.a11y;\n\t\t\tif (params.itemRoleDescriptionMessage) {\n\t\t\t\taddElRoleDescription(swiper.slides, params.itemRoleDescriptionMessage);\n\t\t\t}\n\t\t\tif (params.slideRole) {\n\t\t\t\taddElRole(swiper.slides, params.slideRole);\n\t\t\t}\n\t\t\tconst slidesLength = swiper.slides.length;\n\t\t\tif (params.slideLabelMessage) {\n\t\t\t\tswiper.slides.forEach((slideEl, index) => {\n\t\t\t\t\tconst slideIndex = swiper.params.loop ? parseInt(slideEl.getAttribute('data-swiper-slide-index'), 10) : index;\n\t\t\t\t\tconst ariaLabelMessage = params.slideLabelMessage.replace(/\\{\\{index\\}\\}/, slideIndex + 1).replace(/\\{\\{slidesLength\\}\\}/, slidesLength);\n\t\t\t\t\taddElLabel(slideEl, ariaLabelMessage);\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\t\tconst init = () => {\n\t\t\tconst params = swiper.params.a11y;\n\t\t\tswiper.el.append(liveRegion);\n\n\t\t\t// Container\n\t\t\tconst containerEl = swiper.el;\n\t\t\tif (params.containerRoleDescriptionMessage) {\n\t\t\t\taddElRoleDescription(containerEl, params.containerRoleDescriptionMessage);\n\t\t\t}\n\t\t\tif (params.containerMessage) {\n\t\t\t\taddElLabel(containerEl, params.containerMessage);\n\t\t\t}\n\n\t\t\t// Wrapper\n\t\t\tconst wrapperEl = swiper.wrapperEl;\n\t\t\tconst wrapperId = params.id || wrapperEl.getAttribute('id') || `swiper-wrapper-${getRandomNumber(16)}`;\n\t\t\tconst live = swiper.params.autoplay && swiper.params.autoplay.enabled ? 'off' : 'polite';\n\t\t\taddElId(wrapperEl, wrapperId);\n\t\t\taddElLive(wrapperEl, live);\n\n\t\t\t// Slide\n\t\t\tinitSlides();\n\n\t\t\t// Navigation\n\t\t\tlet {\n\t\t\t\tnextEl,\n\t\t\t\tprevEl\n\t\t\t} = swiper.navigation ? swiper.navigation : {};\n\t\t\tnextEl = makeElementsArray(nextEl);\n\t\t\tprevEl = makeElementsArray(prevEl);\n\t\t\tif (nextEl) {\n\t\t\t\tnextEl.forEach(el => initNavEl(el, wrapperId, params.nextSlideMessage));\n\t\t\t}\n\t\t\tif (prevEl) {\n\t\t\t\tprevEl.forEach(el => initNavEl(el, wrapperId, params.prevSlideMessage));\n\t\t\t}\n\n\t\t\t// Pagination\n\t\t\tif (hasClickablePagination()) {\n\t\t\t\tconst paginationEl = Array.isArray(swiper.pagination.el) ? swiper.pagination.el : [swiper.pagination.el];\n\t\t\t\tpaginationEl.forEach(el => {\n\t\t\t\t\tel.addEventListener('keydown', onEnterOrSpaceKey);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Tab focus\n\t\t\tswiper.el.addEventListener('focus', handleFocus, true);\n\t\t\tswiper.el.addEventListener('pointerdown', handlePointerDown, true);\n\t\t\tswiper.el.addEventListener('pointerup', handlePointerUp, true);\n\t\t};\n\t\tfunction destroy() {\n\t\t\tif (liveRegion) liveRegion.remove();\n\t\t\tlet {\n\t\t\t\tnextEl,\n\t\t\t\tprevEl\n\t\t\t} = swiper.navigation ? swiper.navigation : {};\n\t\t\tnextEl = makeElementsArray(nextEl);\n\t\t\tprevEl = makeElementsArray(prevEl);\n\t\t\tif (nextEl) {\n\t\t\t\tnextEl.forEach(el => el.removeEventListener('keydown', onEnterOrSpaceKey));\n\t\t\t}\n\t\t\tif (prevEl) {\n\t\t\t\tprevEl.forEach(el => el.removeEventListener('keydown', onEnterOrSpaceKey));\n\t\t\t}\n\n\t\t\t// Pagination\n\t\t\tif (hasClickablePagination()) {\n\t\t\t\tconst paginationEl = Array.isArray(swiper.pagination.el) ? swiper.pagination.el : [swiper.pagination.el];\n\t\t\t\tpaginationEl.forEach(el => {\n\t\t\t\t\tel.removeEventListener('keydown', onEnterOrSpaceKey);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Tab focus\n\t\t\tswiper.el.removeEventListener('focus', handleFocus, true);\n\t\t\tswiper.el.removeEventListener('pointerdown', handlePointerDown, true);\n\t\t\tswiper.el.removeEventListener('pointerup', handlePointerUp, true);\n\t\t}\n\t\ton('beforeInit', () => {\n\t\t\tliveRegion = createElement('span', swiper.params.a11y.notificationClass);\n\t\t\tliveRegion.setAttribute('aria-live', 'assertive');\n\t\t\tliveRegion.setAttribute('aria-atomic', 'true');\n\t\t});\n\t\ton('afterInit', () => {\n\t\t\tif (!swiper.params.a11y.enabled) return;\n\t\t\tinit();\n\t\t});\n\t\ton('slidesLengthChange snapGridLengthChange slidesGridLengthChange', () => {\n\t\t\tif (!swiper.params.a11y.enabled) return;\n\t\t\tinitSlides();\n\t\t});\n\t\ton('fromEdge toEdge afterInit lock unlock', () => {\n\t\t\tif (!swiper.params.a11y.enabled) return;\n\t\t\tupdateNavigation();\n\t\t});\n\t\ton('paginationUpdate', () => {\n\t\t\tif (!swiper.params.a11y.enabled) return;\n\t\t\tupdatePagination();\n\t\t});\n\t\ton('destroy', () => {\n\t\t\tif (!swiper.params.a11y.enabled) return;\n\t\t\tdestroy();\n\t\t});\n\t}\n\n\tfunction History(_ref) {\n\t\tlet {\n\t\t\tswiper,\n\t\t\textendParams,\n\t\t\ton\n\t\t} = _ref;\n\t\textendParams({\n\t\t\thistory: {\n\t\t\t\tenabled: false,\n\t\t\t\troot: '',\n\t\t\t\treplaceState: false,\n\t\t\t\tkey: 'slides',\n\t\t\t\tkeepQuery: false\n\t\t\t}\n\t\t});\n\t\tlet initialized = false;\n\t\tlet paths = {};\n\t\tconst slugify = text => {\n\t\t\treturn text.toString().replace(/\\s+/g, '-').replace(/[^\\w-]+/g, '').replace(/--+/g, '-').replace(/^-+/, '').replace(/-+$/, '');\n\t\t};\n\t\tconst getPathValues = urlOverride => {\n\t\t\tconst window = getWindow();\n\t\t\tlet location;\n\t\t\tif (urlOverride) {\n\t\t\t\tlocation = new URL(urlOverride);\n\t\t\t} else {\n\t\t\t\tlocation = window.location;\n\t\t\t}\n\t\t\tconst pathArray = location.pathname.slice(1).split('/').filter(part => part !== '');\n\t\t\tconst total = pathArray.length;\n\t\t\tconst key = pathArray[total - 2];\n\t\t\tconst value = pathArray[total - 1];\n\t\t\treturn {\n\t\t\t\tkey,\n\t\t\t\tvalue\n\t\t\t};\n\t\t};\n\t\tconst setHistory = (key, index) => {\n\t\t\tconst window = getWindow();\n\t\t\tif (!initialized || !swiper.params.history.enabled) return;\n\t\t\tlet location;\n\t\t\tif (swiper.params.url) {\n\t\t\t\tlocation = new URL(swiper.params.url);\n\t\t\t} else {\n\t\t\t\tlocation = window.location;\n\t\t\t}\n\t\t\tconst slide = swiper.slides[index];\n\t\t\tlet value = slugify(slide.getAttribute('data-history'));\n\t\t\tif (swiper.params.history.root.length > 0) {\n\t\t\t\tlet root = swiper.params.history.root;\n\t\t\t\tif (root[root.length - 1] === '/') root = root.slice(0, root.length - 1);\n\t\t\t\tvalue = `${root}/${key ? `${key}/` : ''}${value}`;\n\t\t\t} else if (!location.pathname.includes(key)) {\n\t\t\t\tvalue = `${key ? `${key}/` : ''}${value}`;\n\t\t\t}\n\t\t\tif (swiper.params.history.keepQuery) {\n\t\t\t\tvalue += location.search;\n\t\t\t}\n\t\t\tconst currentState = window.history.state;\n\t\t\tif (currentState && currentState.value === value) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (swiper.params.history.replaceState) {\n\t\t\t\twindow.history.replaceState({\n\t\t\t\t\tvalue\n\t\t\t\t}, null, value);\n\t\t\t} else {\n\t\t\t\twindow.history.pushState({\n\t\t\t\t\tvalue\n\t\t\t\t}, null, value);\n\t\t\t}\n\t\t};\n\t\tconst scrollToSlide = (speed, value, runCallbacks) => {\n\t\t\tif (value) {\n\t\t\t\tfor (let i = 0, length = swiper.slides.length; i < length; i += 1) {\n\t\t\t\t\tconst slide = swiper.slides[i];\n\t\t\t\t\tconst slideHistory = slugify(slide.getAttribute('data-history'));\n\t\t\t\t\tif (slideHistory === value) {\n\t\t\t\t\t\tconst index = swiper.getSlideIndex(slide);\n\t\t\t\t\t\tswiper.slideTo(index, speed, runCallbacks);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tswiper.slideTo(0, speed, runCallbacks);\n\t\t\t}\n\t\t};\n\t\tconst setHistoryPopState = () => {\n\t\t\tpaths = getPathValues(swiper.params.url);\n\t\t\tscrollToSlide(swiper.params.speed, paths.value, false);\n\t\t};\n\t\tconst init = () => {\n\t\t\tconst window = getWindow();\n\t\t\tif (!swiper.params.history) return;\n\t\t\tif (!window.history || !window.history.pushState) {\n\t\t\t\tswiper.params.history.enabled = false;\n\t\t\t\tswiper.params.hashNavigation.enabled = true;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tinitialized = true;\n\t\t\tpaths = getPathValues(swiper.params.url);\n\t\t\tif (!paths.key && !paths.value) {\n\t\t\t\tif (!swiper.params.history.replaceState) {\n\t\t\t\t\twindow.addEventListener('popstate', setHistoryPopState);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tscrollToSlide(0, paths.value, swiper.params.runCallbacksOnInit);\n\t\t\tif (!swiper.params.history.replaceState) {\n\t\t\t\twindow.addEventListener('popstate', setHistoryPopState);\n\t\t\t}\n\t\t};\n\t\tconst destroy = () => {\n\t\t\tconst window = getWindow();\n\t\t\tif (!swiper.params.history.replaceState) {\n\t\t\t\twindow.removeEventListener('popstate', setHistoryPopState);\n\t\t\t}\n\t\t};\n\t\ton('init', () => {\n\t\t\tif (swiper.params.history.enabled) {\n\t\t\t\tinit();\n\t\t\t}\n\t\t});\n\t\ton('destroy', () => {\n\t\t\tif (swiper.params.history.enabled) {\n\t\t\t\tdestroy();\n\t\t\t}\n\t\t});\n\t\ton('transitionEnd _freeModeNoMomentumRelease', () => {\n\t\t\tif (initialized) {\n\t\t\t\tsetHistory(swiper.params.history.key, swiper.activeIndex);\n\t\t\t}\n\t\t});\n\t\ton('slideChange', () => {\n\t\t\tif (initialized && swiper.params.cssMode) {\n\t\t\t\tsetHistory(swiper.params.history.key, swiper.activeIndex);\n\t\t\t}\n\t\t});\n\t}\n\n\tfunction HashNavigation(_ref) {\n\t\tlet {\n\t\t\tswiper,\n\t\t\textendParams,\n\t\t\temit,\n\t\t\ton\n\t\t} = _ref;\n\t\tlet initialized = false;\n\t\tconst document = getDocument();\n\t\tconst window = getWindow();\n\t\textendParams({\n\t\t\thashNavigation: {\n\t\t\t\tenabled: false,\n\t\t\t\treplaceState: false,\n\t\t\t\twatchState: false,\n\t\t\t\tgetSlideIndex(_s, hash) {\n\t\t\t\t\tif (swiper.virtual && swiper.params.virtual.enabled) {\n\t\t\t\t\t\tconst slideWithHash = swiper.slides.filter(slideEl => slideEl.getAttribute('data-hash') === hash)[0];\n\t\t\t\t\t\tif (!slideWithHash) return 0;\n\t\t\t\t\t\tconst index = parseInt(slideWithHash.getAttribute('data-swiper-slide-index'), 10);\n\t\t\t\t\t\treturn index;\n\t\t\t\t\t}\n\t\t\t\t\treturn swiper.getSlideIndex(elementChildren(swiper.slidesEl, `.${swiper.params.slideClass}[data-hash=\"${hash}\"], swiper-slide[data-hash=\"${hash}\"]`)[0]);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tconst onHashChange = () => {\n\t\t\temit('hashChange');\n\t\t\tconst newHash = document.location.hash.replace('#', '');\n\t\t\tconst activeSlideEl = swiper.virtual && swiper.params.virtual.enabled ? swiper.slidesEl.querySelector(`[data-swiper-slide-index=\"${swiper.activeIndex}\"]`) : swiper.slides[swiper.activeIndex];\n\t\t\tconst activeSlideHash = activeSlideEl ? activeSlideEl.getAttribute('data-hash') : '';\n\t\t\tif (newHash !== activeSlideHash) {\n\t\t\t\tconst newIndex = swiper.params.hashNavigation.getSlideIndex(swiper, newHash);\n\t\t\t\tif (typeof newIndex === 'undefined' || Number.isNaN(newIndex)) return;\n\t\t\t\tswiper.slideTo(newIndex);\n\t\t\t}\n\t\t};\n\t\tconst setHash = () => {\n\t\t\tif (!initialized || !swiper.params.hashNavigation.enabled) return;\n\t\t\tconst activeSlideEl = swiper.virtual && swiper.params.virtual.enabled ? swiper.slidesEl.querySelector(`[data-swiper-slide-index=\"${swiper.activeIndex}\"]`) : swiper.slides[swiper.activeIndex];\n\t\t\tconst activeSlideHash = activeSlideEl ? activeSlideEl.getAttribute('data-hash') || activeSlideEl.getAttribute('data-history') : '';\n\t\t\tif (swiper.params.hashNavigation.replaceState && window.history && window.history.replaceState) {\n\t\t\t\twindow.history.replaceState(null, null, `#${activeSlideHash}` || '');\n\t\t\t\temit('hashSet');\n\t\t\t} else {\n\t\t\t\tdocument.location.hash = activeSlideHash || '';\n\t\t\t\temit('hashSet');\n\t\t\t}\n\t\t};\n\t\tconst init = () => {\n\t\t\tif (!swiper.params.hashNavigation.enabled || swiper.params.history && swiper.params.history.enabled) return;\n\t\t\tinitialized = true;\n\t\t\tconst hash = document.location.hash.replace('#', '');\n\t\t\tif (hash) {\n\t\t\t\tconst speed = 0;\n\t\t\t\tconst index = swiper.params.hashNavigation.getSlideIndex(swiper, hash);\n\t\t\t\tswiper.slideTo(index || 0, speed, swiper.params.runCallbacksOnInit, true);\n\t\t\t}\n\t\t\tif (swiper.params.hashNavigation.watchState) {\n\t\t\t\twindow.addEventListener('hashchange', onHashChange);\n\t\t\t}\n\t\t};\n\t\tconst destroy = () => {\n\t\t\tif (swiper.params.hashNavigation.watchState) {\n\t\t\t\twindow.removeEventListener('hashchange', onHashChange);\n\t\t\t}\n\t\t};\n\t\ton('init', () => {\n\t\t\tif (swiper.params.hashNavigation.enabled) {\n\t\t\t\tinit();\n\t\t\t}\n\t\t});\n\t\ton('destroy', () => {\n\t\t\tif (swiper.params.hashNavigation.enabled) {\n\t\t\t\tdestroy();\n\t\t\t}\n\t\t});\n\t\ton('transitionEnd _freeModeNoMomentumRelease', () => {\n\t\t\tif (initialized) {\n\t\t\t\tsetHash();\n\t\t\t}\n\t\t});\n\t\ton('slideChange', () => {\n\t\t\tif (initialized && swiper.params.cssMode) {\n\t\t\t\tsetHash();\n\t\t\t}\n\t\t});\n\t}\n\n\t/* eslint no-underscore-dangle: \"off\" */\n\t/* eslint no-use-before-define: \"off\" */\n\tfunction Autoplay(_ref) {\n\t\tlet {\n\t\t\tswiper,\n\t\t\textendParams,\n\t\t\ton,\n\t\t\temit,\n\t\t\tparams\n\t\t} = _ref;\n\t\tswiper.autoplay = {\n\t\t\trunning: false,\n\t\t\tpaused: false,\n\t\t\ttimeLeft: 0\n\t\t};\n\t\textendParams({\n\t\t\tautoplay: {\n\t\t\t\tenabled: false,\n\t\t\t\tdelay: 3000,\n\t\t\t\twaitForTransition: true,\n\t\t\t\tdisableOnInteraction: true,\n\t\t\t\tstopOnLastSlide: false,\n\t\t\t\treverseDirection: false,\n\t\t\t\tpauseOnMouseEnter: false\n\t\t\t}\n\t\t});\n\t\tlet timeout;\n\t\tlet raf;\n\t\tlet autoplayDelayTotal = params && params.autoplay ? params.autoplay.delay : 3000;\n\t\tlet autoplayDelayCurrent = params && params.autoplay ? params.autoplay.delay : 3000;\n\t\tlet autoplayTimeLeft;\n\t\tlet autoplayStartTime = new Date().getTime;\n\t\tlet wasPaused;\n\t\tlet isTouched;\n\t\tlet pausedByTouch;\n\t\tlet touchStartTimeout;\n\t\tlet slideChanged;\n\t\tlet pausedByInteraction;\n\t\tfunction onTransitionEnd(e) {\n\t\t\tif (!swiper || swiper.destroyed || !swiper.wrapperEl) return;\n\t\t\tif (e.target !== swiper.wrapperEl) return;\n\t\t\tswiper.wrapperEl.removeEventListener('transitionend', onTransitionEnd);\n\t\t\tresume();\n\t\t}\n\t\tconst calcTimeLeft = () => {\n\t\t\tif (swiper.destroyed || !swiper.autoplay.running) return;\n\t\t\tif (swiper.autoplay.paused) {\n\t\t\t\twasPaused = true;\n\t\t\t} else if (wasPaused) {\n\t\t\t\tautoplayDelayCurrent = autoplayTimeLeft;\n\t\t\t\twasPaused = false;\n\t\t\t}\n\t\t\tconst timeLeft = swiper.autoplay.paused ? autoplayTimeLeft : autoplayStartTime + autoplayDelayCurrent - new Date().getTime();\n\t\t\tswiper.autoplay.timeLeft = timeLeft;\n\t\t\temit('autoplayTimeLeft', timeLeft, timeLeft / autoplayDelayTotal);\n\t\t\traf = requestAnimationFrame(() => {\n\t\t\t\tcalcTimeLeft();\n\t\t\t});\n\t\t};\n\t\tconst getSlideDelay = () => {\n\t\t\tlet activeSlideEl;\n\t\t\tif (swiper.virtual && swiper.params.virtual.enabled) {\n\t\t\t\tactiveSlideEl = swiper.slides.filter(slideEl => slideEl.classList.contains('swiper-slide-active'))[0];\n\t\t\t} else {\n\t\t\t\tactiveSlideEl = swiper.slides[swiper.activeIndex];\n\t\t\t}\n\t\t\tif (!activeSlideEl) return undefined;\n\t\t\tconst currentSlideDelay = parseInt(activeSlideEl.getAttribute('data-swiper-autoplay'), 10);\n\t\t\treturn currentSlideDelay;\n\t\t};\n\t\tconst run = delayForce => {\n\t\t\tif (swiper.destroyed || !swiper.autoplay.running) return;\n\t\t\tcancelAnimationFrame(raf);\n\t\t\tcalcTimeLeft();\n\t\t\tlet delay = typeof delayForce === 'undefined' ? swiper.params.autoplay.delay : delayForce;\n\t\t\tautoplayDelayTotal = swiper.params.autoplay.delay;\n\t\t\tautoplayDelayCurrent = swiper.params.autoplay.delay;\n\t\t\tconst currentSlideDelay = getSlideDelay();\n\t\t\tif (!Number.isNaN(currentSlideDelay) && currentSlideDelay > 0 && typeof delayForce === 'undefined') {\n\t\t\t\tdelay = currentSlideDelay;\n\t\t\t\tautoplayDelayTotal = currentSlideDelay;\n\t\t\t\tautoplayDelayCurrent = currentSlideDelay;\n\t\t\t}\n\t\t\tautoplayTimeLeft = delay;\n\t\t\tconst speed = swiper.params.speed;\n\t\t\tconst proceed = () => {\n\t\t\t\tif (!swiper || swiper.destroyed) return;\n\t\t\t\tif (swiper.params.autoplay.reverseDirection) {\n\t\t\t\t\tif (!swiper.isBeginning || swiper.params.loop || swiper.params.rewind) {\n\t\t\t\t\t\tswiper.slidePrev(speed, true, true);\n\t\t\t\t\t\temit('autoplay');\n\t\t\t\t\t} else if (!swiper.params.autoplay.stopOnLastSlide) {\n\t\t\t\t\t\tswiper.slideTo(swiper.slides.length - 1, speed, true, true);\n\t\t\t\t\t\temit('autoplay');\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (!swiper.isEnd || swiper.params.loop || swiper.params.rewind) {\n\t\t\t\t\t\tswiper.slideNext(speed, true, true);\n\t\t\t\t\t\temit('autoplay');\n\t\t\t\t\t} else if (!swiper.params.autoplay.stopOnLastSlide) {\n\t\t\t\t\t\tswiper.slideTo(0, speed, true, true);\n\t\t\t\t\t\temit('autoplay');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (swiper.params.cssMode) {\n\t\t\t\t\tautoplayStartTime = new Date().getTime();\n\t\t\t\t\trequestAnimationFrame(() => {\n\t\t\t\t\t\trun();\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t};\n\t\t\tif (delay > 0) {\n\t\t\t\tclearTimeout(timeout);\n\t\t\t\ttimeout = setTimeout(() => {\n\t\t\t\t\tproceed();\n\t\t\t\t}, delay);\n\t\t\t} else {\n\t\t\t\trequestAnimationFrame(() => {\n\t\t\t\t\tproceed();\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// eslint-disable-next-line\n\t\t\treturn delay;\n\t\t};\n\t\tconst start = () => {\n\t\t\tswiper.autoplay.running = true;\n\t\t\trun();\n\t\t\temit('autoplayStart');\n\t\t};\n\t\tconst stop = () => {\n\t\t\tswiper.autoplay.running = false;\n\t\t\tclearTimeout(timeout);\n\t\t\tcancelAnimationFrame(raf);\n\t\t\temit('autoplayStop');\n\t\t};\n\t\tconst pause = (internal, reset) => {\n\t\t\tif (swiper.destroyed || !swiper.autoplay.running) return;\n\t\t\tclearTimeout(timeout);\n\t\t\tif (!internal) {\n\t\t\t\tpausedByInteraction = true;\n\t\t\t}\n\t\t\tconst proceed = () => {\n\t\t\t\temit('autoplayPause');\n\t\t\t\tif (swiper.params.autoplay.waitForTransition) {\n\t\t\t\t\tswiper.wrapperEl.addEventListener('transitionend', onTransitionEnd);\n\t\t\t\t} else {\n\t\t\t\t\tresume();\n\t\t\t\t}\n\t\t\t};\n\t\t\tswiper.autoplay.paused = true;\n\t\t\tif (reset) {\n\t\t\t\tif (slideChanged) {\n\t\t\t\t\tautoplayTimeLeft = swiper.params.autoplay.delay;\n\t\t\t\t}\n\t\t\t\tslideChanged = false;\n\t\t\t\tproceed();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst delay = autoplayTimeLeft || swiper.params.autoplay.delay;\n\t\t\tautoplayTimeLeft = delay - (new Date().getTime() - autoplayStartTime);\n\t\t\tif (swiper.isEnd && autoplayTimeLeft < 0 && !swiper.params.loop) return;\n\t\t\tif (autoplayTimeLeft < 0) autoplayTimeLeft = 0;\n\t\t\tproceed();\n\t\t};\n\t\tconst resume = () => {\n\t\t\tif (swiper.isEnd && autoplayTimeLeft < 0 && !swiper.params.loop || swiper.destroyed || !swiper.autoplay.running) return;\n\t\t\tautoplayStartTime = new Date().getTime();\n\t\t\tif (pausedByInteraction) {\n\t\t\t\tpausedByInteraction = false;\n\t\t\t\trun(autoplayTimeLeft);\n\t\t\t} else {\n\t\t\t\trun();\n\t\t\t}\n\t\t\tswiper.autoplay.paused = false;\n\t\t\temit('autoplayResume');\n\t\t};\n\t\tconst onVisibilityChange = () => {\n\t\t\tif (swiper.destroyed || !swiper.autoplay.running) return;\n\t\t\tconst document = getDocument();\n\t\t\tif (document.visibilityState === 'hidden') {\n\t\t\t\tpausedByInteraction = true;\n\t\t\t\tpause(true);\n\t\t\t}\n\t\t\tif (document.visibilityState === 'visible') {\n\t\t\t\tresume();\n\t\t\t}\n\t\t};\n\t\tconst onPointerEnter = e => {\n\t\t\tif (e.pointerType !== 'mouse') return;\n\t\t\tpausedByInteraction = true;\n\t\t\tif (swiper.animating || swiper.autoplay.paused) return;\n\t\t\tpause(true);\n\t\t};\n\t\tconst onPointerLeave = e => {\n\t\t\tif (e.pointerType !== 'mouse') return;\n\t\t\tif (swiper.autoplay.paused) {\n\t\t\t\tresume();\n\t\t\t}\n\t\t};\n\t\tconst attachMouseEvents = () => {\n\t\t\tif (swiper.params.autoplay.pauseOnMouseEnter) {\n\t\t\t\tswiper.el.addEventListener('pointerenter', onPointerEnter);\n\t\t\t\tswiper.el.addEventListener('pointerleave', onPointerLeave);\n\t\t\t}\n\t\t};\n\t\tconst detachMouseEvents = () => {\n\t\t\tswiper.el.removeEventListener('pointerenter', onPointerEnter);\n\t\t\tswiper.el.removeEventListener('pointerleave', onPointerLeave);\n\t\t};\n\t\tconst attachDocumentEvents = () => {\n\t\t\tconst document = getDocument();\n\t\t\tdocument.addEventListener('visibilitychange', onVisibilityChange);\n\t\t};\n\t\tconst detachDocumentEvents = () => {\n\t\t\tconst document = getDocument();\n\t\t\tdocument.removeEventListener('visibilitychange', onVisibilityChange);\n\t\t};\n\t\ton('init', () => {\n\t\t\tif (swiper.params.autoplay.enabled) {\n\t\t\t\tattachMouseEvents();\n\t\t\t\tattachDocumentEvents();\n\t\t\t\tautoplayStartTime = new Date().getTime();\n\t\t\t\tstart();\n\t\t\t}\n\t\t});\n\t\ton('destroy', () => {\n\t\t\tdetachMouseEvents();\n\t\t\tdetachDocumentEvents();\n\t\t\tif (swiper.autoplay.running) {\n\t\t\t\tstop();\n\t\t\t}\n\t\t});\n\t\ton('beforeTransitionStart', (_s, speed, internal) => {\n\t\t\tif (swiper.destroyed || !swiper.autoplay.running) return;\n\t\t\tif (internal || !swiper.params.autoplay.disableOnInteraction) {\n\t\t\t\tpause(true, true);\n\t\t\t} else {\n\t\t\t\tstop();\n\t\t\t}\n\t\t});\n\t\ton('sliderFirstMove', () => {\n\t\t\tif (swiper.destroyed || !swiper.autoplay.running) return;\n\t\t\tif (swiper.params.autoplay.disableOnInteraction) {\n\t\t\t\tstop();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tisTouched = true;\n\t\t\tpausedByTouch = false;\n\t\t\tpausedByInteraction = false;\n\t\t\ttouchStartTimeout = setTimeout(() => {\n\t\t\t\tpausedByInteraction = true;\n\t\t\t\tpausedByTouch = true;\n\t\t\t\tpause(true);\n\t\t\t}, 200);\n\t\t});\n\t\ton('touchEnd', () => {\n\t\t\tif (swiper.destroyed || !swiper.autoplay.running || !isTouched) return;\n\t\t\tclearTimeout(touchStartTimeout);\n\t\t\tclearTimeout(timeout);\n\t\t\tif (swiper.params.autoplay.disableOnInteraction) {\n\t\t\t\tpausedByTouch = false;\n\t\t\t\tisTouched = false;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (pausedByTouch && swiper.params.cssMode) resume();\n\t\t\tpausedByTouch = false;\n\t\t\tisTouched = false;\n\t\t});\n\t\ton('slideChange', () => {\n\t\t\tif (swiper.destroyed || !swiper.autoplay.running) return;\n\t\t\tslideChanged = true;\n\t\t});\n\t\tObject.assign(swiper.autoplay, {\n\t\t\tstart,\n\t\t\tstop,\n\t\t\tpause,\n\t\t\tresume\n\t\t});\n\t}\n\n\tfunction Thumb(_ref) {\n\t\tlet {\n\t\t\tswiper,\n\t\t\textendParams,\n\t\t\ton\n\t\t} = _ref;\n\t\textendParams({\n\t\t\tthumbs: {\n\t\t\t\tswiper: null,\n\t\t\t\tmultipleActiveThumbs: true,\n\t\t\t\tautoScrollOffset: 0,\n\t\t\t\tslideThumbActiveClass: 'swiper-slide-thumb-active',\n\t\t\t\tthumbsContainerClass: 'swiper-thumbs'\n\t\t\t}\n\t\t});\n\t\tlet initialized = false;\n\t\tlet swiperCreated = false;\n\t\tswiper.thumbs = {\n\t\t\tswiper: null\n\t\t};\n\t\tfunction onThumbClick() {\n\t\t\tconst thumbsSwiper = swiper.thumbs.swiper;\n\t\t\tif (!thumbsSwiper || thumbsSwiper.destroyed) return;\n\t\t\tconst clickedIndex = thumbsSwiper.clickedIndex;\n\t\t\tconst clickedSlide = thumbsSwiper.clickedSlide;\n\t\t\tif (clickedSlide && clickedSlide.classList.contains(swiper.params.thumbs.slideThumbActiveClass)) return;\n\t\t\tif (typeof clickedIndex === 'undefined' || clickedIndex === null) return;\n\t\t\tlet slideToIndex;\n\t\t\tif (thumbsSwiper.params.loop) {\n\t\t\t\tslideToIndex = parseInt(thumbsSwiper.clickedSlide.getAttribute('data-swiper-slide-index'), 10);\n\t\t\t} else {\n\t\t\t\tslideToIndex = clickedIndex;\n\t\t\t}\n\t\t\tif (swiper.params.loop) {\n\t\t\t\tswiper.slideToLoop(slideToIndex);\n\t\t\t} else {\n\t\t\t\tswiper.slideTo(slideToIndex);\n\t\t\t}\n\t\t}\n\t\tfunction init() {\n\t\t\tconst {\n\t\t\t\tthumbs: thumbsParams\n\t\t\t} = swiper.params;\n\t\t\tif (initialized) return false;\n\t\t\tinitialized = true;\n\t\t\tconst SwiperClass = swiper.constructor;\n\t\t\tif (thumbsParams.swiper instanceof SwiperClass) {\n\t\t\t\tswiper.thumbs.swiper = thumbsParams.swiper;\n\t\t\t\tObject.assign(swiper.thumbs.swiper.originalParams, {\n\t\t\t\t\twatchSlidesProgress: true,\n\t\t\t\t\tslideToClickedSlide: false\n\t\t\t\t});\n\t\t\t\tObject.assign(swiper.thumbs.swiper.params, {\n\t\t\t\t\twatchSlidesProgress: true,\n\t\t\t\t\tslideToClickedSlide: false\n\t\t\t\t});\n\t\t\t\tswiper.thumbs.swiper.update();\n\t\t\t} else if (isObject(thumbsParams.swiper)) {\n\t\t\t\tconst thumbsSwiperParams = Object.assign({}, thumbsParams.swiper);\n\t\t\t\tObject.assign(thumbsSwiperParams, {\n\t\t\t\t\twatchSlidesProgress: true,\n\t\t\t\t\tslideToClickedSlide: false\n\t\t\t\t});\n\t\t\t\tswiper.thumbs.swiper = new SwiperClass(thumbsSwiperParams);\n\t\t\t\tswiperCreated = true;\n\t\t\t}\n\t\t\tswiper.thumbs.swiper.el.classList.add(swiper.params.thumbs.thumbsContainerClass);\n\t\t\tswiper.thumbs.swiper.on('tap', onThumbClick);\n\t\t\treturn true;\n\t\t}\n\t\tfunction update(initial) {\n\t\t\tconst thumbsSwiper = swiper.thumbs.swiper;\n\t\t\tif (!thumbsSwiper || thumbsSwiper.destroyed) return;\n\t\t\tconst slidesPerView = thumbsSwiper.params.slidesPerView === 'auto' ? thumbsSwiper.slidesPerViewDynamic() : thumbsSwiper.params.slidesPerView;\n\n\t\t\t// Activate thumbs\n\t\t\tlet thumbsToActivate = 1;\n\t\t\tconst thumbActiveClass = swiper.params.thumbs.slideThumbActiveClass;\n\t\t\tif (swiper.params.slidesPerView > 1 && !swiper.params.centeredSlides) {\n\t\t\t\tthumbsToActivate = swiper.params.slidesPerView;\n\t\t\t}\n\t\t\tif (!swiper.params.thumbs.multipleActiveThumbs) {\n\t\t\t\tthumbsToActivate = 1;\n\t\t\t}\n\t\t\tthumbsToActivate = Math.floor(thumbsToActivate);\n\t\t\tthumbsSwiper.slides.forEach(slideEl => slideEl.classList.remove(thumbActiveClass));\n\t\t\tif (thumbsSwiper.params.loop || thumbsSwiper.params.virtual && thumbsSwiper.params.virtual.enabled) {\n\t\t\t\tfor (let i = 0; i < thumbsToActivate; i += 1) {\n\t\t\t\t\telementChildren(thumbsSwiper.slidesEl, `[data-swiper-slide-index=\"${swiper.realIndex + i}\"]`).forEach(slideEl => {\n\t\t\t\t\t\tslideEl.classList.add(thumbActiveClass);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (let i = 0; i < thumbsToActivate; i += 1) {\n\t\t\t\t\tif (thumbsSwiper.slides[swiper.realIndex + i]) {\n\t\t\t\t\t\tthumbsSwiper.slides[swiper.realIndex + i].classList.add(thumbActiveClass);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst autoScrollOffset = swiper.params.thumbs.autoScrollOffset;\n\t\t\tconst useOffset = autoScrollOffset && !thumbsSwiper.params.loop;\n\t\t\tif (swiper.realIndex !== thumbsSwiper.realIndex || useOffset) {\n\t\t\t\tconst currentThumbsIndex = thumbsSwiper.activeIndex;\n\t\t\t\tlet newThumbsIndex;\n\t\t\t\tlet direction;\n\t\t\t\tif (thumbsSwiper.params.loop) {\n\t\t\t\t\tconst newThumbsSlide = thumbsSwiper.slides.filter(slideEl => slideEl.getAttribute('data-swiper-slide-index') === `${swiper.realIndex}`)[0];\n\t\t\t\t\tnewThumbsIndex = thumbsSwiper.slides.indexOf(newThumbsSlide);\n\t\t\t\t\tdirection = swiper.activeIndex > swiper.previousIndex ? 'next' : 'prev';\n\t\t\t\t} else {\n\t\t\t\t\tnewThumbsIndex = swiper.realIndex;\n\t\t\t\t\tdirection = newThumbsIndex > swiper.previousIndex ? 'next' : 'prev';\n\t\t\t\t}\n\t\t\t\tif (useOffset) {\n\t\t\t\t\tnewThumbsIndex += direction === 'next' ? autoScrollOffset : -1 * autoScrollOffset;\n\t\t\t\t}\n\t\t\t\tif (thumbsSwiper.visibleSlidesIndexes && thumbsSwiper.visibleSlidesIndexes.indexOf(newThumbsIndex) < 0) {\n\t\t\t\t\tif (thumbsSwiper.params.centeredSlides) {\n\t\t\t\t\t\tif (newThumbsIndex > currentThumbsIndex) {\n\t\t\t\t\t\t\tnewThumbsIndex = newThumbsIndex - Math.floor(slidesPerView / 2) + 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnewThumbsIndex = newThumbsIndex + Math.floor(slidesPerView / 2) - 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (newThumbsIndex > currentThumbsIndex && thumbsSwiper.params.slidesPerGroup === 1);\n\t\t\t\t\tthumbsSwiper.slideTo(newThumbsIndex, initial ? 0 : undefined);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ton('beforeInit', () => {\n\t\t\tconst {\n\t\t\t\tthumbs\n\t\t\t} = swiper.params;\n\t\t\tif (!thumbs || !thumbs.swiper) return;\n\t\t\tif (typeof thumbs.swiper === 'string' || thumbs.swiper instanceof HTMLElement) {\n\t\t\t\tconst document = getDocument();\n\t\t\t\tconst getThumbsElementAndInit = () => {\n\t\t\t\t\tconst thumbsElement = typeof thumbs.swiper === 'string' ? document.querySelector(thumbs.swiper) : thumbs.swiper;\n\t\t\t\t\tif (thumbsElement && thumbsElement.swiper) {\n\t\t\t\t\t\tthumbs.swiper = thumbsElement.swiper;\n\t\t\t\t\t\tinit();\n\t\t\t\t\t\tupdate(true);\n\t\t\t\t\t} else if (thumbsElement) {\n\t\t\t\t\t\tconst onThumbsSwiper = e => {\n\t\t\t\t\t\t\tthumbs.swiper = e.detail[0];\n\t\t\t\t\t\t\tthumbsElement.removeEventListener('init', onThumbsSwiper);\n\t\t\t\t\t\t\tinit();\n\t\t\t\t\t\t\tupdate(true);\n\t\t\t\t\t\t\tthumbs.swiper.update();\n\t\t\t\t\t\t\tswiper.update();\n\t\t\t\t\t\t};\n\t\t\t\t\t\tthumbsElement.addEventListener('init', onThumbsSwiper);\n\t\t\t\t\t}\n\t\t\t\t\treturn thumbsElement;\n\t\t\t\t};\n\t\t\t\tconst watchForThumbsToAppear = () => {\n\t\t\t\t\tif (swiper.destroyed) return;\n\t\t\t\t\tconst thumbsElement = getThumbsElementAndInit();\n\t\t\t\t\tif (!thumbsElement) {\n\t\t\t\t\t\trequestAnimationFrame(watchForThumbsToAppear);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\trequestAnimationFrame(watchForThumbsToAppear);\n\t\t\t} else {\n\t\t\t\tinit();\n\t\t\t\tupdate(true);\n\t\t\t}\n\t\t});\n\t\ton('slideChange update resize observerUpdate', () => {\n\t\t\tupdate();\n\t\t});\n\t\ton('setTransition', (_s, duration) => {\n\t\t\tconst thumbsSwiper = swiper.thumbs.swiper;\n\t\t\tif (!thumbsSwiper || thumbsSwiper.destroyed) return;\n\t\t\tthumbsSwiper.setTransition(duration);\n\t\t});\n\t\ton('beforeDestroy', () => {\n\t\t\tconst thumbsSwiper = swiper.thumbs.swiper;\n\t\t\tif (!thumbsSwiper || thumbsSwiper.destroyed) return;\n\t\t\tif (swiperCreated) {\n\t\t\t\tthumbsSwiper.destroy();\n\t\t\t}\n\t\t});\n\t\tObject.assign(swiper.thumbs, {\n\t\t\tinit,\n\t\t\tupdate\n\t\t});\n\t}\n\n\tfunction freeMode(_ref) {\n\t\tlet {\n\t\t\tswiper,\n\t\t\textendParams,\n\t\t\temit,\n\t\t\tonce\n\t\t} = _ref;\n\t\textendParams({\n\t\t\tfreeMode: {\n\t\t\t\tenabled: false,\n\t\t\t\tmomentum: true,\n\t\t\t\tmomentumRatio: 1,\n\t\t\t\tmomentumBounce: true,\n\t\t\t\tmomentumBounceRatio: 1,\n\t\t\t\tmomentumVelocityRatio: 1,\n\t\t\t\tsticky: false,\n\t\t\t\tminimumVelocity: 0.02\n\t\t\t}\n\t\t});\n\t\tfunction onTouchStart() {\n\t\t\tif (swiper.params.cssMode) return;\n\t\t\tconst translate = swiper.getTranslate();\n\t\t\tswiper.setTranslate(translate);\n\t\t\tswiper.setTransition(0);\n\t\t\tswiper.touchEventsData.velocities.length = 0;\n\t\t\tswiper.freeMode.onTouchEnd({\n\t\t\t\tcurrentPos: swiper.rtl ? swiper.translate : -swiper.translate\n\t\t\t});\n\t\t}\n\t\tfunction onTouchMove() {\n\t\t\tif (swiper.params.cssMode) return;\n\t\t\tconst {\n\t\t\t\ttouchEventsData: data,\n\t\t\t\ttouches\n\t\t\t} = swiper;\n\t\t\t// Velocity\n\t\t\tif (data.velocities.length === 0) {\n\t\t\t\tdata.velocities.push({\n\t\t\t\t\tposition: touches[swiper.isHorizontal() ? 'startX' : 'startY'],\n\t\t\t\t\ttime: data.touchStartTime\n\t\t\t\t});\n\t\t\t}\n\t\t\tdata.velocities.push({\n\t\t\t\tposition: touches[swiper.isHorizontal() ? 'currentX' : 'currentY'],\n\t\t\t\ttime: now()\n\t\t\t});\n\t\t}\n\t\tfunction onTouchEnd(_ref2) {\n\t\t\tlet {\n\t\t\t\tcurrentPos\n\t\t\t} = _ref2;\n\t\t\tif (swiper.params.cssMode) return;\n\t\t\tconst {\n\t\t\t\tparams,\n\t\t\t\twrapperEl,\n\t\t\t\trtlTranslate: rtl,\n\t\t\t\tsnapGrid,\n\t\t\t\ttouchEventsData: data\n\t\t\t} = swiper;\n\t\t\t// Time diff\n\t\t\tconst touchEndTime = now();\n\t\t\tconst timeDiff = touchEndTime - data.touchStartTime;\n\t\t\tif (currentPos < -swiper.minTranslate()) {\n\t\t\t\tswiper.slideTo(swiper.activeIndex);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (currentPos > -swiper.maxTranslate()) {\n\t\t\t\tif (swiper.slides.length < snapGrid.length) {\n\t\t\t\t\tswiper.slideTo(snapGrid.length - 1);\n\t\t\t\t} else {\n\t\t\t\t\tswiper.slideTo(swiper.slides.length - 1);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (params.freeMode.momentum) {\n\t\t\t\tif (data.velocities.length > 1) {\n\t\t\t\t\tconst lastMoveEvent = data.velocities.pop();\n\t\t\t\t\tconst velocityEvent = data.velocities.pop();\n\t\t\t\t\tconst distance = lastMoveEvent.position - velocityEvent.position;\n\t\t\t\t\tconst time = lastMoveEvent.time - velocityEvent.time;\n\t\t\t\t\tswiper.velocity = distance / time;\n\t\t\t\t\tswiper.velocity /= 2;\n\t\t\t\t\tif (Math.abs(swiper.velocity) < params.freeMode.minimumVelocity) {\n\t\t\t\t\t\tswiper.velocity = 0;\n\t\t\t\t\t}\n\t\t\t\t\t// this implies that the user stopped moving a finger then released.\n\t\t\t\t\t// There would be no events with distance zero, so the last event is stale.\n\t\t\t\t\tif (time > 150 || now() - lastMoveEvent.time > 300) {\n\t\t\t\t\t\tswiper.velocity = 0;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tswiper.velocity = 0;\n\t\t\t\t}\n\t\t\t\tswiper.velocity *= params.freeMode.momentumVelocityRatio;\n\t\t\t\tdata.velocities.length = 0;\n\t\t\t\tlet momentumDuration = 1000 * params.freeMode.momentumRatio;\n\t\t\t\tconst momentumDistance = swiper.velocity * momentumDuration;\n\t\t\t\tlet newPosition = swiper.translate + momentumDistance;\n\t\t\t\tif (rtl) newPosition = -newPosition;\n\t\t\t\tlet doBounce = false;\n\t\t\t\tlet afterBouncePosition;\n\t\t\t\tconst bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeMode.momentumBounceRatio;\n\t\t\t\tlet needsLoopFix;\n\t\t\t\tif (newPosition < swiper.maxTranslate()) {\n\t\t\t\t\tif (params.freeMode.momentumBounce) {\n\t\t\t\t\t\tif (newPosition + swiper.maxTranslate() < -bounceAmount) {\n\t\t\t\t\t\t\tnewPosition = swiper.maxTranslate() - bounceAmount;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tafterBouncePosition = swiper.maxTranslate();\n\t\t\t\t\t\tdoBounce = true;\n\t\t\t\t\t\tdata.allowMomentumBounce = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnewPosition = swiper.maxTranslate();\n\t\t\t\t\t}\n\t\t\t\t\tif (params.loop && params.centeredSlides) needsLoopFix = true;\n\t\t\t\t} else if (newPosition > swiper.minTranslate()) {\n\t\t\t\t\tif (params.freeMode.momentumBounce) {\n\t\t\t\t\t\tif (newPosition - swiper.minTranslate() > bounceAmount) {\n\t\t\t\t\t\t\tnewPosition = swiper.minTranslate() + bounceAmount;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tafterBouncePosition = swiper.minTranslate();\n\t\t\t\t\t\tdoBounce = true;\n\t\t\t\t\t\tdata.allowMomentumBounce = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnewPosition = swiper.minTranslate();\n\t\t\t\t\t}\n\t\t\t\t\tif (params.loop && params.centeredSlides) needsLoopFix = true;\n\t\t\t\t} else if (params.freeMode.sticky) {\n\t\t\t\t\tlet nextSlide;\n\t\t\t\t\tfor (let j = 0; j < snapGrid.length; j += 1) {\n\t\t\t\t\t\tif (snapGrid[j] > -newPosition) {\n\t\t\t\t\t\t\tnextSlide = j;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === 'next') {\n\t\t\t\t\t\tnewPosition = snapGrid[nextSlide];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnewPosition = snapGrid[nextSlide - 1];\n\t\t\t\t\t}\n\t\t\t\t\tnewPosition = -newPosition;\n\t\t\t\t}\n\t\t\t\tif (needsLoopFix) {\n\t\t\t\t\tonce('transitionEnd', () => {\n\t\t\t\t\t\tswiper.loopFix();\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t// Fix duration\n\t\t\t\tif (swiper.velocity !== 0) {\n\t\t\t\t\tif (rtl) {\n\t\t\t\t\t\tmomentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmomentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);\n\t\t\t\t\t}\n\t\t\t\t\tif (params.freeMode.sticky) {\n\t\t\t\t\t\t// If freeMode.sticky is active and the user ends a swipe with a slow-velocity\n\t\t\t\t\t\t// event, then durations can be 20+ seconds to slide one (or zero!) slides.\n\t\t\t\t\t\t// It's easy to see this when simulating touch with mouse events. To fix this,\n\t\t\t\t\t\t// limit single-slide swipes to the default slide duration. This also has the\n\t\t\t\t\t\t// nice side effect of matching slide speed if the user stopped moving before\n\t\t\t\t\t\t// lifting finger or mouse vs. moving slowly before lifting the finger/mouse.\n\t\t\t\t\t\t// For faster swipes, also apply limits (albeit higher ones).\n\t\t\t\t\t\tconst moveDistance = Math.abs((rtl ? -newPosition : newPosition) - swiper.translate);\n\t\t\t\t\t\tconst currentSlideSize = swiper.slidesSizesGrid[swiper.activeIndex];\n\t\t\t\t\t\tif (moveDistance < currentSlideSize) {\n\t\t\t\t\t\t\tmomentumDuration = params.speed;\n\t\t\t\t\t\t} else if (moveDistance < 2 * currentSlideSize) {\n\t\t\t\t\t\t\tmomentumDuration = params.speed * 1.5;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tmomentumDuration = params.speed * 2.5;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (params.freeMode.sticky) {\n\t\t\t\t\tswiper.slideToClosest();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (params.freeMode.momentumBounce && doBounce) {\n\t\t\t\t\tswiper.updateProgress(afterBouncePosition);\n\t\t\t\t\tswiper.setTransition(momentumDuration);\n\t\t\t\t\tswiper.setTranslate(newPosition);\n\t\t\t\t\tswiper.transitionStart(true, swiper.swipeDirection);\n\t\t\t\t\tswiper.animating = true;\n\t\t\t\t\telementTransitionEnd(wrapperEl, () => {\n\t\t\t\t\t\tif (!swiper || swiper.destroyed || !data.allowMomentumBounce) return;\n\t\t\t\t\t\temit('momentumBounce');\n\t\t\t\t\t\tswiper.setTransition(params.speed);\n\t\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\t\tswiper.setTranslate(afterBouncePosition);\n\t\t\t\t\t\t\telementTransitionEnd(wrapperEl, () => {\n\t\t\t\t\t\t\t\tif (!swiper || swiper.destroyed) return;\n\t\t\t\t\t\t\t\tswiper.transitionEnd();\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}, 0);\n\t\t\t\t\t});\n\t\t\t\t} else if (swiper.velocity) {\n\t\t\t\t\temit('_freeModeNoMomentumRelease');\n\t\t\t\t\tswiper.updateProgress(newPosition);\n\t\t\t\t\tswiper.setTransition(momentumDuration);\n\t\t\t\t\tswiper.setTranslate(newPosition);\n\t\t\t\t\tswiper.transitionStart(true, swiper.swipeDirection);\n\t\t\t\t\tif (!swiper.animating) {\n\t\t\t\t\t\tswiper.animating = true;\n\t\t\t\t\t\telementTransitionEnd(wrapperEl, () => {\n\t\t\t\t\t\t\tif (!swiper || swiper.destroyed) return;\n\t\t\t\t\t\t\tswiper.transitionEnd();\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tswiper.updateProgress(newPosition);\n\t\t\t\t}\n\t\t\t\tswiper.updateActiveIndex();\n\t\t\t\tswiper.updateSlidesClasses();\n\t\t\t} else if (params.freeMode.sticky) {\n\t\t\t\tswiper.slideToClosest();\n\t\t\t\treturn;\n\t\t\t} else if (params.freeMode) {\n\t\t\t\temit('_freeModeNoMomentumRelease');\n\t\t\t}\n\t\t\tif (!params.freeMode.momentum || timeDiff >= params.longSwipesMs) {\n\t\t\t\tswiper.updateProgress();\n\t\t\t\tswiper.updateActiveIndex();\n\t\t\t\tswiper.updateSlidesClasses();\n\t\t\t}\n\t\t}\n\t\tObject.assign(swiper, {\n\t\t\tfreeMode: {\n\t\t\t\tonTouchStart,\n\t\t\t\tonTouchMove,\n\t\t\t\tonTouchEnd\n\t\t\t}\n\t\t});\n\t}\n\n\tfunction Grid(_ref) {\n\t\tlet {\n\t\t\tswiper,\n\t\t\textendParams\n\t\t} = _ref;\n\t\textendParams({\n\t\t\tgrid: {\n\t\t\t\trows: 1,\n\t\t\t\tfill: 'column'\n\t\t\t}\n\t\t});\n\t\tlet slidesNumberEvenToRows;\n\t\tlet slidesPerRow;\n\t\tlet numFullColumns;\n\t\tconst getSpaceBetween = () => {\n\t\t\tlet spaceBetween = swiper.params.spaceBetween;\n\t\t\tif (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {\n\t\t\t\tspaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiper.size;\n\t\t\t} else if (typeof spaceBetween === 'string') {\n\t\t\t\tspaceBetween = parseFloat(spaceBetween);\n\t\t\t}\n\t\t\treturn spaceBetween;\n\t\t};\n\t\tconst initSlides = slidesLength => {\n\t\t\tconst {\n\t\t\t\tslidesPerView\n\t\t\t} = swiper.params;\n\t\t\tconst {\n\t\t\t\trows,\n\t\t\t\tfill\n\t\t\t} = swiper.params.grid;\n\t\t\tnumFullColumns = Math.floor(slidesLength / rows);\n\t\t\tif (Math.floor(slidesLength / rows) === slidesLength / rows) {\n\t\t\t\tslidesNumberEvenToRows = slidesLength;\n\t\t\t} else {\n\t\t\t\tslidesNumberEvenToRows = Math.ceil(slidesLength / rows) * rows;\n\t\t\t}\n\t\t\tif (slidesPerView !== 'auto' && fill === 'row') {\n\t\t\t\tslidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, slidesPerView * rows);\n\t\t\t}\n\t\t\tslidesPerRow = slidesNumberEvenToRows / rows;\n\t\t};\n\t\tconst updateSlide = (i, slide, slidesLength, getDirectionLabel) => {\n\t\t\tconst {\n\t\t\t\tslidesPerGroup\n\t\t\t} = swiper.params;\n\t\t\tconst spaceBetween = getSpaceBetween();\n\t\t\tconst {\n\t\t\t\trows,\n\t\t\t\tfill\n\t\t\t} = swiper.params.grid;\n\t\t\t// Set slides order\n\t\t\tlet newSlideOrderIndex;\n\t\t\tlet column;\n\t\t\tlet row;\n\t\t\tif (fill === 'row' && slidesPerGroup > 1) {\n\t\t\t\tconst groupIndex = Math.floor(i / (slidesPerGroup * rows));\n\t\t\t\tconst slideIndexInGroup = i - rows * slidesPerGroup * groupIndex;\n\t\t\t\tconst columnsInGroup = groupIndex === 0 ? slidesPerGroup : Math.min(Math.ceil((slidesLength - groupIndex * rows * slidesPerGroup) / rows), slidesPerGroup);\n\t\t\t\trow = Math.floor(slideIndexInGroup / columnsInGroup);\n\t\t\t\tcolumn = slideIndexInGroup - row * columnsInGroup + groupIndex * slidesPerGroup;\n\t\t\t\tnewSlideOrderIndex = column + row * slidesNumberEvenToRows / rows;\n\t\t\t\tslide.style.order = newSlideOrderIndex;\n\t\t\t} else if (fill === 'column') {\n\t\t\t\tcolumn = Math.floor(i / rows);\n\t\t\t\trow = i - column * rows;\n\t\t\t\tif (column > numFullColumns || column === numFullColumns && row === rows - 1) {\n\t\t\t\t\trow += 1;\n\t\t\t\t\tif (row >= rows) {\n\t\t\t\t\t\trow = 0;\n\t\t\t\t\t\tcolumn += 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trow = Math.floor(i / slidesPerRow);\n\t\t\t\tcolumn = i - row * slidesPerRow;\n\t\t\t}\n\t\t\tslide.row = row;\n\t\t\tslide.column = column;\n\t\t\tslide.style[getDirectionLabel('margin-top')] = row !== 0 ? spaceBetween && `${spaceBetween}px` : '';\n\t\t};\n\t\tconst updateWrapperSize = (slideSize, snapGrid, getDirectionLabel) => {\n\t\t\tconst {\n\t\t\t\tcenteredSlides,\n\t\t\t\troundLengths\n\t\t\t} = swiper.params;\n\t\t\tconst spaceBetween = getSpaceBetween();\n\t\t\tconst {\n\t\t\t\trows\n\t\t\t} = swiper.params.grid;\n\t\t\tswiper.virtualSize = (slideSize + spaceBetween) * slidesNumberEvenToRows;\n\t\t\tswiper.virtualSize = Math.ceil(swiper.virtualSize / rows) - spaceBetween;\n\t\t\tswiper.wrapperEl.style[getDirectionLabel('width')] = `${swiper.virtualSize + spaceBetween}px`;\n\t\t\tif (centeredSlides) {\n\t\t\t\tconst newSlidesGrid = [];\n\t\t\t\tfor (let i = 0; i < snapGrid.length; i += 1) {\n\t\t\t\t\tlet slidesGridItem = snapGrid[i];\n\t\t\t\t\tif (roundLengths) slidesGridItem = Math.floor(slidesGridItem);\n\t\t\t\t\tif (snapGrid[i] < swiper.virtualSize + snapGrid[0]) newSlidesGrid.push(slidesGridItem);\n\t\t\t\t}\n\t\t\t\tsnapGrid.splice(0, snapGrid.length);\n\t\t\t\tsnapGrid.push(...newSlidesGrid);\n\t\t\t}\n\t\t};\n\t\tswiper.grid = {\n\t\t\tinitSlides,\n\t\t\tupdateSlide,\n\t\t\tupdateWrapperSize\n\t\t};\n\t}\n\n\tfunction appendSlide(slides) {\n\t\tconst swiper = this;\n\t\tconst {\n\t\t\tparams,\n\t\t\tslidesEl\n\t\t} = swiper;\n\t\tif (params.loop) {\n\t\t\tswiper.loopDestroy();\n\t\t}\n\t\tconst appendElement = slideEl => {\n\t\t\tif (typeof slideEl === 'string') {\n\t\t\t\tconst tempDOM = document.createElement('div');\n\t\t\t\ttempDOM.innerHTML = slideEl;\n\t\t\t\tslidesEl.append(tempDOM.children[0]);\n\t\t\t\ttempDOM.innerHTML = '';\n\t\t\t} else {\n\t\t\t\tslidesEl.append(slideEl);\n\t\t\t}\n\t\t};\n\t\tif (typeof slides === 'object' && 'length' in slides) {\n\t\t\tfor (let i = 0; i < slides.length; i += 1) {\n\t\t\t\tif (slides[i]) appendElement(slides[i]);\n\t\t\t}\n\t\t} else {\n\t\t\tappendElement(slides);\n\t\t}\n\t\tswiper.recalcSlides();\n\t\tif (params.loop) {\n\t\t\tswiper.loopCreate();\n\t\t}\n\t\tif (!params.observer || swiper.isElement) {\n\t\t\tswiper.update();\n\t\t}\n\t}\n\n\tfunction prependSlide(slides) {\n\t\tconst swiper = this;\n\t\tconst {\n\t\t\tparams,\n\t\t\tactiveIndex,\n\t\t\tslidesEl\n\t\t} = swiper;\n\t\tif (params.loop) {\n\t\t\tswiper.loopDestroy();\n\t\t}\n\t\tlet newActiveIndex = activeIndex + 1;\n\t\tconst prependElement = slideEl => {\n\t\t\tif (typeof slideEl === 'string') {\n\t\t\t\tconst tempDOM = document.createElement('div');\n\t\t\t\ttempDOM.innerHTML = slideEl;\n\t\t\t\tslidesEl.prepend(tempDOM.children[0]);\n\t\t\t\ttempDOM.innerHTML = '';\n\t\t\t} else {\n\t\t\t\tslidesEl.prepend(slideEl);\n\t\t\t}\n\t\t};\n\t\tif (typeof slides === 'object' && 'length' in slides) {\n\t\t\tfor (let i = 0; i < slides.length; i += 1) {\n\t\t\t\tif (slides[i]) prependElement(slides[i]);\n\t\t\t}\n\t\t\tnewActiveIndex = activeIndex + slides.length;\n\t\t} else {\n\t\t\tprependElement(slides);\n\t\t}\n\t\tswiper.recalcSlides();\n\t\tif (params.loop) {\n\t\t\tswiper.loopCreate();\n\t\t}\n\t\tif (!params.observer || swiper.isElement) {\n\t\t\tswiper.update();\n\t\t}\n\t\tswiper.slideTo(newActiveIndex, 0, false);\n\t}\n\n\tfunction addSlide(index, slides) {\n\t\tconst swiper = this;\n\t\tconst {\n\t\t\tparams,\n\t\t\tactiveIndex,\n\t\t\tslidesEl\n\t\t} = swiper;\n\t\tlet activeIndexBuffer = activeIndex;\n\t\tif (params.loop) {\n\t\t\tactiveIndexBuffer -= swiper.loopedSlides;\n\t\t\tswiper.loopDestroy();\n\t\t\tswiper.recalcSlides();\n\t\t}\n\t\tconst baseLength = swiper.slides.length;\n\t\tif (index <= 0) {\n\t\t\tswiper.prependSlide(slides);\n\t\t\treturn;\n\t\t}\n\t\tif (index >= baseLength) {\n\t\t\tswiper.appendSlide(slides);\n\t\t\treturn;\n\t\t}\n\t\tlet newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + 1 : activeIndexBuffer;\n\t\tconst slidesBuffer = [];\n\t\tfor (let i = baseLength - 1; i >= index; i -= 1) {\n\t\t\tconst currentSlide = swiper.slides[i];\n\t\t\tcurrentSlide.remove();\n\t\t\tslidesBuffer.unshift(currentSlide);\n\t\t}\n\t\tif (typeof slides === 'object' && 'length' in slides) {\n\t\t\tfor (let i = 0; i < slides.length; i += 1) {\n\t\t\t\tif (slides[i]) slidesEl.append(slides[i]);\n\t\t\t}\n\t\t\tnewActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + slides.length : activeIndexBuffer;\n\t\t} else {\n\t\t\tslidesEl.append(slides);\n\t\t}\n\t\tfor (let i = 0; i < slidesBuffer.length; i += 1) {\n\t\t\tslidesEl.append(slidesBuffer[i]);\n\t\t}\n\t\tswiper.recalcSlides();\n\t\tif (params.loop) {\n\t\t\tswiper.loopCreate();\n\t\t}\n\t\tif (!params.observer || swiper.isElement) {\n\t\t\tswiper.update();\n\t\t}\n\t\tif (params.loop) {\n\t\t\tswiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);\n\t\t} else {\n\t\t\tswiper.slideTo(newActiveIndex, 0, false);\n\t\t}\n\t}\n\n\tfunction removeSlide(slidesIndexes) {\n\t\tconst swiper = this;\n\t\tconst {\n\t\t\tparams,\n\t\t\tactiveIndex\n\t\t} = swiper;\n\t\tlet activeIndexBuffer = activeIndex;\n\t\tif (params.loop) {\n\t\t\tactiveIndexBuffer -= swiper.loopedSlides;\n\t\t\tswiper.loopDestroy();\n\t\t}\n\t\tlet newActiveIndex = activeIndexBuffer;\n\t\tlet indexToRemove;\n\t\tif (typeof slidesIndexes === 'object' && 'length' in slidesIndexes) {\n\t\t\tfor (let i = 0; i < slidesIndexes.length; i += 1) {\n\t\t\t\tindexToRemove = slidesIndexes[i];\n\t\t\t\tif (swiper.slides[indexToRemove]) swiper.slides[indexToRemove].remove();\n\t\t\t\tif (indexToRemove < newActiveIndex) newActiveIndex -= 1;\n\t\t\t}\n\t\t\tnewActiveIndex = Math.max(newActiveIndex, 0);\n\t\t} else {\n\t\t\tindexToRemove = slidesIndexes;\n\t\t\tif (swiper.slides[indexToRemove]) swiper.slides[indexToRemove].remove();\n\t\t\tif (indexToRemove < newActiveIndex) newActiveIndex -= 1;\n\t\t\tnewActiveIndex = Math.max(newActiveIndex, 0);\n\t\t}\n\t\tswiper.recalcSlides();\n\t\tif (params.loop) {\n\t\t\tswiper.loopCreate();\n\t\t}\n\t\tif (!params.observer || swiper.isElement) {\n\t\t\tswiper.update();\n\t\t}\n\t\tif (params.loop) {\n\t\t\tswiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);\n\t\t} else {\n\t\t\tswiper.slideTo(newActiveIndex, 0, false);\n\t\t}\n\t}\n\n\tfunction removeAllSlides() {\n\t\tconst swiper = this;\n\t\tconst slidesIndexes = [];\n\t\tfor (let i = 0; i < swiper.slides.length; i += 1) {\n\t\t\tslidesIndexes.push(i);\n\t\t}\n\t\tswiper.removeSlide(slidesIndexes);\n\t}\n\n\tfunction Manipulation(_ref) {\n\t\tlet {\n\t\t\tswiper\n\t\t} = _ref;\n\t\tObject.assign(swiper, {\n\t\t\tappendSlide: appendSlide.bind(swiper),\n\t\t\tprependSlide: prependSlide.bind(swiper),\n\t\t\taddSlide: addSlide.bind(swiper),\n\t\t\tremoveSlide: removeSlide.bind(swiper),\n\t\t\tremoveAllSlides: removeAllSlides.bind(swiper)\n\t\t});\n\t}\n\n\tfunction effectInit(params) {\n\t\tconst {\n\t\t\teffect,\n\t\t\tswiper,\n\t\t\ton,\n\t\t\tsetTranslate,\n\t\t\tsetTransition,\n\t\t\toverwriteParams,\n\t\t\tperspective,\n\t\t\trecreateShadows,\n\t\t\tgetEffectParams\n\t\t} = params;\n\t\ton('beforeInit', () => {\n\t\t\tif (swiper.params.effect !== effect) return;\n\t\t\tswiper.classNames.push(`${swiper.params.containerModifierClass}${effect}`);\n\t\t\tif (perspective && perspective()) {\n\t\t\t\tswiper.classNames.push(`${swiper.params.containerModifierClass}3d`);\n\t\t\t}\n\t\t\tconst overwriteParamsResult = overwriteParams ? overwriteParams() : {};\n\t\t\tObject.assign(swiper.params, overwriteParamsResult);\n\t\t\tObject.assign(swiper.originalParams, overwriteParamsResult);\n\t\t});\n\t\ton('setTranslate', () => {\n\t\t\tif (swiper.params.effect !== effect) return;\n\t\t\tsetTranslate();\n\t\t});\n\t\ton('setTransition', (_s, duration) => {\n\t\t\tif (swiper.params.effect !== effect) return;\n\t\t\tsetTransition(duration);\n\t\t});\n\t\ton('transitionEnd', () => {\n\t\t\tif (swiper.params.effect !== effect) return;\n\t\t\tif (recreateShadows) {\n\t\t\t\tif (!getEffectParams || !getEffectParams().slideShadows) return;\n\t\t\t\t// remove shadows\n\t\t\t\tswiper.slides.forEach(slideEl => {\n\t\t\t\t\tslideEl.querySelectorAll('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').forEach(shadowEl => shadowEl.remove());\n\t\t\t\t});\n\t\t\t\t// create new one\n\t\t\t\trecreateShadows();\n\t\t\t}\n\t\t});\n\t\tlet requireUpdateOnVirtual;\n\t\ton('virtualUpdate', () => {\n\t\t\tif (swiper.params.effect !== effect) return;\n\t\t\tif (!swiper.slides.length) {\n\t\t\t\trequireUpdateOnVirtual = true;\n\t\t\t}\n\t\t\trequestAnimationFrame(() => {\n\t\t\t\tif (requireUpdateOnVirtual && swiper.slides && swiper.slides.length) {\n\t\t\t\t\tsetTranslate();\n\t\t\t\t\trequireUpdateOnVirtual = false;\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\tfunction effectTarget(effectParams, slideEl) {\n\t\tconst transformEl = getSlideTransformEl(slideEl);\n\t\tif (transformEl !== slideEl) {\n\t\t\ttransformEl.style.backfaceVisibility = 'hidden';\n\t\t\ttransformEl.style['-webkit-backface-visibility'] = 'hidden';\n\t\t}\n\t\treturn transformEl;\n\t}\n\n\tfunction effectVirtualTransitionEnd(_ref) {\n\t\tlet {\n\t\t\tswiper,\n\t\t\tduration,\n\t\t\ttransformElements,\n\t\t\tallSlides\n\t\t} = _ref;\n\t\tconst {\n\t\t\tactiveIndex\n\t\t} = swiper;\n\t\tconst getSlide = el => {\n\t\t\tif (!el.parentElement) {\n\t\t\t\t// assume shadow root\n\t\t\t\tconst slide = swiper.slides.filter(slideEl => slideEl.shadowRoot && slideEl.shadowRoot === el.parentNode)[0];\n\t\t\t\treturn slide;\n\t\t\t}\n\t\t\treturn el.parentElement;\n\t\t};\n\t\tif (swiper.params.virtualTranslate && duration !== 0) {\n\t\t\tlet eventTriggered = false;\n\t\t\tlet transitionEndTarget;\n\t\t\tif (allSlides) {\n\t\t\t\ttransitionEndTarget = transformElements;\n\t\t\t} else {\n\t\t\t\ttransitionEndTarget = transformElements.filter(transformEl => {\n\t\t\t\t\tconst el = transformEl.classList.contains('swiper-slide-transform') ? getSlide(transformEl) : transformEl;\n\t\t\t\t\treturn swiper.getSlideIndex(el) === activeIndex;\n\t\t\t\t});\n\t\t\t}\n\t\t\ttransitionEndTarget.forEach(el => {\n\t\t\t\telementTransitionEnd(el, () => {\n\t\t\t\t\tif (eventTriggered) return;\n\t\t\t\t\tif (!swiper || swiper.destroyed) return;\n\t\t\t\t\teventTriggered = true;\n\t\t\t\t\tswiper.animating = false;\n\t\t\t\t\tconst evt = new window.CustomEvent('transitionend', {\n\t\t\t\t\t\tbubbles: true,\n\t\t\t\t\t\tcancelable: true\n\t\t\t\t\t});\n\t\t\t\t\tswiper.wrapperEl.dispatchEvent(evt);\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t}\n\n\tfunction EffectFade(_ref) {\n\t\tlet {\n\t\t\tswiper,\n\t\t\textendParams,\n\t\t\ton\n\t\t} = _ref;\n\t\textendParams({\n\t\t\tfadeEffect: {\n\t\t\t\tcrossFade: false\n\t\t\t}\n\t\t});\n\t\tconst setTranslate = () => {\n\t\t\tconst {\n\t\t\t\tslides\n\t\t\t} = swiper;\n\t\t\tconst params = swiper.params.fadeEffect;\n\t\t\tfor (let i = 0; i < slides.length; i += 1) {\n\t\t\t\tconst slideEl = swiper.slides[i];\n\t\t\t\tconst offset = slideEl.swiperSlideOffset;\n\t\t\t\tlet tx = -offset;\n\t\t\t\tif (!swiper.params.virtualTranslate) tx -= swiper.translate;\n\t\t\t\tlet ty = 0;\n\t\t\t\tif (!swiper.isHorizontal()) {\n\t\t\t\t\tty = tx;\n\t\t\t\t\ttx = 0;\n\t\t\t\t}\n\t\t\t\tconst slideOpacity = swiper.params.fadeEffect.crossFade ? Math.max(1 - Math.abs(slideEl.progress), 0) : 1 + Math.min(Math.max(slideEl.progress, -1), 0);\n\t\t\t\tconst targetEl = effectTarget(params, slideEl);\n\t\t\t\ttargetEl.style.opacity = slideOpacity;\n\t\t\t\ttargetEl.style.transform = `translate3d(${tx}px, ${ty}px, 0px)`;\n\t\t\t}\n\t\t};\n\t\tconst setTransition = duration => {\n\t\t\tconst transformElements = swiper.slides.map(slideEl => getSlideTransformEl(slideEl));\n\t\t\ttransformElements.forEach(el => {\n\t\t\t\tel.style.transitionDuration = `${duration}ms`;\n\t\t\t});\n\t\t\teffectVirtualTransitionEnd({\n\t\t\t\tswiper,\n\t\t\t\tduration,\n\t\t\t\ttransformElements,\n\t\t\t\tallSlides: true\n\t\t\t});\n\t\t};\n\t\teffectInit({\n\t\t\teffect: 'fade',\n\t\t\tswiper,\n\t\t\ton,\n\t\t\tsetTranslate,\n\t\t\tsetTransition,\n\t\t\toverwriteParams: () => ({\n\t\t\t\tslidesPerView: 1,\n\t\t\t\tslidesPerGroup: 1,\n\t\t\t\twatchSlidesProgress: true,\n\t\t\t\tspaceBetween: 0,\n\t\t\t\tvirtualTranslate: !swiper.params.cssMode\n\t\t\t})\n\t\t});\n\t}\n\n\tfunction EffectCube(_ref) {\n\t\tlet {\n\t\t\tswiper,\n\t\t\textendParams,\n\t\t\ton\n\t\t} = _ref;\n\t\textendParams({\n\t\t\tcubeEffect: {\n\t\t\t\tslideShadows: true,\n\t\t\t\tshadow: true,\n\t\t\t\tshadowOffset: 20,\n\t\t\t\tshadowScale: 0.94\n\t\t\t}\n\t\t});\n\t\tconst createSlideShadows = (slideEl, progress, isHorizontal) => {\n\t\t\tlet shadowBefore = isHorizontal ? slideEl.querySelector('.swiper-slide-shadow-left') : slideEl.querySelector('.swiper-slide-shadow-top');\n\t\t\tlet shadowAfter = isHorizontal ? slideEl.querySelector('.swiper-slide-shadow-right') : slideEl.querySelector('.swiper-slide-shadow-bottom');\n\t\t\tif (!shadowBefore) {\n\t\t\t\tshadowBefore = createElement('div', `swiper-slide-shadow-cube swiper-slide-shadow-${isHorizontal ? 'left' : 'top'}`.split(' '));\n\t\t\t\tslideEl.append(shadowBefore);\n\t\t\t}\n\t\t\tif (!shadowAfter) {\n\t\t\t\tshadowAfter = createElement('div', `swiper-slide-shadow-cube swiper-slide-shadow-${isHorizontal ? 'right' : 'bottom'}`.split(' '));\n\t\t\t\tslideEl.append(shadowAfter);\n\t\t\t}\n\t\t\tif (shadowBefore) shadowBefore.style.opacity = Math.max(-progress, 0);\n\t\t\tif (shadowAfter) shadowAfter.style.opacity = Math.max(progress, 0);\n\t\t};\n\t\tconst recreateShadows = () => {\n\t\t\t// create new ones\n\t\t\tconst isHorizontal = swiper.isHorizontal();\n\t\t\tswiper.slides.forEach(slideEl => {\n\t\t\t\tconst progress = Math.max(Math.min(slideEl.progress, 1), -1);\n\t\t\t\tcreateSlideShadows(slideEl, progress, isHorizontal);\n\t\t\t});\n\t\t};\n\t\tconst setTranslate = () => {\n\t\t\tconst {\n\t\t\t\tel,\n\t\t\t\twrapperEl,\n\t\t\t\tslides,\n\t\t\t\twidth: swiperWidth,\n\t\t\t\theight: swiperHeight,\n\t\t\t\trtlTranslate: rtl,\n\t\t\t\tsize: swiperSize,\n\t\t\t\tbrowser\n\t\t\t} = swiper;\n\t\t\tconst params = swiper.params.cubeEffect;\n\t\t\tconst isHorizontal = swiper.isHorizontal();\n\t\t\tconst isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n\t\t\tlet wrapperRotate = 0;\n\t\t\tlet cubeShadowEl;\n\t\t\tif (params.shadow) {\n\t\t\t\tif (isHorizontal) {\n\t\t\t\t\tcubeShadowEl = swiper.wrapperEl.querySelector('.swiper-cube-shadow');\n\t\t\t\t\tif (!cubeShadowEl) {\n\t\t\t\t\t\tcubeShadowEl = createElement('div', 'swiper-cube-shadow');\n\t\t\t\t\t\tswiper.wrapperEl.append(cubeShadowEl);\n\t\t\t\t\t}\n\t\t\t\t\tcubeShadowEl.style.height = `${swiperWidth}px`;\n\t\t\t\t} else {\n\t\t\t\t\tcubeShadowEl = el.querySelector('.swiper-cube-shadow');\n\t\t\t\t\tif (!cubeShadowEl) {\n\t\t\t\t\t\tcubeShadowEl = createElement('div', 'swiper-cube-shadow');\n\t\t\t\t\t\tel.append(cubeShadowEl);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (let i = 0; i < slides.length; i += 1) {\n\t\t\t\tconst slideEl = slides[i];\n\t\t\t\tlet slideIndex = i;\n\t\t\t\tif (isVirtual) {\n\t\t\t\t\tslideIndex = parseInt(slideEl.getAttribute('data-swiper-slide-index'), 10);\n\t\t\t\t}\n\t\t\t\tlet slideAngle = slideIndex * 90;\n\t\t\t\tlet round = Math.floor(slideAngle / 360);\n\t\t\t\tif (rtl) {\n\t\t\t\t\tslideAngle = -slideAngle;\n\t\t\t\t\tround = Math.floor(-slideAngle / 360);\n\t\t\t\t}\n\t\t\t\tconst progress = Math.max(Math.min(slideEl.progress, 1), -1);\n\t\t\t\tlet tx = 0;\n\t\t\t\tlet ty = 0;\n\t\t\t\tlet tz = 0;\n\t\t\t\tif (slideIndex % 4 === 0) {\n\t\t\t\t\ttx = -round * 4 * swiperSize;\n\t\t\t\t\ttz = 0;\n\t\t\t\t} else if ((slideIndex - 1) % 4 === 0) {\n\t\t\t\t\ttx = 0;\n\t\t\t\t\ttz = -round * 4 * swiperSize;\n\t\t\t\t} else if ((slideIndex - 2) % 4 === 0) {\n\t\t\t\t\ttx = swiperSize + round * 4 * swiperSize;\n\t\t\t\t\ttz = swiperSize;\n\t\t\t\t} else if ((slideIndex - 3) % 4 === 0) {\n\t\t\t\t\ttx = -swiperSize;\n\t\t\t\t\ttz = 3 * swiperSize + swiperSize * 4 * round;\n\t\t\t\t}\n\t\t\t\tif (rtl) {\n\t\t\t\t\ttx = -tx;\n\t\t\t\t}\n\t\t\t\tif (!isHorizontal) {\n\t\t\t\t\tty = tx;\n\t\t\t\t\ttx = 0;\n\t\t\t\t}\n\t\t\t\tconst transform = `rotateX(${isHorizontal ? 0 : -slideAngle}deg) rotateY(${isHorizontal ? slideAngle : 0}deg) translate3d(${tx}px, ${ty}px, ${tz}px)`;\n\t\t\t\tif (progress <= 1 && progress > -1) {\n\t\t\t\t\twrapperRotate = slideIndex * 90 + progress * 90;\n\t\t\t\t\tif (rtl) wrapperRotate = -slideIndex * 90 - progress * 90;\n\t\t\t\t}\n\t\t\t\tslideEl.style.transform = transform;\n\t\t\t\tif (params.slideShadows) {\n\t\t\t\t\tcreateSlideShadows(slideEl, progress, isHorizontal);\n\t\t\t\t}\n\t\t\t}\n\t\t\twrapperEl.style.transformOrigin = `50% 50% -${swiperSize / 2}px`;\n\t\t\twrapperEl.style['-webkit-transform-origin'] = `50% 50% -${swiperSize / 2}px`;\n\t\t\tif (params.shadow) {\n\t\t\t\tif (isHorizontal) {\n\t\t\t\t\tcubeShadowEl.style.transform = `translate3d(0px, ${swiperWidth / 2 + params.shadowOffset}px, ${-swiperWidth / 2}px) rotateX(90deg) rotateZ(0deg) scale(${params.shadowScale})`;\n\t\t\t\t} else {\n\t\t\t\t\tconst shadowAngle = Math.abs(wrapperRotate) - Math.floor(Math.abs(wrapperRotate) / 90) * 90;\n\t\t\t\t\tconst multiplier = 1.5 - (Math.sin(shadowAngle * 2 * Math.PI / 360) / 2 + Math.cos(shadowAngle * 2 * Math.PI / 360) / 2);\n\t\t\t\t\tconst scale1 = params.shadowScale;\n\t\t\t\t\tconst scale2 = params.shadowScale / multiplier;\n\t\t\t\t\tconst offset = params.shadowOffset;\n\t\t\t\t\tcubeShadowEl.style.transform = `scale3d(${scale1}, 1, ${scale2}) translate3d(0px, ${swiperHeight / 2 + offset}px, ${-swiperHeight / 2 / scale2}px) rotateX(-90deg)`;\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst zFactor = (browser.isSafari || browser.isWebView) && browser.needPerspectiveFix ? -swiperSize / 2 : 0;\n\t\t\twrapperEl.style.transform = `translate3d(0px,0,${zFactor}px) rotateX(${swiper.isHorizontal() ? 0 : wrapperRotate}deg) rotateY(${swiper.isHorizontal() ? -wrapperRotate : 0}deg)`;\n\t\t\twrapperEl.style.setProperty('--swiper-cube-translate-z', `${zFactor}px`);\n\t\t};\n\t\tconst setTransition = duration => {\n\t\t\tconst {\n\t\t\t\tel,\n\t\t\t\tslides\n\t\t\t} = swiper;\n\t\t\tslides.forEach(slideEl => {\n\t\t\t\tslideEl.style.transitionDuration = `${duration}ms`;\n\t\t\t\tslideEl.querySelectorAll('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').forEach(subEl => {\n\t\t\t\t\tsubEl.style.transitionDuration = `${duration}ms`;\n\t\t\t\t});\n\t\t\t});\n\t\t\tif (swiper.params.cubeEffect.shadow && !swiper.isHorizontal()) {\n\t\t\t\tconst shadowEl = el.querySelector('.swiper-cube-shadow');\n\t\t\t\tif (shadowEl) shadowEl.style.transitionDuration = `${duration}ms`;\n\t\t\t}\n\t\t};\n\t\teffectInit({\n\t\t\teffect: 'cube',\n\t\t\tswiper,\n\t\t\ton,\n\t\t\tsetTranslate,\n\t\t\tsetTransition,\n\t\t\trecreateShadows,\n\t\t\tgetEffectParams: () => swiper.params.cubeEffect,\n\t\t\tperspective: () => true,\n\t\t\toverwriteParams: () => ({\n\t\t\t\tslidesPerView: 1,\n\t\t\t\tslidesPerGroup: 1,\n\t\t\t\twatchSlidesProgress: true,\n\t\t\t\tresistanceRatio: 0,\n\t\t\t\tspaceBetween: 0,\n\t\t\t\tcenteredSlides: false,\n\t\t\t\tvirtualTranslate: true\n\t\t\t})\n\t\t});\n\t}\n\n\tfunction createShadow(suffix, slideEl, side) {\n\t\tconst shadowClass = `swiper-slide-shadow${side ? `-${side}` : ''}${suffix ? ` swiper-slide-shadow-${suffix}` : ''}`;\n\t\tconst shadowContainer = getSlideTransformEl(slideEl);\n\t\tlet shadowEl = shadowContainer.querySelector(`.${shadowClass.split(' ').join('.')}`);\n\t\tif (!shadowEl) {\n\t\t\tshadowEl = createElement('div', shadowClass.split(' '));\n\t\t\tshadowContainer.append(shadowEl);\n\t\t}\n\t\treturn shadowEl;\n\t}\n\n\tfunction EffectFlip(_ref) {\n\t\tlet {\n\t\t\tswiper,\n\t\t\textendParams,\n\t\t\ton\n\t\t} = _ref;\n\t\textendParams({\n\t\t\tflipEffect: {\n\t\t\t\tslideShadows: true,\n\t\t\t\tlimitRotation: true\n\t\t\t}\n\t\t});\n\t\tconst createSlideShadows = (slideEl, progress) => {\n\t\t\tlet shadowBefore = swiper.isHorizontal() ? slideEl.querySelector('.swiper-slide-shadow-left') : slideEl.querySelector('.swiper-slide-shadow-top');\n\t\t\tlet shadowAfter = swiper.isHorizontal() ? slideEl.querySelector('.swiper-slide-shadow-right') : slideEl.querySelector('.swiper-slide-shadow-bottom');\n\t\t\tif (!shadowBefore) {\n\t\t\t\tshadowBefore = createShadow('flip', slideEl, swiper.isHorizontal() ? 'left' : 'top');\n\t\t\t}\n\t\t\tif (!shadowAfter) {\n\t\t\t\tshadowAfter = createShadow('flip', slideEl, swiper.isHorizontal() ? 'right' : 'bottom');\n\t\t\t}\n\t\t\tif (shadowBefore) shadowBefore.style.opacity = Math.max(-progress, 0);\n\t\t\tif (shadowAfter) shadowAfter.style.opacity = Math.max(progress, 0);\n\t\t};\n\t\tconst recreateShadows = () => {\n\t\t\t// Set shadows\n\t\t\tswiper.params.flipEffect;\n\t\t\tswiper.slides.forEach(slideEl => {\n\t\t\t\tlet progress = slideEl.progress;\n\t\t\t\tif (swiper.params.flipEffect.limitRotation) {\n\t\t\t\t\tprogress = Math.max(Math.min(slideEl.progress, 1), -1);\n\t\t\t\t}\n\t\t\t\tcreateSlideShadows(slideEl, progress);\n\t\t\t});\n\t\t};\n\t\tconst setTranslate = () => {\n\t\t\tconst {\n\t\t\t\tslides,\n\t\t\t\trtlTranslate: rtl\n\t\t\t} = swiper;\n\t\t\tconst params = swiper.params.flipEffect;\n\t\t\tfor (let i = 0; i < slides.length; i += 1) {\n\t\t\t\tconst slideEl = slides[i];\n\t\t\t\tlet progress = slideEl.progress;\n\t\t\t\tif (swiper.params.flipEffect.limitRotation) {\n\t\t\t\t\tprogress = Math.max(Math.min(slideEl.progress, 1), -1);\n\t\t\t\t}\n\t\t\t\tconst offset = slideEl.swiperSlideOffset;\n\t\t\t\tconst rotate = -180 * progress;\n\t\t\t\tlet rotateY = rotate;\n\t\t\t\tlet rotateX = 0;\n\t\t\t\tlet tx = swiper.params.cssMode ? -offset - swiper.translate : -offset;\n\t\t\t\tlet ty = 0;\n\t\t\t\tif (!swiper.isHorizontal()) {\n\t\t\t\t\tty = tx;\n\t\t\t\t\ttx = 0;\n\t\t\t\t\trotateX = -rotateY;\n\t\t\t\t\trotateY = 0;\n\t\t\t\t} else if (rtl) {\n\t\t\t\t\trotateY = -rotateY;\n\t\t\t\t}\n\t\t\t\tslideEl.style.zIndex = -Math.abs(Math.round(progress)) + slides.length;\n\t\t\t\tif (params.slideShadows) {\n\t\t\t\t\tcreateSlideShadows(slideEl, progress);\n\t\t\t\t}\n\t\t\t\tconst transform = `translate3d(${tx}px, ${ty}px, 0px) rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;\n\t\t\t\tconst targetEl = effectTarget(params, slideEl);\n\t\t\t\ttargetEl.style.transform = transform;\n\t\t\t}\n\t\t};\n\t\tconst setTransition = duration => {\n\t\t\tconst transformElements = swiper.slides.map(slideEl => getSlideTransformEl(slideEl));\n\t\t\ttransformElements.forEach(el => {\n\t\t\t\tel.style.transitionDuration = `${duration}ms`;\n\t\t\t\tel.querySelectorAll('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').forEach(shadowEl => {\n\t\t\t\t\tshadowEl.style.transitionDuration = `${duration}ms`;\n\t\t\t\t});\n\t\t\t});\n\t\t\teffectVirtualTransitionEnd({\n\t\t\t\tswiper,\n\t\t\t\tduration,\n\t\t\t\ttransformElements\n\t\t\t});\n\t\t};\n\t\teffectInit({\n\t\t\teffect: 'flip',\n\t\t\tswiper,\n\t\t\ton,\n\t\t\tsetTranslate,\n\t\t\tsetTransition,\n\t\t\trecreateShadows,\n\t\t\tgetEffectParams: () => swiper.params.flipEffect,\n\t\t\tperspective: () => true,\n\t\t\toverwriteParams: () => ({\n\t\t\t\tslidesPerView: 1,\n\t\t\t\tslidesPerGroup: 1,\n\t\t\t\twatchSlidesProgress: true,\n\t\t\t\tspaceBetween: 0,\n\t\t\t\tvirtualTranslate: !swiper.params.cssMode\n\t\t\t})\n\t\t});\n\t}\n\n\tfunction EffectCoverflow(_ref) {\n\t\tlet {\n\t\t\tswiper,\n\t\t\textendParams,\n\t\t\ton\n\t\t} = _ref;\n\t\textendParams({\n\t\t\tcoverflowEffect: {\n\t\t\t\trotate: 50,\n\t\t\t\tstretch: 0,\n\t\t\t\tdepth: 100,\n\t\t\t\tscale: 1,\n\t\t\t\tmodifier: 1,\n\t\t\t\tslideShadows: true\n\t\t\t}\n\t\t});\n\t\tconst setTranslate = () => {\n\t\t\tconst {\n\t\t\t\twidth: swiperWidth,\n\t\t\t\theight: swiperHeight,\n\t\t\t\tslides,\n\t\t\t\tslidesSizesGrid\n\t\t\t} = swiper;\n\t\t\tconst params = swiper.params.coverflowEffect;\n\t\t\tconst isHorizontal = swiper.isHorizontal();\n\t\t\tconst transform = swiper.translate;\n\t\t\tconst center = isHorizontal ? -transform + swiperWidth / 2 : -transform + swiperHeight / 2;\n\t\t\tconst rotate = isHorizontal ? params.rotate : -params.rotate;\n\t\t\tconst translate = params.depth;\n\t\t\t// Each slide offset from center\n\t\t\tfor (let i = 0, length = slides.length; i < length; i += 1) {\n\t\t\t\tconst slideEl = slides[i];\n\t\t\t\tconst slideSize = slidesSizesGrid[i];\n\t\t\t\tconst slideOffset = slideEl.swiperSlideOffset;\n\t\t\t\tconst centerOffset = (center - slideOffset - slideSize / 2) / slideSize;\n\t\t\t\tconst offsetMultiplier = typeof params.modifier === 'function' ? params.modifier(centerOffset) : centerOffset * params.modifier;\n\t\t\t\tlet rotateY = isHorizontal ? rotate * offsetMultiplier : 0;\n\t\t\t\tlet rotateX = isHorizontal ? 0 : rotate * offsetMultiplier;\n\t\t\t\t// var rotateZ = 0\n\t\t\t\tlet translateZ = -translate * Math.abs(offsetMultiplier);\n\t\t\t\tlet stretch = params.stretch;\n\t\t\t\t// Allow percentage to make a relative stretch for responsive sliders\n\t\t\t\tif (typeof stretch === 'string' && stretch.indexOf('%') !== -1) {\n\t\t\t\t\tstretch = parseFloat(params.stretch) / 100 * slideSize;\n\t\t\t\t}\n\t\t\t\tlet translateY = isHorizontal ? 0 : stretch * offsetMultiplier;\n\t\t\t\tlet translateX = isHorizontal ? stretch * offsetMultiplier : 0;\n\t\t\t\tlet scale = 1 - (1 - params.scale) * Math.abs(offsetMultiplier);\n\n\t\t\t\t// Fix for ultra small values\n\t\t\t\tif (Math.abs(translateX) < 0.001) translateX = 0;\n\t\t\t\tif (Math.abs(translateY) < 0.001) translateY = 0;\n\t\t\t\tif (Math.abs(translateZ) < 0.001) translateZ = 0;\n\t\t\t\tif (Math.abs(rotateY) < 0.001) rotateY = 0;\n\t\t\t\tif (Math.abs(rotateX) < 0.001) rotateX = 0;\n\t\t\t\tif (Math.abs(scale) < 0.001) scale = 0;\n\t\t\t\tconst slideTransform = `translate3d(${translateX}px,${translateY}px,${translateZ}px)  rotateX(${rotateX}deg) rotateY(${rotateY}deg) scale(${scale})`;\n\t\t\t\tconst targetEl = effectTarget(params, slideEl);\n\t\t\t\ttargetEl.style.transform = slideTransform;\n\t\t\t\tslideEl.style.zIndex = -Math.abs(Math.round(offsetMultiplier)) + 1;\n\t\t\t\tif (params.slideShadows) {\n\t\t\t\t\t// Set shadows\n\t\t\t\t\tlet shadowBeforeEl = isHorizontal ? slideEl.querySelector('.swiper-slide-shadow-left') : slideEl.querySelector('.swiper-slide-shadow-top');\n\t\t\t\t\tlet shadowAfterEl = isHorizontal ? slideEl.querySelector('.swiper-slide-shadow-right') : slideEl.querySelector('.swiper-slide-shadow-bottom');\n\t\t\t\t\tif (!shadowBeforeEl) {\n\t\t\t\t\t\tshadowBeforeEl = createShadow('coverflow', slideEl, isHorizontal ? 'left' : 'top');\n\t\t\t\t\t}\n\t\t\t\t\tif (!shadowAfterEl) {\n\t\t\t\t\t\tshadowAfterEl = createShadow('coverflow', slideEl, isHorizontal ? 'right' : 'bottom');\n\t\t\t\t\t}\n\t\t\t\t\tif (shadowBeforeEl) shadowBeforeEl.style.opacity = offsetMultiplier > 0 ? offsetMultiplier : 0;\n\t\t\t\t\tif (shadowAfterEl) shadowAfterEl.style.opacity = -offsetMultiplier > 0 ? -offsetMultiplier : 0;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tconst setTransition = duration => {\n\t\t\tconst transformElements = swiper.slides.map(slideEl => getSlideTransformEl(slideEl));\n\t\t\ttransformElements.forEach(el => {\n\t\t\t\tel.style.transitionDuration = `${duration}ms`;\n\t\t\t\tel.querySelectorAll('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').forEach(shadowEl => {\n\t\t\t\t\tshadowEl.style.transitionDuration = `${duration}ms`;\n\t\t\t\t});\n\t\t\t});\n\t\t};\n\t\teffectInit({\n\t\t\teffect: 'coverflow',\n\t\t\tswiper,\n\t\t\ton,\n\t\t\tsetTranslate,\n\t\t\tsetTransition,\n\t\t\tperspective: () => true,\n\t\t\toverwriteParams: () => ({\n\t\t\t\twatchSlidesProgress: true\n\t\t\t})\n\t\t});\n\t}\n\n\tfunction EffectCreative(_ref) {\n\t\tlet {\n\t\t\tswiper,\n\t\t\textendParams,\n\t\t\ton\n\t\t} = _ref;\n\t\textendParams({\n\t\t\tcreativeEffect: {\n\t\t\t\tlimitProgress: 1,\n\t\t\t\tshadowPerProgress: false,\n\t\t\t\tprogressMultiplier: 1,\n\t\t\t\tperspective: true,\n\t\t\t\tprev: {\n\t\t\t\t\ttranslate: [0, 0, 0],\n\t\t\t\t\trotate: [0, 0, 0],\n\t\t\t\t\topacity: 1,\n\t\t\t\t\tscale: 1\n\t\t\t\t},\n\t\t\t\tnext: {\n\t\t\t\t\ttranslate: [0, 0, 0],\n\t\t\t\t\trotate: [0, 0, 0],\n\t\t\t\t\topacity: 1,\n\t\t\t\t\tscale: 1\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tconst getTranslateValue = value => {\n\t\t\tif (typeof value === 'string') return value;\n\t\t\treturn `${value}px`;\n\t\t};\n\t\tconst setTranslate = () => {\n\t\t\tconst {\n\t\t\t\tslides,\n\t\t\t\twrapperEl,\n\t\t\t\tslidesSizesGrid\n\t\t\t} = swiper;\n\t\t\tconst params = swiper.params.creativeEffect;\n\t\t\tconst {\n\t\t\t\tprogressMultiplier: multiplier\n\t\t\t} = params;\n\t\t\tconst isCenteredSlides = swiper.params.centeredSlides;\n\t\t\tif (isCenteredSlides) {\n\t\t\t\tconst margin = slidesSizesGrid[0] / 2 - swiper.params.slidesOffsetBefore || 0;\n\t\t\t\twrapperEl.style.transform = `translateX(calc(50% - ${margin}px))`;\n\t\t\t}\n\t\t\tfor (let i = 0; i < slides.length; i += 1) {\n\t\t\t\tconst slideEl = slides[i];\n\t\t\t\tconst slideProgress = slideEl.progress;\n\t\t\t\tconst progress = Math.min(Math.max(slideEl.progress, -params.limitProgress), params.limitProgress);\n\t\t\t\tlet originalProgress = progress;\n\t\t\t\tif (!isCenteredSlides) {\n\t\t\t\t\toriginalProgress = Math.min(Math.max(slideEl.originalProgress, -params.limitProgress), params.limitProgress);\n\t\t\t\t}\n\t\t\t\tconst offset = slideEl.swiperSlideOffset;\n\t\t\t\tconst t = [swiper.params.cssMode ? -offset - swiper.translate : -offset, 0, 0];\n\t\t\t\tconst r = [0, 0, 0];\n\t\t\t\tlet custom = false;\n\t\t\t\tif (!swiper.isHorizontal()) {\n\t\t\t\t\tt[1] = t[0];\n\t\t\t\t\tt[0] = 0;\n\t\t\t\t}\n\t\t\t\tlet data = {\n\t\t\t\t\ttranslate: [0, 0, 0],\n\t\t\t\t\trotate: [0, 0, 0],\n\t\t\t\t\tscale: 1,\n\t\t\t\t\topacity: 1\n\t\t\t\t};\n\t\t\t\tif (progress < 0) {\n\t\t\t\t\tdata = params.next;\n\t\t\t\t\tcustom = true;\n\t\t\t\t} else if (progress > 0) {\n\t\t\t\t\tdata = params.prev;\n\t\t\t\t\tcustom = true;\n\t\t\t\t}\n\t\t\t\t// set translate\n\t\t\t\tt.forEach((value, index) => {\n\t\t\t\t\tt[index] = `calc(${value}px + (${getTranslateValue(data.translate[index])} * ${Math.abs(progress * multiplier)}))`;\n\t\t\t\t});\n\t\t\t\t// set rotates\n\t\t\t\tr.forEach((value, index) => {\n\t\t\t\t\tr[index] = data.rotate[index] * Math.abs(progress * multiplier);\n\t\t\t\t});\n\t\t\t\tslideEl.style.zIndex = -Math.abs(Math.round(slideProgress)) + slides.length;\n\t\t\t\tconst translateString = t.join(', ');\n\t\t\t\tconst rotateString = `rotateX(${r[0]}deg) rotateY(${r[1]}deg) rotateZ(${r[2]}deg)`;\n\t\t\t\tconst scaleString = originalProgress < 0 ? `scale(${1 + (1 - data.scale) * originalProgress * multiplier})` : `scale(${1 - (1 - data.scale) * originalProgress * multiplier})`;\n\t\t\t\tconst opacityString = originalProgress < 0 ? 1 + (1 - data.opacity) * originalProgress * multiplier : 1 - (1 - data.opacity) * originalProgress * multiplier;\n\t\t\t\tconst transform = `translate3d(${translateString}) ${rotateString} ${scaleString}`;\n\n\t\t\t\t// Set shadows\n\t\t\t\tif (custom && data.shadow || !custom) {\n\t\t\t\t\tlet shadowEl = slideEl.querySelector('.swiper-slide-shadow');\n\t\t\t\t\tif (!shadowEl && data.shadow) {\n\t\t\t\t\t\tshadowEl = createShadow('creative', slideEl);\n\t\t\t\t\t}\n\t\t\t\t\tif (shadowEl) {\n\t\t\t\t\t\tconst shadowOpacity = params.shadowPerProgress ? progress * (1 / params.limitProgress) : progress;\n\t\t\t\t\t\tshadowEl.style.opacity = Math.min(Math.max(Math.abs(shadowOpacity), 0), 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tconst targetEl = effectTarget(params, slideEl);\n\t\t\t\ttargetEl.style.transform = transform;\n\t\t\t\ttargetEl.style.opacity = opacityString;\n\t\t\t\tif (data.origin) {\n\t\t\t\t\ttargetEl.style.transformOrigin = data.origin;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tconst setTransition = duration => {\n\t\t\tconst transformElements = swiper.slides.map(slideEl => getSlideTransformEl(slideEl));\n\t\t\ttransformElements.forEach(el => {\n\t\t\t\tel.style.transitionDuration = `${duration}ms`;\n\t\t\t\tel.querySelectorAll('.swiper-slide-shadow').forEach(shadowEl => {\n\t\t\t\t\tshadowEl.style.transitionDuration = `${duration}ms`;\n\t\t\t\t});\n\t\t\t});\n\t\t\teffectVirtualTransitionEnd({\n\t\t\t\tswiper,\n\t\t\t\tduration,\n\t\t\t\ttransformElements,\n\t\t\t\tallSlides: true\n\t\t\t});\n\t\t};\n\t\teffectInit({\n\t\t\teffect: 'creative',\n\t\t\tswiper,\n\t\t\ton,\n\t\t\tsetTranslate,\n\t\t\tsetTransition,\n\t\t\tperspective: () => swiper.params.creativeEffect.perspective,\n\t\t\toverwriteParams: () => ({\n\t\t\t\twatchSlidesProgress: true,\n\t\t\t\tvirtualTranslate: !swiper.params.cssMode\n\t\t\t})\n\t\t});\n\t}\n\n\tfunction EffectCards(_ref) {\n\t\tlet {\n\t\t\tswiper,\n\t\t\textendParams,\n\t\t\ton\n\t\t} = _ref;\n\t\textendParams({\n\t\t\tcardsEffect: {\n\t\t\t\tslideShadows: true,\n\t\t\t\trotate: true,\n\t\t\t\tperSlideRotate: 2,\n\t\t\t\tperSlideOffset: 8\n\t\t\t}\n\t\t});\n\t\tconst setTranslate = () => {\n\t\t\tconst {\n\t\t\t\tslides,\n\t\t\t\tactiveIndex,\n\t\t\t\trtlTranslate: rtl\n\t\t\t} = swiper;\n\t\t\tconst params = swiper.params.cardsEffect;\n\t\t\tconst {\n\t\t\t\tstartTranslate,\n\t\t\t\tisTouched\n\t\t\t} = swiper.touchEventsData;\n\t\t\tconst currentTranslate = rtl ? -swiper.translate : swiper.translate;\n\t\t\tfor (let i = 0; i < slides.length; i += 1) {\n\t\t\t\tconst slideEl = slides[i];\n\t\t\t\tconst slideProgress = slideEl.progress;\n\t\t\t\tconst progress = Math.min(Math.max(slideProgress, -4), 4);\n\t\t\t\tlet offset = slideEl.swiperSlideOffset;\n\t\t\t\tif (swiper.params.centeredSlides && !swiper.params.cssMode) {\n\t\t\t\t\tswiper.wrapperEl.style.transform = `translateX(${swiper.minTranslate()}px)`;\n\t\t\t\t}\n\t\t\t\tif (swiper.params.centeredSlides && swiper.params.cssMode) {\n\t\t\t\t\toffset -= slides[0].swiperSlideOffset;\n\t\t\t\t}\n\t\t\t\tlet tX = swiper.params.cssMode ? -offset - swiper.translate : -offset;\n\t\t\t\tlet tY = 0;\n\t\t\t\tconst tZ = -100 * Math.abs(progress);\n\t\t\t\tlet scale = 1;\n\t\t\t\tlet rotate = -params.perSlideRotate * progress;\n\t\t\t\tlet tXAdd = params.perSlideOffset - Math.abs(progress) * 0.75;\n\t\t\t\tconst slideIndex = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.from + i : i;\n\t\t\t\tconst isSwipeToNext = (slideIndex === activeIndex || slideIndex === activeIndex - 1) && progress > 0 && progress < 1 && (isTouched || swiper.params.cssMode) && currentTranslate < startTranslate;\n\t\t\t\tconst isSwipeToPrev = (slideIndex === activeIndex || slideIndex === activeIndex + 1) && progress < 0 && progress > -1 && (isTouched || swiper.params.cssMode) && currentTranslate > startTranslate;\n\t\t\t\tif (isSwipeToNext || isSwipeToPrev) {\n\t\t\t\t\tconst subProgress = (1 - Math.abs((Math.abs(progress) - 0.5) / 0.5)) ** 0.5;\n\t\t\t\t\trotate += -28 * progress * subProgress;\n\t\t\t\t\tscale += -0.5 * subProgress;\n\t\t\t\t\ttXAdd += 96 * subProgress;\n\t\t\t\t\ttY = `${-25 * subProgress * Math.abs(progress)}%`;\n\t\t\t\t}\n\t\t\t\tif (progress < 0) {\n\t\t\t\t\t// next\n\t\t\t\t\ttX = `calc(${tX}px ${rtl ? '-' : '+'} (${tXAdd * Math.abs(progress)}%))`;\n\t\t\t\t} else if (progress > 0) {\n\t\t\t\t\t// prev\n\t\t\t\t\ttX = `calc(${tX}px ${rtl ? '-' : '+'} (-${tXAdd * Math.abs(progress)}%))`;\n\t\t\t\t} else {\n\t\t\t\t\ttX = `${tX}px`;\n\t\t\t\t}\n\t\t\t\tif (!swiper.isHorizontal()) {\n\t\t\t\t\tconst prevY = tY;\n\t\t\t\t\ttY = tX;\n\t\t\t\t\ttX = prevY;\n\t\t\t\t}\n\t\t\t\tconst scaleString = progress < 0 ? `${1 + (1 - scale) * progress}` : `${1 - (1 - scale) * progress}`;\n\n\t\t\t\t/* eslint-disable */\n\t\t\t\tconst transform = `\n        translate3d(${tX}, ${tY}, ${tZ}px)\n        rotateZ(${params.rotate ? rtl ? -rotate : rotate : 0}deg)\n        scale(${scaleString})\n      `;\n\t\t\t\t/* eslint-enable */\n\n\t\t\t\tif (params.slideShadows) {\n\t\t\t\t\t// Set shadows\n\t\t\t\t\tlet shadowEl = slideEl.querySelector('.swiper-slide-shadow');\n\t\t\t\t\tif (!shadowEl) {\n\t\t\t\t\t\tshadowEl = createShadow('cards', slideEl);\n\t\t\t\t\t}\n\t\t\t\t\tif (shadowEl) shadowEl.style.opacity = Math.min(Math.max((Math.abs(progress) - 0.5) / 0.5, 0), 1);\n\t\t\t\t}\n\t\t\t\tslideEl.style.zIndex = -Math.abs(Math.round(slideProgress)) + slides.length;\n\t\t\t\tconst targetEl = effectTarget(params, slideEl);\n\t\t\t\ttargetEl.style.transform = transform;\n\t\t\t}\n\t\t};\n\t\tconst setTransition = duration => {\n\t\t\tconst transformElements = swiper.slides.map(slideEl => getSlideTransformEl(slideEl));\n\t\t\ttransformElements.forEach(el => {\n\t\t\t\tel.style.transitionDuration = `${duration}ms`;\n\t\t\t\tel.querySelectorAll('.swiper-slide-shadow').forEach(shadowEl => {\n\t\t\t\t\tshadowEl.style.transitionDuration = `${duration}ms`;\n\t\t\t\t});\n\t\t\t});\n\t\t\teffectVirtualTransitionEnd({\n\t\t\t\tswiper,\n\t\t\t\tduration,\n\t\t\t\ttransformElements\n\t\t\t});\n\t\t};\n\t\teffectInit({\n\t\t\teffect: 'cards',\n\t\t\tswiper,\n\t\t\ton,\n\t\t\tsetTranslate,\n\t\t\tsetTransition,\n\t\t\tperspective: () => true,\n\t\t\toverwriteParams: () => ({\n\t\t\t\twatchSlidesProgress: true,\n\t\t\t\tvirtualTranslate: !swiper.params.cssMode\n\t\t\t})\n\t\t});\n\t}\n\n\tconst modules = [Virtual, Keyboard, Mousewheel, Navigation, Pagination, Scrollbar, Parallax, Zoom, Controller, A11y, History, HashNavigation, Autoplay, Thumb, freeMode, Grid, Manipulation, EffectFade, EffectCube, EffectFlip, EffectCoverflow, EffectCreative, EffectCards];\n\tSwiper.use(modules);\n\n\treturn Swiper;\n\n})();"],"file":"app-products.js"}